<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ 中 const 的使用要点</title>
    <url>/myblog/2020/10/13/C/C++%20%E4%B8%AD%20const%20%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A6%81%E7%82%B9/</url>
    <content><![CDATA[<h1 id="C-中-const-的使用要点"><a href="#C-中-const-的使用要点" class="headerlink" title="C++ 中 const 的使用要点"></a>C++ 中 const 的使用要点</h1><hr>
<p>const语法变化多端，但是却并非高深莫测</p>
<p>1、注意以下的几个 <code>const</code> 用法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *p = greeting; 			<span class="comment">//non-const pointer, non-const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * p = greeting;  	 <span class="comment">//non-const pointer, const data</span></span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> p = greeting;		 <span class="comment">//const pointer, non-const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> p = greeting; <span class="comment">//const pointer, const data;</span></span><br></pre></td></tr></table></figure>

<p><strong>const 在星号左边表示被指物是常量，const 在星号右边表示指针自身是常量</strong></p>
<p>2、如果被指物是常量，const 在类型名的前后意义都相同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">const</span> Widget* pw)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(Widget <span class="keyword">const</span>* pw)</span></span>;</span><br><span class="line"><span class="comment">// 两者没有区别</span></span><br></pre></td></tr></table></figure>

<p>3、STL迭代器是以指针为根据塑膜出来的</p>
<p>声明迭代器为 const 和 声明 指针为 const 的大致方法相同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.begin();</span><br><span class="line"><span class="comment">//iter 的作用和 T* const 类似</span></span><br><span class="line">*iter = <span class="number">10</span>; <span class="comment">// 可以改变指向物</span></span><br><span class="line">++iter; <span class="comment">// 错误！ 不可以改变 iter, 它是一个常量</span></span><br><span class="line"></span><br><span class="line">str::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator cIter = vec.begin();</span><br><span class="line"><span class="comment">//cIter 的作用和 const T* 类似</span></span><br><span class="line">*cIter = <span class="number">10</span>; <span class="comment">// 错误！不可以改变 *cIter, 它是一个常量</span></span><br><span class="line">++cIter; <span class="comment">// 可以改变 cIter 的指向</span></span><br></pre></td></tr></table></figure>



<h3 id="一、const-成员函数"><a href="#一、const-成员函数" class="headerlink" title="一、const 成员函数"></a>一、const 成员函数</h3><p>将 const 实施于成员函数的目的是为了能将其用于 const 对象身上</p>
<p>const 成员函数的重要性体现在下面两个方向：</p>
<ul>
<li>使 class 接口更加便于理解(可以清楚的看到哪个函数能够改变对象内容而哪一个不行)</li>
<li>使”操作 const 对象”变为可能</li>
</ul>
<p><em>两个成员函数如果常量性(constness)不同，那么可以被重载</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">class <span class="title">TextBlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	......</span><br><span class="line">    	<span class="keyword">const</span> chat&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">    	&#123;</span><br><span class="line">        	<span class="keyword">return</span> text[position];</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position)</span><br><span class="line">    	&#123;</span><br><span class="line">        	<span class="keyword">return</span> text[position];</span><br><span class="line">    	&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对其做一下处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tb[<span class="number">0</span>]; <span class="comment">//读一个 non-const TextBlock</span></span><br><span class="line">tb[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;	    <span class="comment">//写一个 non-const TextBlock</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ctb[<span class="number">0</span>];<span class="comment">//读一个 const TextBlock</span></span><br><span class="line">ctb[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;       <span class="comment">//错误， 不能写一个 const TextBlock</span></span><br></pre></td></tr></table></figure>

<p>错误的原因是企图对一个”const operator[]”返回的 const char&amp; 实施赋值操作</p>
<p>现在对于成员函数的理解有两个主流理解：</p>
<ul>
<li><p>bitwise constness(Physcial constness)</p>
<p>成员函数只有在不改变对象的任何的任何成员变量(static 除外)时才能说是const。</p>
</li>
<li><p>logical constness</p>
<p>一个 const 成员函数可以修改它所处理的对象内的某些 bits，但是只有在客户端检测不出来的情况下才能这样处理</p>
</li>
</ul>
<h5 id="1、bitwise-constness"><a href="#1、bitwise-constness" class="headerlink" title="1、bitwise constness"></a>1、bitwise constness</h5><p>这种理解的好处是非常容易去检测是否遵守了 bitwise constness 准则：只需要寻找成员变量的赋值动作。</p>
<p>但是缺点也很明显，许多不具备 const 性质的成员函数也能通过 bitwise 测试</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个需要于 C API 沟通的 TextBlock-like class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	...</span><br><span class="line">    	<span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">    	&#123;	<span class="keyword">return</span> pText[position];	&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">char</span>* pText;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面所示的 class 不恰当的将其 operator[] 声明为 const 成员函数，而该函数返回一个 referrence 指向对象内部值。</p>
<p>当编译器认为它是 bitwise constness 时</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> CTextBlock <span class="title">cctb</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span>* pc = &amp;cctb[<span class="number">0</span>]; <span class="comment">// 调用 const operator[] 取得一个指针，指向cctb[0]</span></span><br><span class="line">*pc = <span class="string">&#x27;J&#x27;</span>; <span class="comment">// 修改了 cctb[0]</span></span><br></pre></td></tr></table></figure>

<h5 id="2、logical-constness"><a href="#2、logical-constness" class="headerlink" title="2、logical constness"></a>2、logical constness</h5><p>有时候 TextBlock class 要 cache 文本区块的长度，以便后面使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	...</span><br><span class="line">    	<span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">char</span>* pText;</span><br><span class="line">    	<span class="built_in">std</span>::<span class="keyword">size_t</span> textLength;</span><br><span class="line">    	<span class="keyword">bool</span> lengthIsValid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">CTextBlock::length</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lengthIsVailid)</span><br><span class="line">    &#123;</span><br><span class="line">        textLength = <span class="built_in">std</span>::<span class="built_in">strlen</span>(pText);</span><br><span class="line">        lengthIsValid = <span class="literal">true</span>; <span class="comment">// 这种改动很重要，但是不被编译器接受。编译器坚持 bitwise constness</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法：使用 <code>mutable</code> 关键字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> textLength;</span><br><span class="line"><span class="keyword">mutable</span> <span class="keyword">bool</span> lengthIsValid;</span><br></pre></td></tr></table></figure>



<h3 id="二、在-const-和-non-const-成员函数中避免重复"><a href="#二、在-const-和-non-const-成员函数中避免重复" class="headerlink" title="二、在 const 和 non-const 成员函数中避免重复"></a>二、在 const 和 non-const 成员函数中避免重复</h3><p>对于在 上一节提到的用 mutable 解决 bitwise-const 错误理解的问题，是一个不错的解法，但是不能适用于所有的 const 相关难题。</p>
<p>当 operator[] 操作过于复杂的时候，代码的重复量会造成很大的困扰</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...; <span class="comment">// bounding checking</span></span><br><span class="line">        ...; <span class="comment">// log access data</span></span><br><span class="line">        ...; <span class="comment">// verify data integrity</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> position) </span><br><span class="line">    &#123;</span><br><span class="line">        ...; <span class="comment">// bounding checking</span></span><br><span class="line">        ...; <span class="comment">// log access data</span></span><br><span class="line">        ...; <span class="comment">// verify data integrity</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上的代码重复发，编译时间，维护，代码膨胀……问题会让人头大</p>
<p>这时需要做的是： <strong>实现 operator[] 机制一次， 并两次使用</strong></p>
<p>需要使用的方法是: **casting away constness **      Tips: 除非是有特殊需求，一般不会推荐使用 casting 操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...; <span class="comment">// bounding checking</span></span><br><span class="line">        ...; <span class="comment">// log access data</span></span><br><span class="line">        ...; <span class="comment">// verify data integrity</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> position) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;( <span class="comment">// 第二次casting将 op[] 的 const 性质消除</span></span><br><span class="line">            	<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>) <span class="comment">// 第一次casting，将*this的原始类型从TextBlock&amp; 转型为 const TextBlock&amp; </span></span><br><span class="line">            		[position]</span><br><span class="line">        	)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码长尝试用 <code>non-cost operator[]</code> 调用它的 <code>const</code> 兄弟</p>
<p>还有一点要注意：<strong>不要用 const 版本调用 non-const 版本来避免重复</strong> </p>
<p>否则你之前的承诺： <strong>const 成员函数承诺不改变其对象的逻辑状态</strong> 便没有任何价值！！！💔💔💔</p>
<p>const 在编程的时候是一个强有力的帮手，但是要小心其使用 💖 💖 💖</p>
<p>总结：</p>
<ul>
<li>将某些东西声明为 const 可以帮助编译器检测错误用法。const 可以施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体</li>
<li>编译器会强制实施 bitwise constness，但是自己在编写程序的时候要使用 “概念上的常量” conceptual constness</li>
<li>当const 和 non-const 成员函数有相同的实现的时候，要用 non-const  版本来调用 const 版本</li>
</ul>
<p>​<center><font face="宋体" size=20 color=#8B008B>FINE</font></center></p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++ 内存布局</title>
    <url>/myblog/2020/09/22/C/C++%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<hr>
<h2 id="C-C-内存布局"><a href="#C-C-内存布局" class="headerlink" title="C/C++ 内存布局"></a>C/C++ 内存布局</h2><h4 id="一、可执行映像"><a href="#一、可执行映像" class="headerlink" title="一、可执行映像"></a>一、可执行映像</h4><p>&emsp;&emsp;当生成C/C++程序的时候，链接器生成可执行文件。在UNIX和大多数游戏主机上面使用一种 <strong><em>可执行与可链接格式(executable and linkable format, ELF)</em></strong> 。在这些平台上的可执行文件使用后缀 <strong><em>.elf</em></strong> 。在Windows中的可执行文件同意类似与ELF，使用 <strong><em>.exe</em></strong> 作为扩展名。</p>
<p>映像文件一般最少由一下几个部分构成：</p>
<ul>
<li><p>代码段(text/code segement)</p>
<blockquote>
<p>程序中定义的函数的全部机械码</p>
</blockquote>
</li>
<li><p>数据段(data segment)</p>
<blockquote>
<p>已经初始化的全部静态变量<br>将由连接器为其分配内存，并且填如适当的初始值</p>
</blockquote>
</li>
<li><p>BBS 段(BBS segement)</p>
<blockquote>
<p>BBS是一种老旧的叫法，意为 <strong><em>“由符号开始的块(block started by symbol)”</em></strong>。包含程序定义中所有的未初始化的全局变量和静态变量，在C/C++中未初始化的全局变量和静态变量全为零。</p>
</blockquote>
</li>
<li><p>只读数据段(read only data segement)</p>
<blockquote>
<p> 又称为 <strong><em>rodata</em></strong> 段,包含程序中定义的只读(常量)全局变量。<br> 比如：浮点常量，用const关键字声名的全局对象实例……</p>
<blockquote>
<p>tips: 编译器通常会把整数常量视为<strong>明示常量</strong>(manifast constant)，并且直接把明示常量插入机器码中，直接占用代码段的存储空间而不存储于只读数据段。</p>
</blockquote>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>Memory Management</tag>
        <tag>GameDev</tag>
      </tags>
  </entry>
  <entry>
    <title>Linkers and loaders (1)</title>
    <url>/myblog/2020/10/24/C/Linkers%20and%20Loads/</url>
    <content><![CDATA[<h1 id="Linkers-and-Loads"><a href="#Linkers-and-Loads" class="headerlink" title="Linkers and Loads"></a>Linkers and Loads</h1><font size = 4.5>

<h3 id="一、INTRODUCTION"><a href="#一、INTRODUCTION" class="headerlink" title="一、INTRODUCTION"></a>一、INTRODUCTION</h3><hr>
<p>Translating high-level language into a properly formatted binary string before it can be executed is necessary. In most basic form this transformation process occurs in two stages:</p>
<ol>
<li>A user’s (source) program is translated into machine language.</li>
<li>The translated program is stored for immediate or future execution</li>
</ol>
<p><strong>loading</strong>: storing into main memory</p>
<p><strong>linking</strong>: combine subprograms into a composite program</p>
<h3 id="二、LOADERS"><a href="#二、LOADERS" class="headerlink" title="二、LOADERS"></a>二、LOADERS</h3><hr>
<p>Loading a translated program into memory is logically distinct from the translation of that program, separate software modules, called loaders, have been developed to accomplish the loading operation. </p>
<p>There are two types:</p>
<ol>
<li>Binary loaders</li>
<li>Relocating loaders</li>
</ol>
<p>The relocating loader is responsible for loading into main memory a program in relocatable binary form and updating (relocation) all relative addresses.</p>
<h3 id="三、LINKERS"><a href="#三、LINKERS" class="headerlink" title="三、LINKERS"></a>三、LINKERS</h3><hr>
<p>Linking could be carried out at 7 different times:</p>
<ul>
<li>source program coding time</li>
<li>after coding but before translation time</li>
<li>at translation time</li>
<li>after translation but before loading time</li>
<li>at loading time</li>
<li>after loading but before execute time</li>
<li>at execute time</li>
</ul>
<p><strong>Address binding</strong>: translation  or mapping of a logical into a physical address.</p>
<p><strong>Linking process</strong>: binding (combining) independent logical spaces into one composite logical space.</p>
<h3 id="四、THE-LINKAGE-EDITOR"><a href="#四、THE-LINKAGE-EDITOR" class="headerlink" title="四、THE LINKAGE EDITOR"></a>四、THE LINKAGE EDITOR</h3><hr>
<p>On the IBM System/360, there exist a sophisticated linker, called the <code>Linkage Eeditor</code> , and a simple relocating loader referred to as <code>Program Fetch</code> .</p>
<p>Linkage Editor is responsible for the following functions:</p>
<ul>
<li><p>Primary function: (1) Linking together independently translated modules.</p>
</li>
<li><p>Secondary function: (1) Overlaying processing.</p>
<p>​                                 (2) Program modification.</p>
<p>​                                 (3) Library access.</p>
</li>
</ul>
<p>The inputs accepted  can be divided into two groups: <code>input modules</code> &amp; <code>Linkage Editor control statements</code>. </p>
<p>Input modules are further classified as being either <code>Object Modules</code> or <code>Load modules</code>. These two are similar in structure.</p>
<p>Object module: The output  produced by the language translators(IBM System/360). This output consists of the machine language code for the translated program, relocation information, and a table indicating the definition and use of external symbols.</p>
<p>Linking Together a Set of Modules:</p>
<p>​        In linking together a set of modules, the Linkage Editor is primarily responsible for:</p>
<p>​            (1) assigning address.</p>
<p>​            (2) relocating Address Constants.</p>
<p>​            (3) create an output module (Load Module).</p>
<h3 id="四、SUMMARY"><a href="#四、SUMMARY" class="headerlink" title="四、SUMMARY"></a>四、SUMMARY</h3><hr>
<p>The linking together of independently translated programs is the responsibility of the <strong>Linkage Editor</strong> , and a major part of the language processing burden is on the language translators whose responsibility is not only to translate source programs into a form which is very close to machine language, but also to format addresses in a base plus displacement form and to create the Object Module.</p>
<p>If the various stages of the language transformation process are viewed as a function of time, it is generally true that <strong>early binding allows more efficient implementations</strong> while <strong>late binding facilitates program debugging and modification.</strong></p>
<p>Features as elaborate editing capabilities and overlay processing, which produce a powerful and sophisticated linker, are at a high cost. So flexibility provided by simple linkers and relocating loaders has a definite place in modern OS.</p>
</font>




<div align = "right">Computing Surveys Vol 4, No 3, Sep 1972</div>


]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>Linkers and loaders</tag>
        <tag>Operation Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>Virtual Memory Series I</title>
    <url>/myblog/2020/10/25/C/Virtual%20Memory%EF%BC%9A%20Issues%20of%20Implementation/</url>
    <content><![CDATA[<h1 id="Virtual-Memory：-Issues-of-Implementation"><a href="#Virtual-Memory：-Issues-of-Implementation" class="headerlink" title="Virtual Memory： Issues of Implementation"></a>Virtual Memory： Issues of Implementation</h1><font size = 4.5>
---

<p>In 1998,  there has not been much agreement on the form that what kind of support should modern processors take for “Virtual Memory”.</p>
<p>Thus in that time they have two ways for system-level software but seems somewhat unattractive:</p>
<ol>
<li>Writing software to fit many different architectures, which can compromise performance and reliabilities.</li>
<li>Inserting layers of software to emulate a particular hardware interface, which essentially forces one hardware design to look like another. Inserting this <strong>hardware abstraction layer</strong> hides hardware particulars from the higher levels of software but also compromise performance and compatibility.</li>
</ol>
<p>Today’s  OSs and microprocessor are geared toward demand-paged virtual memory.</p>
<h3 id="一、BASIC-CONCEPTS"><a href="#一、BASIC-CONCEPTS" class="headerlink" title="一、BASIC CONCEPTS"></a>一、BASIC CONCEPTS</h3><hr>
<p>A well-designed virtual-memory system system:</p>
<ul>
<li>The main memory holds only the most often used portions of a process’s address space.</li>
<li>Other portions are stored on disk and retrieved as needed.</li>
</ul>
<p>The mapping is a function, a given virtual page can have only one physical location.  However, the inverse mapping is not necessarily a function. This allows several virtual pages mapped to the same page frame. This is called <code>virtual-address aliasing</code>, which lets processes or threads share memory and supports different ‘views’ of data with different protections or behaviors.</p>
<p>If an item can be paged, it implies that the item resides in virtual space. The OS allocates physical memory for the item itself only when the item is paged in.</p>
<h3 id="1、Page-table-entries"><a href="#1、Page-table-entries" class="headerlink" title="1、Page table entries"></a>1、Page table entries</h3><p>At the minimum, a PTE indicates whether its virtual page is in memory, on disk, or unallocated.</p>
<p>Form a PTE, the OS must be able to determine:</p>
<ul>
<li>the ID of the page’s owner </li>
<li>the virtual page number</li>
<li>the page’s location in memory (page frame number) or location on disk (an offset into a swap file)</li>
<li>a valid bit contains a valid translation or not</li>
<li>a reference bit, whether the page was recently accessed</li>
<li>a modify bit, whether the page was recently written</li>
<li>page-protection bits, read-write、read-only and so on</li>
</ul>
<p>However, for efficiency reasons, all of the information an OS needs <strong>is rarely stored explicitly in each PTE.</strong></p>
<h3 id="2、Translation-lookaside-buffers"><a href="#2、Translation-lookaside-buffers" class="headerlink" title="2、Translation lookaside buffers"></a>2、Translation lookaside buffers</h3><p>To speed translation, most hardware systems provide a cache for PTEs, called a translation lookaside buffer(TLB).</p>
<p>In some implementations the OS searches the page table after a TLB miss; in others, a hardware state machine conducts the search.</p>
<p>If a page fault interrupts the OS, which must then do one of three things:</p>
<ol>
<li>Retrieve the page from disk and place it into memory.</li>
<li>Create a new page if the page does not exist (as when a process allocates a new stack frame in virgin territory).</li>
<li>If the access is to illegal space——send the process an error signal.</li>
</ol>
<p>Faulting address: The virtual address causing a TLB miss. This is not meant to imply that all TLB misses result in page faults.</p>
<p>The inclusion between the TLB and main memory: If a page is in memory, its mapping <strong>may or may not be in the TLB</strong>, but if a page’s mapping is in the TLB, the page <strong>must be in physical memory.</strong> </p>
<h3 id="二、PAGE-TABLE-ORGANIZATION"><a href="#二、PAGE-TABLE-ORGANIZATION" class="headerlink" title="二、PAGE TABLE ORGANIZATION"></a>二、PAGE TABLE ORGANIZATION</h3><hr>
<p>Few generations ago, we use signal-level table, <strong>direct table</strong>.</p>
<p>Table walking: the search of the page table.</p>
<p>There are two primary types of page table organization: <code>forward-mapped or hierarchical page table</code> index by the virtual page number; and the <code>inverse mapped or inverted page table</code> index by the page frame number.</p>
<h3 id="1、-Hierarchical-page-tables"><a href="#1、-Hierarchical-page-tables" class="headerlink" title="1、 Hierarchical page tables"></a>1、 Hierarchical page tables</h3><p>Based on the idea: <strong>A large data array can be mapped by a smaller array, which can in turn be mapped be an even smaller array.</strong></p>
<p>Most OSs wire down root-level table in memory while the process is running.</p>
<p>There are two access methods for the hierarchical page table: <code>top-down</code> or <code>bottom-up</code>.</p>
<p>Top-down: uses physical address to reference the PTEs in the table.</p>
<p>Bottom-up: uses virtual address.</p>
<h3 id="2、Top-down-traversal"><a href="#2、Top-down-traversal" class="headerlink" title="2、Top-down traversal"></a>2、Top-down traversal</h3><p>Often used in hardware table-walking schemes(Inter’s IA-32 architecture).</p>
<h3 id="3、Bottom-up-traversal"><a href="#3、Bottom-up-traversal" class="headerlink" title="3、Bottom-up traversal"></a>3、Bottom-up traversal</h3><p>The top-down access method requires as many memory references as there are table levels.</p>
<p>On a TLB miss, the virtual address for this user PTE is used to load the PTE from the user page table.</p>
<p>The following pseudo-code briefly illustrates these steps:</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">load user data /* load misses TLB */</span><br><span class="line">    	/* invokes TLB-miss handler */</span><br><span class="line">    	construct virtual address for user PTE</span><br><span class="line">	    load user PTE /* load misses TLB */</span><br><span class="line">	    	/* invoke root TLB-miss handler: */</span><br><span class="line">		    construct physcial address for root PTE</span><br><span class="line">		    load root PTE /* can not cause TLB miss, because it uses a </span><br><span class="line">            				physical address*/</span><br><span class="line">             put root PTE into TLB</span><br><span class="line">             jump to faulting instruction</span><br><span class="line">        /* return to user TLB-miss handler: */</span><br><span class="line">        load user PTE /* this time load succeeds */</span><br><span class="line">        put user PTE into TLB</span><br><span class="line">        jump to faulting instruction</span><br><span class="line">/* return to user mode */</span><br><span class="line">load user data /* this time load succeeds */</span><br></pre></td></tr></table></figure>









<h3 id="4、Inverted-page-tables"><a href="#4、Inverted-page-tables" class="headerlink" title="4、Inverted page tables"></a>4、Inverted page tables</h3><p>Instead of one entry for every virtual page belonging to a process, the inverted page table has <strong>one entry for every page frame in main memory.</strong></p>
<p>The index of the PTE in the inverted table is equal to the page frame number of the page it maps. Thus, rather than scaling with the size of the virtual space, it <strong>scales with the size of physical memory.</strong> It compact in size, making it a good candidate for the hardware-managed mechanism that need the table to be wired down in memory.</p>
<p>Since different virtual page numbers might produce identical hash values, a <code>collision-chain</code> mechanism is used to let these mapping exist int the table simultaneously.</p>
<p>Noting that in classical inverted-table implementations, the PTE is too large compare to hierarchical table. As a trade-off to keep the table small, the designers of early systems increased the number of memory accesses per lookup. They added a level of indirection, the <strong>hash anchor table(HAT).</strong></p>
<p>Since the entries in the hash anchor table are smaller than the entries in the inverted table, it is more memory efficient <strong>to increase the size of the hash anchor table to reduce the average collision-chain length.</strong></p>
<p>the following steps briefly illustrate this mechanism:</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">Step 1:</span><br><span class="line">	faulting virtual page number is hashed, indexing the hash anchor table index.</span><br><span class="line">	Corresponding anchor-table entry is loaded and points to the chain head for that hash value.</span><br><span class="line">step 2:</span><br><span class="line">	The indecated PTE loaded.</span><br><span class="line">	Comparing its virtual page number to the faulting virtual page number.</span><br><span class="line">	if (marched) </span><br><span class="line">		step 3a:</span><br><span class="line">			Algorithm terminates, the mapping, composed of the virtual page number and the page 	frame numbers(PTE&#x27;s index), is placed into the TLB.</span><br><span class="line">	else</span><br><span class="line">		step 3b</span><br><span class="line">			The PTE referrences the next entry in the chain, or indicates that it is the last chain in the chain.</span><br><span class="line">If there is a next entry, it is loaded and compared.</span><br><span class="line">If the last entry fails to match, algorithm terminates and cases a page fault.</span><br><span class="line">			</span><br></pre></td></tr></table></figure>

<h3 id="三、DETAILS-AND-THEIR-DEVILS"><a href="#三、DETAILS-AND-THEIR-DEVILS" class="headerlink" title="三、DETAILS (AND THEIR DEVILS)"></a>三、DETAILS (AND THEIR DEVILS)</h3><hr>
<p>The choice between hierarchical and inverted page tables is not an obvious one: There are many trade-offs between performance and memory usage. Implementations of shared memory width vary widely in performance, <strong>especially with different hardware support</strong>. (i.e. virtual caches requires more consistency management than physical caches).</p>
<p>The address-space protection scheme is also heavily dependent on hardware support and has great impact on the shared-memory implementation.</p>
<p>Also, the TLB can be managed by the OS or managed in hardware, presenting a trade-off between flexibility and performance. </p>
<p>It is not surprising that <strong>the interactions are often subtle and  nonintuitive.</strong></p>
<h3 id="1、Share-memory"><a href="#1、Share-memory" class="headerlink" title="1、Share memory"></a>1、Share memory</h3><p>There are several implementation possibilities for shared memory. One of the most common is <code>virtual address aliasing</code>, or simply <code>aliasing</code>. In this scheme, each mapping to the same physical page requires its own logical PTE.</p>
<p>Maintaining multiple PTEs makes it possible for different processes:</p>
<ul>
<li>Using different virtual address for the same physical data.</li>
<li>Mapping the same physical data with different protections.</li>
<li>For different virtual references to the same physical data to cause different behaviors. </li>
</ul>
<p>primary disadvantage of aliasing: Increasing overhead of managing multiple mappings to the same physical page.</p>
<p>A variation on aliasing is to <strong>share portions of page tables whenever data is shared.</strong></p>
<p>Compared to the normal aliasing mechanism, this variation reduces the overhead of mapping PTEs and reduces the impact of multiple PTEs on the TLB.</p>
<p>Disadvantage: It can require sharing at large granularities (It can be overcome if the hardware translation mechanism is segmented and supports protection at the segment level).</p>
<p>Another alternative to aliasing is to have all processes share a global virtual address space. This space is often called a “flat” address space because <strong>it is not divided into disjunct per-process spaces by address-space identifiers.</strong></p>
<p>Typically, these signal address-space OSs map the entire space of all processes with a single page table, which considerably reduces the management overhead. (Unix-based OSs and PA-RISC system use a global address space)</p>
<h3 id="2、Address-space-identifier-versus-segmentation"><a href="#2、Address-space-identifier-versus-segmentation" class="headerlink" title="2、Address-space identifier versus segmentation"></a>2、Address-space identifier versus segmentation</h3><p> Two common hardware assists for providing address-space protection are <code>address-space identifiers</code> and <code>page segmentation</code>.</p>
<p><strong>Address-space identifiers</strong> found in: <code>MIPS</code>, <code>Alpha</code>, and <code>sparc</code> architectures, extend virtual addresses and distinguish them form those generate by different processes. multiple processes can coexist, each thinking it owns the full extend of a 32-bit address space. Each process is unable to produce addresses that mimic those of other processes, because to do so it must control the contents of the protected register holding the address-space identifier.</p>
<p>The OS place a process’s address-space identifier in a protected register, and every virtual address the process generates is concatenated with the address-space identifier.</p>
<p><strong>In page segmentation</strong>, (as implemented in the <code>PowerPC</code>, <code>PA-RISC</code> , and <code>X86</code> architectures), virtual-physical translation occurs in two steps: </p>
<ol>
<li>User addresses are mapped onto a global address at the granularity of segments.</li>
<li>Virtual addresses from the global space are mapped onto physical memory at the granularity of pages.</li>
</ol>
<p>A process address space is usually composed of many segments, so the OS maintains a set of segment identifiers for each process. It can also provide address-space protection.</p>
<p>Segment translation from the process address space to the global address is like the hardware scheme for address-space identifiers.</p>
<p>Segmentation is therefore analogous to having multiple address-space identifiers per process—one for each segment in the user address space.</p>
<p>Address-space identifiers and segmentation interact with shared memory differently. Conceptually, shared memory acts in opposition to address-space protection schemes. </p>
<p>With address-space identifiers, this is often done by explicitly duplicating mapping information across page tables. Or by marking a shared page as visible to all processes—explicitly turning off protection for that page.</p>
<p>Segments, in contrast, allow both protection and fine-grained sharing. Two processes can safely share a segment, and can do so without making segment visible to other processes.</p>
<h3 id="3、TLBs-revisited"><a href="#3、TLBs-revisited" class="headerlink" title="3、TLBs  revisited"></a>3、TLBs  revisited</h3><p>(tips: flush–&gt;means to clean all.)</p>
<p>Either the OS or the hardware can refill the TLB when a TLB miss occurs.</p>
<p><strong>Hardware-managed TLB</strong>: a hardware state machine walks the page table, there is no interrupt or interaction with the instruction cache.</p>
<p><strong>Software-managed TLB</strong>: the general interrupt mechanism invokes a software TLB-miss handler — a primitive in the OS that is usually 10-100 instructions long. The use of the interrupt mechanism adds to the cost by flushing the pipeline, possibly removing many instructions from the reorder buffer. This can result in hundreds of cycles.</p>
<p>However, the software-managed TLB design allows the OS to choose any page table organization, whereas the hardware-managed scheme defines a page table organization for the OS. This flexibility in the software-managed scheme can outweigh its potentially higher per-miss cost .</p>
<p>The PA-7200 uses a hybrid approach,  implementing the initial probe of its hashed page table in hardware, and — if this initial probe fails — walking the rest of the page table in software.</p>
<p>TLB does not need to be flushed on process context switch unless there are globally shared pages. </p>
<p><strong>Flushing</strong> is typically required only whenever the OS reassigns an address-space identifier or segment identifier to a new process (such as at process creation), or when there are fewer address-space identifiers than currently active processes, which necessitates a temporary ID remapping. If the protection mechanism goes unused flushing is also required. </p>
<p>In most case, only those entries tagged with that address-space identifier need to be flushed.</p>
<p>OS must often <strong>invalidate the entire TLB contents</strong> or <strong>individually invalidate each entry that matches the address-space identifier.</strong> Typically, it is cheaper to invalidate all TLB contents than to maintain a list of entries to be flushed on context switch as this list will typically be large and expensive to maintain. </p>
<h3 id="四、Foresight"><a href="#四、Foresight" class="headerlink" title="四、Foresight"></a>四、Foresight</h3><p>There is wide diversity in how today’s commercial processors support memory management. However, the specific details of one processor’s memory-management architecture do not seem to confer a clear performance advantage over another’s. Why? <strong>incompatible</strong> from inadequate hardware support.</p>
<p>Virtual caches requires no address translation when the data is found in the caches are large enough, there is rarely a need to go to memory. Address translation would be performed only on the rare cache miss and could therefore afford to be expensive.</p>
<p>Instead of using hardware, the OS itself could perform virtual-memory functions — including address translation and protection checks — resulting in increased flexibility and simplifying the job of porting system software.</p>
<h3 id="五、Typical-architecture"><a href="#五、Typical-architecture" class="headerlink" title="五、Typical architecture"></a>五、Typical architecture</h3><h3 id="1、MIPS-Architecture"><a href="#1、MIPS-Architecture" class="headerlink" title="1、MIPS Architecture"></a>1、MIPS Architecture</h3><p>OS handles TLB misses entirely in software. The OS walks the page table, fills the TLB, and can implement virtually any TLB replacement policy.</p>
<p>The hardware supports a bottom-up hierarchical page table through the TLB context register, which holds a virtual address partitioned into a software-loaded segment and a hardware-loaded segment.</p>
</font>
]]></content>
      <categories>
        <category>Operating Systems</category>
      </categories>
      <tags>
        <tag>Memory Management</tag>
        <tag>Operation Systems</tag>
        <tag>Virtual Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>EffectC++</title>
    <url>/myblog/2021/04/21/C/Effective%20C++%2055%20(04-12)/</url>
    <content><![CDATA[<hr>
<p>04 确定对象使用前已经初始化<br>（1）<br>ABEntry::ABEntry(const std::string&amp; name, const std::string&amp; address, const std::list<PhoneNumber>&amp; phones)<br>                :theName(name),<br>                theAddress(address),<br>                thePhones(phones),<br>                numTimesConsulted(0)<br>                {}</p>
<p>比起经由赋值操作完成的“伪初始化”，通过成员列初值完成的“真正初始化”更加可取。 注意在<br>成员初值列中使用成员时最好按照其声名次序来使用。</p>
<p>（2）<br>C++对 定义于不同编译单元内的non-local static对象 的初始化顺序没有明确的定义</p>
<p>但是因为C++保证，函数内的local static对象，在“函数被调用期间” “第一次遇到该对象的定义式” 的时候<br>初始化，所以用函数调用替换掉直接调用对象可以保证初始化的顺序。并且这样使用可以减少构造和析构的次数<br>e.g.</p>
<p>class FileSystem<br>{<br>public:<br>    std::size_t numDisks() const;<br>};<br>extern FileSystem tfs;</p>
<p>class Directory<br>{<br>public:<br>    Directory(params);<br>};</p>
<p>Directory::Directory(params)<br>{<br>    std::size_t disks = tfs.numDisks();<br>}</p>
<p>此时用户创建一个 Directory 对象，来放临时文件<br>Directory tempDir(params);</p>
<p>在这种情况下，就按照前面所描述的情况来使用，大概情况如下：</p>
<p>class FileSystem {};<br>FileSystem &amp;tfs()  // 类似一种仿真函数<br>{<br>    static FileSystem fs;<br>    return fs;<br>}<br>class Directory {};<br>Directory::Directory(params)<br>{<br>    std::size_t disks = tfs().numDisks(); // 将 tfs.numDisks() 改为 tfs().numDisks()<br>}<br>Directory&amp; tempDir() // 现在用 Directory&amp; tempDir() 函数来替换 tempDir 对象<br>{<br>    static Directory td;<br>    return td;<br>}</p>
<p>为了避免“跨单元编译之初始化”问题，最好用local static对象 替换non-local static对象。</p>
<hr>
<p>05 了解编译器默默编写并调用了哪些函数</p>
<p>default 构造函数<br>copy 构造函数<br>copy assignment 操作符<br>析构函数</p>
<hr>
<p>06 若不想使用编译器自动生成的函数，就应该明确拒绝</p>
<p>方法一： 将其 copy 构造函数 和 copy assignment 构造函数声明为 private 而且不需要将其定义<br>（因为不会使用）<br>class NoCopyable<br>{<br>public:<br>    …<br>private:<br>    NoCopyable(const NoCopyable&amp;);<br>    NoCopyable&amp; operator=(const NoCopyable&amp;);<br>};</p>
<p>方法二： 为了能在编译期间找到错误，可以构造一个专门阻止copying动作的 base class。<br>class Uncopyable<br>{<br>protected:<br>    Uncopyable();<br>    ~Uncopyable(); //允许derived对象构造和析构<br>private:<br>    Uncopyable(const Uncopyable&amp;);<br>    Uncopyable&amp; operator=(const Uncopyable&amp;);<br>};</p>
<p>使用时自需要继承它即可<br>class HomeForSale: private Uncopyable<br>{<br>    //     不需要提供 copy 和 assigned copy 函数<br>};</p>
<hr>
<p>07 为多态基类声明 virtual 析构函数</p>
<p>class TimeKeeper<br>{<br>public:<br>    TimeKeeper();<br>    ~TimeKeeper();<br>};</p>
<p>class AtomicClock: public TimeKeeper {};<br>class WaterClock: public TimeKeeper {};<br>class WristWatch: public TimeKeeper {};</p>
<p>TimeKeeper* getTimekeeper();</p>
<p>TimeKeeper* ptk = getTimekeeper();<br>…<br>delete ptk;<br>// 这里getTimeKeeper() 返回的指针指向一个 derived class 对象, 但是该对象却经由一个<br>// bass class 指针来删除，当前bass class 只有一个 non-virtual 析构函数，导致其结果<br>// 未定义。 产生诡异的 “局部销毁对象”！</p>
<p>解决办法： 将其bass class的析构函数声明为 virtual<br>class TimerKeeper<br>{<br>public:<br>    TimerKeeper();<br>    virtual ~TimerKeeper();<br>};<br>TimerKeeper* ptk = getTimekeeper();<br>…<br>delete ptk;</p>
<p>Tips: 如果一个 class 不含 virtual 函数。说明它并不希望被作为一个 bass class 来使用。<br>若此时再将其析构函数声明为 virtual 是非常不合适的。 将一个函数声明为 virtual 的时候<br>会改变该class的内存布局，并且降低其可移植性，通用性。<br>通常只有当class内至少有一个虚函数的时候，才将其析构函数声明为 virtual</p>
<p>给bass class 一个 virtual 析构函数，这个规则只适用于polymorphic base class 上，<br>这类classes的设计目的是为了通过bass class 接口来处理 derived class 对象。 其它的classes<br>就不应该声明 virtual 析构函数。</p>
<p>polymorphic base classes 应该声明一个 virtual  析构函数。如果 class 带任何 virtual 函数，<br>它就应该拥有一个 virtual 析构函数。</p>
<hr>
<p>08 别让异常逃离析构函数</p>
<p>当使用下面这个类来管理 DBConnection 对象;</p>
<p>class DBConn<br>{<br>public:<br>    …<br>    ~DBConn()<br>    {<br>        db.close();     // 确保数据库总是会被关闭。<br>    }<br>private:<br>    DBConnection db;<br>}</p>
<p>如果 <code>~DBConn()</code> 调用正常那么便不会有问题，但是只要没有调用 <code>~DBConn()</code> 那么该析构函数便会<br>传播该异常，允许其离开这个析构函数。<br>有以下两种解决办法：<br>1：如果 close() 抛出异常就结束程序，那么就通过调用 abort() 来完成;<br>DBConn::~DBConn()<br>{<br>    try { db.close(); }<br>    catch (…)<br>    {<br>        // 制作运转记录，记录下 close() 的调用失败<br>        std::abort();<br>    }<br>}<br>阻止异常从 close() 传播出去，调用 abort() 抢先将“不明确行为”置于死地</p>
<p>2：吞下因为调用 close() 而产生的异常<br>DBConn::~DBConn()<br>{<br>    try { db.close(); }<br>    catch (…)<br>    {<br>        // 制作运转记录，记录下 close() 的调用失败<br>    }<br>}<br>该方法主要是为了保证程序在遇到异常时还能继续运行下去而做的妥协，当然，这并不是一个好主意。<br>这两种情况都不能对“导致close()”抛出异常的情况做出反应</p>
<p>最好的设计方法还是提供一个 close() 函数给客户一个自己处理发生异常的。 当用户实在是不想自己<br>处理的时候，我们再使用上面两个方法。</p>
<p>class DBConn<br>{<br>public:<br>    …<br>    void close()<br>    {<br>        db.close();<br>        closed = true;<br>    }<br>    ~DBConn()<br>    {<br>        if (!ifclose())<br>        {<br>            try<br>            {<br>                db.close();<br>            }<br>            catch (…)<br>            {<br>                // 制作运转记录，记录下 close() 的调用失败<br>            }<br>        }<br>    }<br>private:<br>    DBConnection db;<br>    bool closed;<br>}</p>
<p><strong>** 析构函数绝对不要吐出异常 **</strong></p>
<hr>
<p>09 绝不在构造和析构过程中调用 virtual 函数</p>
<p>class Transaction<br>{<br>public:<br>    Transaction();<br>    virtual void logTransaction() const = 0;<br>    …<br>};<br>Transaction::Transaction<br>{<br>    …<br>    logTransaction();<br>}<br>class BuyTransaction: public Transaction<br>{<br>public:<br>    virtual void logTransaction() const;<br>    …<br>};<br>class SellTransaction: public Transaction<br>{<br>public:<br>    virtual void logTransaction() const;<br>};</p>
<p>当运行 BuyTransaction b;</p>
<p>时调用的 logTransaction() 的版本不是 BuyTransaction 的版本而是 Transaction 的版本；<br>原因时由于 base class 在构造的时候其 virtual 函数不会下降到 derived class 阶层。 其<br>对象的行为就会类似隶属于 base 类型。 也就是说，在析构和构造的时候，virtual 函数不是<br>virtual;</p>
<p>base class 的构造函数会先于 derived class 构造函数。 在 base class 构造完成的时候<br>derived class 还没有构造，在C++中绝对不能要求使用对象内部尚未初始化的部分。所以此时<br>bass class 的 virtual 函数绝对不会下降到 derived class 阶层。</p>
<p>及对象在 derived class 的构造函数开始之前不会成为一个 derived class 对象</p>
<p>解决方法</p>
<p>class Transaction<br>{<br>public:<br>    explicit Transaction(const std::string&amp; logInfo);<br>    void logTransaction(const std::string&amp; logInfo) const; // 现在是一个 non-vitrual 函数<br>};</p>
<p>Transaction::Transaction(const std::string&amp; logInfo)<br>{<br>    …<br>    logTransaction(logInfo); // 让 derived class 构造函数传递必要信息给 Transaction 构造函数<br>                             // 然后便可以安全的调用 non-virtual logTransaction<br>}</p>
<p>class BuyTransaction<br>{<br>public:<br>    BuyTransaction(parameters)<br>    : Transaction(createLogString(parameters))  // 将 log 信息传递给 base class 构造函数<br>    { … }<br>    …<br>private:<br>    static std::string createLogString(parameters);<br>}</p>
<p>在构造和析构期间不要调用 virtual 函数</p>
<hr>
<p>10 令 operator= 返回一个 reference to *this</p>
<p>为了能实现连锁赋值，赋值操作符必须返回一个 reference 指向操作符左侧的实参。<br>令赋值操作符返回一个 reference to *this</p>
<p>class Widget<br>{<br>public:<br>    …<br>    Widget&amp; operator+=(const Widget&amp; rhs)<br>    {<br>        …<br>        return *this;<br>    }<br>    Widget&amp; operator=(int rhs)<br>    {<br>        …<br>        return *this;<br>    }<br>} </p>
<hr>
<p>11 在 operator= 中处理 “自我赋值”</p>
<p>自我赋值的情况如下：<br>class Widget { … };<br>Widget w;<br>…<br>w = w;</p>
<p>这种情况看上去非常奇怪，但是编译器并不会阻止，而且存在很多的 “潜在自我赋值” 形式，如下：<br>1.a[i] = a[j]; // i == j<br>2.*px = *py;   // px py 可能指向同一个东西<br>3.class Base { … };<br>  class Derived: public Base { … };<br>  void doSomething (const Base&amp; rb, Derived *pd); // rb 和 pd 有可能是指向同一个对象</p>
<p>一般情况下使用C++自己提供的资源管理对象的时候是“自我赋值安全”的，但是当决定自己写一个<br>资源管理对象的时候，很有可能犯　“在停止使用资源前意外释放”　的错误，该情况如下：<br>class Bitmap { … };<br>class Widget<br>{<br>    …<br>private:<br>    Bitmap* pb;<br>}</p>
<p>Widget&amp; Widget::operator=(const Widget&amp; rhs)<br>{<br>    delete pb;                    // 停止当前的bitmap<br>    pb = new Bitmap(*rhs.pb);    // 使用 rhs’s bitmap 副本<br>    return *this;<br>}</p>
<p>在这种情况下， rhs 和 bp 可能是同一个东西，这时，如果 delete pb 则可能同时 delete 了 rhs<br>导致最后 return *this; 指向了一块已经被删除了的区域，这是非常危险的操作！！</p>
<p>传统的解决方法如下是，在 operator= 中添加 “认同测试”</p>
<p>Widget&amp; Widget::operator=(const Widget&amp; rhs)<br>{<br>    if (this == &amp;rhs) return *this; // 检查这两指针是否指向同一个对象<br>    delete pb;<br>    pb = new Bitmap(*rhs.pb);<br>    return *this;<br>}</p>
<p>虽然这个版本处理了 “赋值安全性” 但是在 “异常安全性” 上却完全没有办法。 如果 new Bitmap<br>发生了异常，那么Widget最终还是会指向一块被删除了的 Bitmap;</p>
<p>幸运的是，如果处理完了“异常安全性”那么Widget会自动获得 “自我赋值安全性”</p>
<p>Widget&amp; Widget::operator=(const Widget&amp; rhs)<br>{<br>    Bitmap* pOrig = pb;                // 先记住原先的 pb<br>    pb = new Bitmap(*rhs.pb);        // 令 pb 指向一个 *pb 的副本<br>    delete pOrig;                    // 删除原来的 pb<br>    return *this;<br>} </p>
<p>这种情况下虽然获得了两个安全性，但是却有了性能上的损失。<br>使用 copy and swap 技术<br>class Widget<br>{<br>    …<br>    void swap(Widget&amp; rhs);<br>    …<br>};<br>Widget&amp; Widget::operator=(const Widget&amp; rhs)<br>{<br>    Widget temp(rhs);   // 为rhs数据制作一份附件<br>    swap(temp);            // 将 *this 数据和上述附件的数据交换<br>    return *this;<br>}</p>
<p>确保当对象自我复制的时候 operator= 有良好行为。</p>
<hr>
<p>12 复制对象时勿忘其每一部分的组成 </p>
<p>class Date { … };<br>class Customer<br>{<br>public:<br>    …<br>private:<br>    std::string name;<br>    Date lastTransaction;<br>};</p>
<p>在这种情况的类的结构下，一旦发生继承将会产生非常危险的结果:</p>
<p>class PriorityCustomer: public Customer<br>{<br>public:<br>    …<br>    PriorityCustomer(const PriorityCustomer&amp; rhs);<br>    PriorityCustomer&amp; operator=(const PriorityCustomer&amp; rhs);<br>    …<br>private:<br>    int priority;<br>};</p>
<dl><dt>PriorityCustomer::PriorityCustomer(const PriorityCustomer&amp; rhs)</dt><dd>priority(rhs.priority)<br>{<br>    logCall(“…”);<br>}<br>PriorityCustomer&amp; PriorityCustomer::PriorityCustomer operator=<br>(const PriorityCustomer&amp; rhs)<br>{<br>    logCall(“…”);<br>    priority = rhs.priority;<br>    return *this;<br>}</dd></dl><p>注意，这里的copy构造函数并没有指定实参传递给 base class 的构造函数。<br>因此 PriorityCustomer 对象的 Customer 成分会被 Customer 的 default 构造函数<br>进行缺省的初始化。</p>
<p>所以在任何时候，只要承担了为 derived class 撰写 copying 函数的重大责任，我们必须<br>小心的复制其 base class 成分！</p>
<dl><dt>PriorityCustomer::PriorityCustomer(const PriorityCustomer&amp; rhs)</dt><dd>Customer(rhs),             // 调用 base class 的 copy 构造函数<br>  priority(rhs.priority)<br>{<br>    logCall(“…”);<br>}</dd></dl><p>PriorityCustomer&amp; PriorityCustomer::operator=(const PriorityCustomer&amp; rhs)<br>{<br>    logCall(“…”);<br>    Customer::operator=(rhs);        // 对 base class 进行赋值<br>    priority = rhs.priority;<br>    return *this;<br>}</p>
<p>tips: 不要尝试用某个 copying 函数实现另一个 copying 函数。如果确实想要精简代码，那么将<br>其共同的机能放入第三个函数中，并由两个 copying 函数共同调用。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>初始化 Direct3D 12</title>
    <url>/myblog/2021/04/19/C/%E5%88%9D%E5%A7%8B%E5%8C%96%20Direct3D/</url>
    <content><![CDATA[<h2 id="初始化-Direct3D"><a href="#初始化-Direct3D" class="headerlink" title="初始化 Direct3D"></a>初始化 Direct3D</h2><h3 id="对-DX3D-的初始化分为以下几步："><a href="#对-DX3D-的初始化分为以下几步：" class="headerlink" title="对 DX3D 的初始化分为以下几步："></a>对 DX3D 的初始化分为以下几步：</h3><ol>
<li>用 D3D12CreateDevice 函数创建 ID3D12Device 接口实例</li>
<li>创建一个 ID3D12Fence 对象，并查询描述符的大小</li>
<li>检查用户对 4X MSAA 质量级别的支持情况</li>
<li>依次创建命令队列、命令列表分配器和主命令列表</li>
<li>描述并创建交换链</li>
<li>创建应用程序所需的描述符堆</li>
<li>调整后台缓冲区的大小，并为它创建渲染目标视图</li>
<li>创建深度/模板缓冲区及与之关联的深度/模板视图</li>
<li>设置窗口(viewport)和剪裁矩形(scissor rectangle)</li>
</ol>
<h3 id="1-创建设备"><a href="#1-创建设备" class="headerlink" title="1. 创建设备"></a>1. 创建设备</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">HRESULT WINAPI <span class="title">D3D12CreateDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	IUnknown* pAdapter,</span></span></span><br><span class="line"><span class="function"><span class="params">    D3D_FEATURE_LEVEL MinimumFeatureLevel,</span></span></span><br><span class="line"><span class="function"><span class="params">    REFIID riid,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>** getDevice)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>pAdapter</code> :指定创建设备时使用的显示适配器，nullper 代表默认使用主显示适配器</p>
<p><code>MinimumFeatureLevel</code> :程序所需要硬件支持的最低功能级别 (这里我们使用 D3D_FEATURE_LEVEL_11_0)</p>
<p><code>riid</code> :创建的 ID3D12Device 接口的 COM ID</p>
<p><code>ppDevice</code> :返回所创建的 Direct3D 12 设备</p>
<p><em>函数调用示例</em>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(DEBUG)	||	defined(_DEBUG)</span></span><br><span class="line"><span class="comment">// 启用 D3D12 的调试层</span></span><br><span class="line">&#123;</span><br><span class="line">	ComPtr&lt;ID3D12Debug&gt; debugController;</span><br><span class="line">    ThrowIfFailed(D3D12GetDebugInterface(IID_PPV_ARGS(&amp;debugcontroller)));</span><br><span class="line">    debugController-&gt;EnableDebugLayer();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">ThorwIfFailed(CreateDXGIFactory1(IID_PPV_ARGS(&amp;mdxgiFactory)));</span><br><span class="line"><span class="comment">// 尝试创建硬件设备</span></span><br><span class="line">HRESULT hardwareResult = D3D12CreateDevice(</span><br><span class="line">	<span class="literal">nullptr</span>, <span class="comment">// 使用默认适配器</span></span><br><span class="line">    D3D_FEATURE_LEVEL_11_0,</span><br><span class="line">    IID_PPV_ARGS(&amp;md3dDevice));</span><br><span class="line"><span class="comment">// 回退到 WARP 设备</span></span><br><span class="line"><span class="keyword">if</span> (Failed(hardwareResult))</span><br><span class="line">&#123;</span><br><span class="line">	ComPtr&lt;IDXGIAdapter&gt; pWarpAdapter; <span class="comment">// IID_PPV_ARGS() 辅助函数 大多数时候是将 ppType 类型强制转换为 void** 类型的</span></span><br><span class="line">    								<span class="comment">// 待创建接口 COM ID</span></span><br><span class="line">    ThrowIfFailed(mdxgiFactory-&gt;EnumWarpAdapter(IID_PPV_ARGS(&amp;pWrapAdapter)));</span><br><span class="line">    </span><br><span class="line">    ThrowIfFailed(D3D12CreateDevice(</span><br><span class="line">    	pWarpAdapter.Get(),</span><br><span class="line">        D3D_FEATURE_LEVEL_11_0,</span><br><span class="line">        IID_PPV_ARGS(&amp;md3dDevice()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用 D3D12CreateDevice 失败后，会回退到 WARP <code>Windows Advanced Rasterization Platform</code> (Windows 高级光栅化平台)。</p>
<p><em>创建 WARP 适配器</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先创建一个 IDXGIFactory4 对象，通过其来枚举 WARP 适配器</span></span><br><span class="line">ComPtr&lt;IDXGIFactory4&gt; mdxgiFactory;</span><br><span class="line">CreateDXGIFactory1(IID_PPV_ARGS(&amp;mdxgiFactory));</span><br><span class="line">mdxgiFactory-&gt;EnumWrapAdapter(IID_PPV_ARGS(&amp;pWarpAdapter));</span><br><span class="line"><span class="comment">// 作为 DXGI 的一部分 mdxgiFactory 也可以用于创建交换链</span></span><br></pre></td></tr></table></figure>



<h3 id="2-创建围栏并获取描述符的大小"><a href="#2-创建围栏并获取描述符的大小" class="headerlink" title="2. 创建围栏并获取描述符的大小"></a>2. 创建围栏并获取描述符的大小</h3><p>创建好设备之后，就可以为 CPU/GPU 的同步来创建”围栏”(Fence)了。</p>
<p><em>创建围栏对象如下</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">ID3D12Device::CreateFence</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	UINT64 InitialValue,</span></span></span><br><span class="line"><span class="function"><span class="params">    D3D12_FENCE_FLAGS Flags,</span></span></span><br><span class="line"><span class="function"><span class="params">    REFIID riid,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> **ppFence)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ThrowIfFailed(md3dDevice-&gt;createFence(</span><br><span class="line">	<span class="number">0</span>, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&amp;mFence)));</span><br><span class="line">mRtvDescriptorSize = md3dDevice-&gt;GetDescriptorHandleIncrementSize(</span><br><span class="line">	D3D12_DESCRIPTOR_HEAP_TYPE_RTV);</span><br><span class="line">mDsvDescriptorSize = md3dDevice-&gt;GetDescriptorHandleIncrementSize(</span><br><span class="line">	D3D12_DESCRIPTOR_HEAP_TYPE_DSV);</span><br><span class="line">mCbvDescriptorSize = md3dDevice-&gt;GetDescriptorHandleIncrementSize(</span><br><span class="line">	D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);</span><br></pre></td></tr></table></figure>

<p>描述符在不同的 GPU 平台上大小各异，我们在查询相关信息后，将其缓存起来，需要时直接引用。</p>
<h3 id="3-检测对-4X-MSAA-质量级别的支持"><a href="#3-检测对-4X-MSAA-质量级别的支持" class="headerlink" title="3. 检测对 4X MSAA 质量级别的支持"></a>3. 检测对 4X MSAA 质量级别的支持</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS msQualityLevels;</span><br><span class="line">msQualityLevels.Format = mBackBufferFormat;</span><br><span class="line">msQualityLevels.SampleCount = <span class="number">4</span>;</span><br><span class="line">msQualityLevels.Flags = D3D12_MULITISAMPLE_QUALITY_LEVELS_FLAG_NONE;</span><br><span class="line">msQualityLevels.NumQualityLevels = <span class="number">0</span>;</span><br><span class="line">ThrowIfFail(md3dDevice-&gt;CheckFeatureSupport(</span><br><span class="line">	D3D12_FEATURE_MULTISAMPLE_QUALITY_LEVELS,</span><br><span class="line">	&amp;msQualityLevels,</span><br><span class="line">	<span class="keyword">sizeof</span>(msQualityLevels)));</span><br><span class="line">m4xMsaaQuality = msQualityLevels.NumQualityLevels;</span><br><span class="line">assert(m4xMsaaQuality &gt; <span class="number">0</span> &amp;&amp; <span class="string">&quot;Unexcepted MSAA quality level.&quot;</span>); <span class="comment">// 返回值必须大于 0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="4-创建命令队列和命令列表"><a href="#4-创建命令队列和命令列表" class="headerlink" title="4. 创建命令队列和命令列表"></a>4. 创建命令队列和命令列表</h3><p>下面是常用的接口</p>
<p><code>ID3D12CommandQueue</code> : 命令队列</p>
<p><code>ID3D12CommandAllocator</code> : 命令分配器</p>
<p><code>ID3D12GraphicsCommandList</code> : 命令列表</p>
<p><em>完整的创建流程</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ComPtr&lt;ID3D12CommandQueue&gt; mCommandQueue;</span><br><span class="line">ComPtr&lt;ID3D12CommandAllocator&gt; mDirectCmdListAlloc;</span><br><span class="line">ComPtr&lt;ID3D12GraphicsCommandList&gt; mCommandList;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">D3DApp::CreateCommandObjects</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	D3D12_COMMAND_QUEUE_DESC queueDesc = &#123;&#125;;</span><br><span class="line">    queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;</span><br><span class="line">    queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;</span><br><span class="line">    ThrowIfFailed(md3dDevice-&gt;CreateCommandQueue(</span><br><span class="line">    	&amp;queueDesc, IID_PPV_ARGS(&amp;mCommandQueue)));</span><br><span class="line">    ThrowIfFailed(md3dDevice-&gt;CreateCommandAllocator(</span><br><span class="line">    	D3D12_COMMAND_LIST_TYPE_DIRECT,</span><br><span class="line">    	IID_PPV_ARGS(mDirectCmdListAlloc.GetAddressOf())));</span><br><span class="line">    ThrowIfFailed(md3dDevice-&gt;CreateCommandList(</span><br><span class="line">    	<span class="number">0</span>,</span><br><span class="line">    	D3D12_COMMAND_LIST_DIRECT,</span><br><span class="line">    	mDirectCmdListAlloc.Get(),   <span class="comment">// 关联命令分配器</span></span><br><span class="line">    	<span class="literal">nullptr</span>,				    <span class="comment">// 初始化流水线状态对象（此时不会发起任何绘制命令） pipeline state object</span></span><br><span class="line">    	IID_PPV_ARGS(mCommandList.GetAddressOf())));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先将命令列表置于关闭状态。</span></span><br><span class="line">    mCommandList-&gt;close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-描述并创建交换链"><a href="#5-描述并创建交换链" class="headerlink" title="5. 描述并创建交换链"></a>5. 描述并创建交换链</h3><p><em>先填写一份</em> DXGI_SWAP_CHAIN_DESC <em>结构体实例用来描述欲创建交换链的特性</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DXGI_SWAP_CHAIN_DESC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DXGI_MODE_DESC 		 BufferDesc;</span><br><span class="line">    DXGI_SAMPLE_DESC 	 SampleDesc;</span><br><span class="line">    DXGI_USAGE 		     BufferUsage;</span><br><span class="line">    UINT    		     BufferCount;</span><br><span class="line">    HWND 				OutPutWindow;</span><br><span class="line">    BOOL				Windowed;</span><br><span class="line">    DXGI_SWAP_EFFECT	 SwapEffect;</span><br><span class="line">    UINT 				Flags;</span><br><span class="line">    DXGI_SWAP_CHAIN_DESC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的 <code> DXGI_MODE_DESC</code> 是另一种结构体，定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DXGI_MODE_DESC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	UINT				Width;</span><br><span class="line">    UINT				Height;</span><br><span class="line">    DXGI_PARTIONAL		 RefreshRate;</span><br><span class="line">    DXGI_FORMAT			 Format;</span><br><span class="line">    DXGI_MODE_SCANLINE_ORDER	Scaling;</span><br><span class="line">&#125; DXGI_MODE_DESC;</span><br></pre></td></tr></table></figure>

<p>对于上面的一些数据成员，其含义和设定如下:</p>
<p><code> BufferDesc</code> : 带创建的后台缓冲区属性</p>
<p><code> SampleDesc</code> : 多重采样的质量级别和对每个像素的采样次数</p>
<p><code> BufferUsage</code> : 此时要将数据渲染至后台缓冲区，所以这里指定为 DXGI_USAGE_RENDER_TARGET_OUTPUT</p>
<p><code> OutPutWindow</code> : 渲染窗口的句柄</p>
<p><code> Windowed</code> : true -&gt; 窗口模式运行   false -&gt; 全屏模式运行</p>
<p><code> SwapEffect</code>:指定为 DXGI_SWAP_EFFECT_FLIP_DISCARD</p>
<p><code> Falgs</code> : 可选标志 若指定为 DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH  当程序切换为全屏模式时，将选择最适于当前应用程序窗口</p>
<p>大小的尺寸显示模式。 如果没有指定的话，切换为全屏模式的时候，将采用当前桌面的显示模式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 适用该方法创建交换链</span></span><br><span class="line"><span class="function">HRESULT <span class="title">IDXGIFactory::CreateSwapChain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">IUnknown *pDevice,					<span class="comment">// 指向 ID3D12CommamdQueue 接口的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">DXGI_SWAP_CHAIN_DESC *pDesc,		 <span class="comment">// 指向描述交换链的结构体指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">IDXGISwapChain **PPSwapChain)</span></span>;		 <span class="comment">// 返回所创建的交换链接口</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DXGI_FORMAT mBackBufferFormat = DXGI_FORMAT_R8G8B8A8_UNORM;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">D3Dapp::CreateSwapChain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 释放之前的交换链，随后再重新创建</span></span><br><span class="line">    mSwapChain.Reset();</span><br><span class="line">    </span><br><span class="line">    DXGI_SWAP_CHAIN_DESC 						sd;</span><br><span class="line">    sd.BufferDesc.Width 		 	=  			mClinetWidth;</span><br><span class="line">    sd.BufferDesc.Height			= 		    mClientHeight;</span><br><span class="line">    sd.BufferDesc.RefreshRate.Numerator 	=     <span class="number">60</span>;</span><br><span class="line">    sd.BufferDesc.RefreshRate.Denomiator	= 	  <span class="number">1</span>;</span><br><span class="line">    sd.BufferDesc.Format			=			mBackBufferFormat;</span><br><span class="line">    sd.BufferDesc.ScanLineOrder      =     		  DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;</span><br><span class="line">    sd.BufferDesc.Scaling			= 			DXGI_MODE_SCALING_UNSPECIFIED;</span><br><span class="line">    sd.SampleDesc			        =            m4xMsaaState ? <span class="number">4</span> : <span class="number">1</span>;</span><br><span class="line">    sd.SampleQuality			    =			m4xMsaaState ? (m4xMsaaQuality - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">    sd.BufferUsage 				    = 			DXGI_USAGE_RENDER_TARGET_OUTPUT;</span><br><span class="line">    sd.BufferCount 				    =   		SwapChainBufferCount;</span><br><span class="line">    sd.OutPutWindow				    =			mhMainWnd;</span><br><span class="line">    sd.Windowed                      =			 <span class="literal">true</span>;</span><br><span class="line">    sd.SwapEffect 				    =		    DXGI_SWAP_EFFECT_FLIP_DISCARD;</span><br><span class="line">    sd.Flags					   =            DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;</span><br><span class="line">   	<span class="comment">// 交换链需要命令队列对其进行刷新</span></span><br><span class="line">    ThrowIfFailed(mdxgiFactory-&gt;CreateSwapChain(</span><br><span class="line">    	mCommandQueue.Get(),</span><br><span class="line">    	&amp;sd,</span><br><span class="line">    	mSwapChain.GetAddressOf()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-创建描述符堆"><a href="#6-创建描述符堆" class="headerlink" title="6. 创建描述符堆"></a>6. 创建描述符堆</h3><p>我们需要通过创建描述符堆来存储程序中用到的 描述符/视图。</p>
<p><code> ID3D12DescriptorHeap</code> : 堆描述符接口</p>
<p><code> ID3D12DeviceCreateDescriptorHeap</code> : 创建堆描述符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Comptr&lt;ID3D12DescriptorHeap&gt; mRtvHeap; <span class="comment">// render target view</span></span><br><span class="line">Comptr&lt;ID3D12DescrtptorHeap&gt; mDsvHeap; <span class="comment">// depth / stencil view</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">D3DApp::CreateRtvAndDsvDescriptorHeaps</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	D3D12_DESCRIPTOR_HEAP_DESC rtvHeapDesc;</span><br><span class="line">    rtvHeapDesc.NumDescriptors = SwapChainBufferCount;</span><br><span class="line">    rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;</span><br><span class="line">    rtvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;</span><br><span class="line">	rtvHeapDesc.NodeMask = <span class="number">0</span>;</span><br><span class="line">    ThrowIfFailed(md3dDevice-&gt;CreateDescriptorHeap(</span><br><span class="line">        &amp;rtvHeapDesc, IID_PPV_ARGS(mRtvHeap.GetAddressOf())));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    D3D12_DESCRIPTOR_HEAP_DESC dsvHeapDesc;</span><br><span class="line">    dsvHeapDesc.NumDescriptors = <span class="number">1</span>;</span><br><span class="line">    dsvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;</span><br><span class="line">    dsvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;</span><br><span class="line">	dsvHeapDesc.NodeMask = <span class="number">0</span>;</span><br><span class="line">    ThrowIfFailed(md3dDevice-&gt;CreateDescriptorHeap(</span><br><span class="line">        &amp;dsvHeapDesc, IID_PPV_ARGS(mDsvHeap.GetAddressOf())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本书的应用框架有以下定义:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> SwapChainBufferCount = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> mCurrBackBuffer = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><code> mCurrBackBuffer</code> : 用来记录当前后台缓冲区的索引。 (我们必须知道当前正在用于渲染数据的后台缓冲区)</p>
<p>在程序中我们是通过句柄来引用描述符的，借助下列函数即可获得。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">D3D12_CPU_DESCRIPTOR_HANDLE <span class="title">D3DApp::CurrentBackBufferView</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> CD3DX12_CPU_DESCRIPTOR_HANDLE(</span><br><span class="line">		mRtvHeap-&gt;GetCPUDescriptorHandleForHeapStart(),   <span class="comment">// 堆中的首个句柄</span></span><br><span class="line">		mCurrBackBuffer,							   <span class="comment">// 偏移至后台缓冲区描述符句柄的索引</span></span><br><span class="line">		mRtvDescriptorSize);						   <span class="comment">// 描述符所占字节的大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">D3D12_CPU_DESCRIPTOR_HANDLE <span class="title">D3DApp::DepthStencilView</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mDsvHeap-&gt;GetCPUDescriptorHandleForHeapStart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说通过描述符的大小，通过偏移量找到当前后台缓冲区的 RTV 描述符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 目标描述符句柄 */</span> = GetCPUDescriptorHandleForHeapStart() + mCurrBackBuffer * mRTVDescriptorSize;</span><br></pre></td></tr></table></figure>



<h3 id="7-创建渲染目标视图"><a href="#7-创建渲染目标视图" class="headerlink" title="7. 创建渲染目标视图"></a>7. 创建渲染目标视图</h3><p>由于资源不能于渲染流水线中的阶段直接绑定，必须为其创建资源视图才能完成绑定。</p>
<ol>
<li><p>获取存于交换链中的缓冲区资源</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">IDXGISwapChain::GetBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	UINT Buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">	REFIID riid,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span> **ppSurface)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code> Buffer</code> : 缓冲区索引</p>
<p><code> riid</code> : 希望获得的 ID3D12Resource 接口的 COM ID  </p>
<p><code> ID3D12Resource</code> : 该接口将物理内存于堆资源抽象组织为可处理的数组于多维数组，使得 CPU/GPU 可以对这些资源进行读写</p>
<p><code> ppSurface</code> : 返回一个指向 ID3D12Resource 接口的指针，该指针便是希望获得的后台缓冲区。</p>
<p>GetBuffer 会增加 COM 的引用计数，所以使用后要将其释放。 ComPtr 可以自动的做到这点。</p>
</li>
<li><p>使用 ID3D12Device::CreateRenderTargetView 来为获取的后台缓冲区创建渲染目标视图</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ID3D12Device::CreateRenderTargetView</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	ID3D12Resource *pResource,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> D3D12_RENDER_TARGET_VIEW_DESC *pDesc,</span></span></span><br><span class="line">	D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor)；</span><br></pre></td></tr></table></figure>

<p><code> pResource</code> : 指定用作渲染目标的资源（在这里是后台缓冲区）</p>
<p><code> pDesc</code> : 指向 D3D12_RENDER_TARGET_VIEW_DESC 数据结构的实例指针</p>
<p><code> DestDescriptor</code> : 引用所创建渲染目标视图的描述符</p>
</li>
<li><p>调用上面2种方法为交换链的每一个缓冲区都创建了一个 RTV</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ComPtr&lt;ID3D12Resource&gt; <span class="title">mSwapChainBuffer</span><span class="params">(SwapChainBufferCount)</span></span>;</span><br><span class="line"><span class="function">CD3DX12_CPU_DESCRIPTOR_HANDLE <span class="title">rtvHeapHandle</span><span class="params">(mRtvHeap-&gt;GetCPUDescriptorHandleForHeapStart())</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (UINT i = <span class="number">0</span>; i &lt; SwapChainBufferCount; i++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 获得交换链的第 i 个缓冲区</span></span><br><span class="line">		ThrowIfFailed(mSwapChain-&gt;GetBuffer(i, IID_PPV_ARGS(&amp;mSwapChainBuffer[i])));</span><br><span class="line">        <span class="comment">// 为该缓冲区创建一个 RTV</span></span><br><span class="line">		md3dDevice-&gt;CreateRenderTargetView(mSwapChainBuffer[i].Get(), <span class="literal">nullptr</span>, rtvHeapHandle);</span><br><span class="line">        <span class="comment">// 偏移到描述符堆的下一个缓冲区</span></span><br><span class="line">		rtvHeapHandle.Offset(<span class="number">1</span>, mRtvDescriptorSize);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h3 id="8-创建深度-模板缓冲区及其视图"><a href="#8-创建深度-模板缓冲区及其视图" class="headerlink" title="8. 创建深度/模板缓冲区及其视图"></a>8. 创建深度/模板缓冲区及其视图</h3><p>深度缓冲是一种2D纹理，存储着可视对象的深度信息，由于纹理是一种 GPU 资源，我们通过 D3D12_RESOURCE_DESC 结构体来描述，用 </p>
<p>ID3D12Device::CreateCommittedResource 方法来创建。</p>
<p><em>D3D12_RESOURCE_DESC</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">D3D12_RESOURCE_DESC</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    D3D12_RESOURCE_DIMENSION Dimension;</span><br><span class="line">    UINT64 Alignment;</span><br><span class="line">    UINT64 Width;</span><br><span class="line">    UINT Height;</span><br><span class="line">    UINT16 DepthOrArraySize;</span><br><span class="line">    UINT16 MipLevels;</span><br><span class="line">    DXGI_FORMAT Format;</span><br><span class="line">    DXGI_SAMPLE_DESC SampleDesc;</span><br><span class="line">    D3D12_TEXTURE_LAYOUT Layout;</span><br><span class="line">    D3D12_RESOURCE_FLAGS Flags;</span><br><span class="line">    &#125; 	D3D12_RESOURCE_DESC;</span><br></pre></td></tr></table></figure>

<p><code> Dimension</code> : 资源的维度，选择下列之一</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> D3D12_RESOURCE_DIMENSION</span><br><span class="line">    &#123;</span><br><span class="line">        D3D12_RESOURCE_DIMENSION_UNKNOWN	= <span class="number">0</span>,</span><br><span class="line">        D3D12_RESOURCE_DIMENSION_BUFFER	= <span class="number">1</span>,</span><br><span class="line">        D3D12_RESOURCE_DIMENSION_TEXTURE1D	= <span class="number">2</span>,</span><br><span class="line">        D3D12_RESOURCE_DIMENSION_TEXTURE2D	= <span class="number">3</span>,</span><br><span class="line">        D3D12_RESOURCE_DIMENSION_TEXTURE3D	= <span class="number">4</span></span><br><span class="line">    &#125; 	D3D12_RESOURCE_DIMENSION;</span><br></pre></td></tr></table></figure>

<p><code> Width</code> : 纹理宽度 （以纹素为单位，特别对于缓冲区资源来说，这是缓冲区占据的字节数）</p>
<p><code> Height</code> : 纹理高度 (纹素为单位)</p>
<p><code> DepthOrArraySize</code> : 纹理深度 (纹素为单位)，对于 1D/2D 纹理来说是纹理数组的大小。D3D 中并不存在 3D 纹理数组的概念</p>
<p><code> MipLevels</code> : mipmap 层级的数量</p>
<p><code> Format</code> : DXGI_FORMAT 枚举类型的一种，用来指定纹素的格式</p>
<p><code> SampleDesc</code> : 多重采样的质量级别以及对每个像素的采样次数 </p>
<p><code> Layout</code> : 用于指定纹理的布局，这里暂时不考虑，设定为 D3D12_TEXTURE_LAYOUT_UNKNOWN</p>
<p><code> Flags</code> : 与资源有关的杂项标志，对于深度/模板缓冲资源来说设定为 D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</p>
<p>GPU 资源都存于堆(Heap)中，本质是具有特定属性的 GPU 显存块。 ID3D12Device::CreateCommittedResource 根据我们提供的属性创建一个资源与一个堆，并把该资源提交到这个堆中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">HRESULT STDMETHODCALLTYPE <span class="title">CreateCommittedResource</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> D3D12_HEAP_PROPERTIES *pHeapProperties,</span></span></span><br><span class="line"><span class="function"><span class="params">            D3D12_HEAP_FLAGS HeapFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> D3D12_RESOURCE_DESC *pDesc,</span></span></span><br><span class="line"><span class="function"><span class="params">            D3D12_RESOURCE_STATES InitialResourceState,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> D3D12_CLEAR_VALUE *pOptimizedClearValue,</span></span></span><br><span class="line"><span class="function"><span class="params">            REFIID riidResource,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">void</span> **ppvResource)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">D3D12_HEAP_PROPERTIES</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    D3D12_HEAP_TYPE Type;</span><br><span class="line">    D3D12_CPU_PAGE_PROPERTY CPUPageProperty;</span><br><span class="line">    D3D12_MEMORY_POOL MemoryPoolPreference;</span><br><span class="line">    UINT CreationNodeMask;</span><br><span class="line">    UINT VisibleNodeMask;</span><br><span class="line">    &#125; 	D3D12_HEAP_PROPERTIES;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code> pHeapProperties</code> : 资源欲提交到的堆所具有的属性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> </span><br><span class="line"><span class="keyword">enum</span> D3D12_HEAP_TYPE</span><br><span class="line">    &#123;</span><br><span class="line">        D3D12_HEAP_TYPE_DEFAULT	= <span class="number">1</span>,			<span class="comment">// 默认，向这个堆提交的资源只有 GPU 不能访问</span></span><br><span class="line">        D3D12_HEAP_TYPE_UPLOAD	= <span class="number">2</span>,			<span class="comment">// 上传堆，需要经过 CPU 上传到 GPU 的资源</span></span><br><span class="line">        D3D12_HEAP_TYPE_READBACK	= <span class="number">3</span>,		<span class="comment">// 回读堆，需要 CPU 读取的资源</span></span><br><span class="line">        D3D12_HEAP_TYPE_CUSTOM	= <span class="number">4</span>			 	<span class="comment">// 用于高级场景</span></span><br><span class="line">    &#125; 	D3D12_HEAP_TYPE;</span><br></pre></td></tr></table></figure>

<p><code> HeapFlags</code> : 与堆有关的额外选项标志。通常设置为 D3D12_HEAP_FLAG_NONE</p>
<p><code> pDesc</code> : 指向一个 D3D12_RESOURCE_DESC 实例的指针，用其描述一个带创建的资源</p>
<p><code> InitialResourceState</code> : 用该参数来设置每种资源的初始状态</p>
<p><code> pOptimizedClearValue</code> : 指向一个 D3D12_CLEAR_VALUE 对象的指针，描述一个用于清除资源的优化值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">D3D12_CLEAR_VALUE</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    DXGI_FORMAT Format;</span><br><span class="line">    <span class="keyword">union</span> </span><br><span class="line">        &#123;</span><br><span class="line">        FLOAT Color[ <span class="number">4</span> ];</span><br><span class="line">        D3D12_DEPTH_STENCIL_VALUE DepthStencil;</span><br><span class="line">        &#125; 	;</span><br><span class="line">    &#125; 	D3D12_CLEAR_VALUE;</span><br></pre></td></tr></table></figure>

<p><code> riidResource</code> : 我们希望获得的 ID3D12Resource 接口的 COM ID </p>
<p><code> ppvResource</code> : 返回一个指向 ID3Dd12Resource 的指针，也就是新建的资源的指针</p>
<p><strong>为了使性能达到最价，通常将资源放于默认堆中。有其他需求时再使用其他类型的堆</strong></p>
<p>在使用深度/模板缓冲之前一定要创建相关的深度/模板视图，并将其绑定到渲染流水线上。过程类似于创建渲染目标视图</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// Create the depth/stencil buffer and view.</span></span><br><span class="line">   D3D12_RESOURCE_DESC depthStencilDesc;</span><br><span class="line">   depthStencilDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;</span><br><span class="line">   depthStencilDesc.Alignment = <span class="number">0</span>;</span><br><span class="line">   depthStencilDesc.Width = mClientWidth;</span><br><span class="line">   depthStencilDesc.Height = mClientHeight;</span><br><span class="line">   depthStencilDesc.DepthOrArraySize = <span class="number">1</span>;</span><br><span class="line">   depthStencilDesc.MipLevels = <span class="number">1</span>;</span><br><span class="line">   depthStencilDesc.Format = mDepthStencilFormat;</span><br><span class="line">   depthStencilDesc.SampleDesc.Count = m4xMsaaState ? <span class="number">4</span> : <span class="number">1</span>;</span><br><span class="line">   depthStencilDesc.SampleDesc.Quality = m4xMsaaState ? (m4xMsaaQuality - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">   depthStencilDesc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;</span><br><span class="line">   depthStencilDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;</span><br><span class="line"></span><br><span class="line">   D3D12_CLEAR_VALUE optClear;</span><br><span class="line">   optClear.Format = mDepthStencilFormat;</span><br><span class="line">   optClear.DepthStencil.Depth = <span class="number">1.0f</span>;</span><br><span class="line">   optClear.DepthStencil.Stencil = <span class="number">0</span>;</span><br><span class="line">   ThrowIfFailed(md3dDevice-&gt;CreateCommittedResource(</span><br><span class="line">       &amp;CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT),</span><br><span class="line">	D3D12_HEAP_FLAG_NONE,</span><br><span class="line">       &amp;depthStencilDesc,</span><br><span class="line">	D3D12_RESOURCE_STATE_COMMON,</span><br><span class="line">       &amp;optClear,</span><br><span class="line">       IID_PPV_ARGS(mDepthStencilBuffer.GetAddressOf())));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Create descriptor to mip level 0 of entire resource using the format of the resource.</span></span><br><span class="line">   md3dDevice-&gt;CreateDepthStencilView(mDepthStencilBuffer.Get(), <span class="literal">nullptr</span>, DepthStencilView());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Transition the resource from its initial state to be used as a depth buffer.</span></span><br><span class="line">mCommandList-&gt;ResourceBarrier(<span class="number">1</span>, &amp;CD3DX12_RESOURCE_BARRIER::Transition(mDepthStencilBuffer.Get(),</span><br><span class="line">	D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_STATE_DEPTH_WRITE));</span><br></pre></td></tr></table></figure>

<p>其中用了 CD3DX12_HEAP_PROPERTIES 辅助函数来构建创建堆的属性结构体，其实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">CD3DX12_HEAP_PROPERTIES</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">    D3D12_HEAP_TYPE type, </span></span></span><br><span class="line"><span class="function"><span class="params">    UINT creationNodeMask = <span class="number">1</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    UINT nodeMask = <span class="number">1</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Type = type;</span><br><span class="line">    CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;</span><br><span class="line">    MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;</span><br><span class="line">    CreationNodeMask = creationNodeMask;</span><br><span class="line">    VisibleNodeMask = nodeMask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-绘制窗口"><a href="#9-绘制窗口" class="headerlink" title="9. 绘制窗口"></a>9. 绘制窗口</h3><p>我们通常将3D场景绘制到与整个屏幕，或者和窗口工作区大小相同的后台缓冲区中。但是有时候只是需要将其绘制到后台缓冲区中某个矩形区域的子区域中</p>
<p>我们将这种矩形子区域叫做视口( viewport )</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">D3D12_VIEWPORT</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    FLOAT TopLeftX;</span><br><span class="line">    FLOAT TopLeftY;</span><br><span class="line">    FLOAT Width;</span><br><span class="line">    FLOAT Height;</span><br><span class="line">    FLOAT MinDepth;</span><br><span class="line">    FLOAT MaxDepth;</span><br><span class="line">    &#125; 	D3D12_VIEWPORT;</span><br></pre></td></tr></table></figure>

<p><code> MinDepth</code> , <code> MaxDepth</code> 这两个成员负责将深度值从区间 [0, 1] 转换到区间 [MinDepth, MaxDepth]。</p>
<p>填好D3D12_VIEWPROT 结构体，便可以使用 ID3D12GraphicsCommandList::RSSetViewports 来设置视口了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">D3D12_VIEWPORT vp;</span><br><span class="line">vp.TopLeftX = <span class="number">0.0f</span>;</span><br><span class="line">vp.TopRightY = <span class="number">0.0f</span>;</span><br><span class="line">vp.Width = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(mClientWidth);</span><br><span class="line">vp.Height = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(mClientHeight);</span><br><span class="line">vp.MinDepth = <span class="number">0.0f</span>;</span><br><span class="line">vp.MaxDepth = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">mCommandList-&gt;RSSetViewports(<span class="number">1</span>, &amp;vp);   <span class="comment">// 第一个参数是需要绑定的视口数量，第二个则是指向视口数组的指针。</span></span><br></pre></td></tr></table></figure>

<p><strong>命令列表一旦重置，视口也要重置</strong></p>
<h3 id="10-设置剪裁矩阵"><a href="#10-设置剪裁矩阵" class="headerlink" title="10. 设置剪裁矩阵"></a>10. 设置剪裁矩阵</h3><p>剪裁矩阵的类型为 RECT 的 D3D12_RECT 结构体定义而成</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagRECT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LONG    left;</span><br><span class="line">    LONG    top;</span><br><span class="line">    LONG    right;</span><br><span class="line">    LONG    bottom;</span><br><span class="line">&#125; RECT, *PRECT, NEAR *NPRECT, FAR *LPRECT;</span><br></pre></td></tr></table></figure>

<p>使用下面的方法来设置剪裁矩阵</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mScissorRect = &#123; <span class="number">0</span>, <span class="number">0</span>, mClientWidth/<span class="number">2</span>, mClientHeight/<span class="number">2</span> &#125;;</span><br><span class="line">mCommandList-&gt;RSSetScissorRects(<span class="number">1</span>, &amp;mScissorRect); <span class="comment">// 需要绑定的剪裁矩阵数量，指向剪裁矩阵的指针</span></span><br></pre></td></tr></table></figure>

<p><strong>剪裁矩阵需要随着命令列表的重置而重置</strong></p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>Direct3D</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>利用汇编深入学习C++</title>
    <url>/myblog/2020/09/26/C/%E5%88%A9%E7%94%A8%E6%B1%87%E7%BC%96%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0C++/</url>
    <content><![CDATA[<h1 id="一、基础内容"><a href="#一、基础内容" class="headerlink" title="一、基础内容"></a>一、基础内容</h1><h3 id="1、杂项"><a href="#1、杂项" class="headerlink" title="1、杂项"></a>1、杂项</h3><hr>
<h5 id="（1）汇编语言，机器语言，高级语言"><a href="#（1）汇编语言，机器语言，高级语言" class="headerlink" title="（1）汇编语言，机器语言，高级语言"></a>（1）汇编语言，机器语言，高级语言</h5><p><code>汇编语言</code>与<code>机器语言</code>一一对应，每一条机器指令都有与之相对的汇编指令</p>
<p><code>汇编语言</code>可以通过编译得到<code>机器语言</code>，<code>机器语言</code>可以通过反汇编得到<code>汇编语言</code></p>
<p><code>高级语言</code>可以通过编译得到<code>汇编语言\机器语言</code>，但是<code>汇编语言\机器语言</code>几乎不可能还原成<code>高级语言</code></p>
<p>​&emsp;&emsp;&emsp;&emsp;&emsp;编译        </p>
<p>​&emsp;汇编语言 ——&gt; 机器语言</p>
<p>​            mov ax, bx&lt;—— 0010101011</p>
<p>​&emsp;&emsp;&emsp;&emsp;反编译</p>
<p>eg：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line">Date d = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">C7 <span class="number">45</span> F0 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov			dword ptr [ebp<span class="number">-10</span>h],<span class="number">1</span></span><br><span class="line">C7 <span class="number">45</span> F4 <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov			dword ptr [ebp<span class="number">-0</span>Ch],<span class="number">2</span></span><br><span class="line">C7 <span class="number">45</span> F8 <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov			dword ptr [ebp<span class="number">-8</span>],<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">C7 <span class="number">45</span> F0 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov			dword ptr [ebp<span class="number">-10</span>h],<span class="number">1</span></span><br><span class="line">C7 <span class="number">45</span> F4 <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov			dword ptr [ebp<span class="number">-0</span>Ch],<span class="number">2</span></span><br><span class="line">C7 <span class="number">45</span> F8 <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov			dword ptr [ebp<span class="number">-8</span>],<span class="number">3</span></span><br><span class="line"><span class="comment">/*注意到两者的机器码和汇编码完全一样，所以只确定汇编\机器语言不能还原为唯一确定的高级语言，如果一定需要</span></span><br><span class="line"><span class="comment">相关高级语言，那么可以将其还原为伪代码，在人为还原为高级语言。*/</span></span><br></pre></td></tr></table></figure>

<p>​    <strong>在不同架构的CPU下，生成的汇编码不一样</strong></p>
<h5 id="（2）一些编程语言的本质区别"><a href="#（2）一些编程语言的本质区别" class="headerlink" title="（2）一些编程语言的本质区别"></a>（2）一些编程语言的本质区别</h5><ul>
<li><p>C++</p>
<blockquote>
<p>轻易反汇编</p>
</blockquote>
<p>编译器编译为汇编代码，可以和机器码进行转换</p>
</li>
<li><p>JavaScript</p>
<blockquote>
<p>脚本语言，由浏览器进行解析</p>
</blockquote>
</li>
<li><p>PHP</p>
<blockquote>
<p>脚本语言，由Zend Engine(ZE)进行解析</p>
</blockquote>
<p>JS 和 PHP 在通过引擎解析后变为中间代码，然后转为<code>机器码(不同语言的机器码不同)</code>，所以不好接触到底层</p>
</li>
<li><p>Java</p>
<blockquote>
<p>由JVM进行装载字节码</p>
</blockquote>
<p>编译器编译为class（字节码），然后通过JVM虚拟机形转为器码</p>
</li>
</ul>
<p>无论用什么语言编写代码，最终会形成几乎相同的机器码。</p>
<h3 id="2、函数重载（Overload）"><a href="#2、函数重载（Overload）" class="headerlink" title="2、函数重载（Overload）"></a>2、函数重载（Overload）</h3><hr>
<ul>
<li><p>规则</p>
<blockquote>
<p>函数名相同</p>
<p>参数个数不同、参数类型不同、参数顺序不同</p>
</blockquote>
</li>
<li><p>注意</p>
<blockquote>
<p>返回值类型与函数重载无关</p>
<p>调用函数时，实参的隐式类型转换可能会产生二义性</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>本质</p>
<blockquote>
<p>采用了name mangling或者叫name decoration的技术，C++编译器默认会对符号名（比如函数名）进行改变，修饰。</p>
<p>重载时产生的函数名字和编译器有关，不同编译器不同，产生的名字不同。</p>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;        			 		<span class="function">call		<span class="title">display</span><span class="params">(<span class="number">0</span>CA1429h)</span>		</span></span><br><span class="line"><span class="function">    <span class="comment">//...</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;					<span class="function">call		<span class="title">display</span><span class="params">(<span class="number">0</span>CA13F7h)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//...</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">long</span> a)</span></span>&#123;					<span class="function">call		<span class="title">display</span><span class="params">(<span class="number">0</span>CA1230h)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//...</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(doble a)</span></span>&#123;					<span class="function">call		<span class="title">display</span><span class="params">(<span class="number">0</span>CA10B4h)</span>	</span></span><br><span class="line"><span class="function">    <span class="comment">//...																</span></span></span><br><span class="line">&#125;</span><br><span class="line">VS简化了函数名，使其看上去一样，但函数后面括号里的不同数值表示调用的函数地址并不相同。</span><br></pre></td></tr></table></figure>

<p>使用IDA进行逆向工程，在main文件里查看汇编码：</p>
<blockquote>
<p>记得将程序以release版本生成，去除调试信息，使文件精简。但是相对的release会对程序进行相应的优化，比如上面4个打印函数，编译器会直接将4个函数改为4个直接输出，不再进行函数调用。所以要将编译器的优化选项关闭。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call		display</span><br><span class="line">call		display_1</span><br><span class="line">call		display_2</span><br><span class="line">call		display_3			可见的确进行了name mangling使函数重载得以实现</span><br></pre></td></tr></table></figure>



<h3 id="3、默认参数"><a href="#3、默认参数" class="headerlink" title="3、默认参数"></a>3、默认参数</h3><hr>
<p>C++允许函数设置默认参数，在调用时可以根据情况省略实参。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> v1 = <span class="number">5</span>, <span class="keyword">int</span> v2 = <span class="number">6</span>)</span></span>&#123; <span class="comment">// 默认参数值必须从右边开始 int v1 = 10, int v2 ---&gt; 编译不通过</span></span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum(<span class="number">10</span>) &lt;&lt;<span class="built_in">endl</span>;<span class="comment">// 16</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 30</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//同时有声明和实现的时候，只能在声明处填默认参数</span></span><br></pre></td></tr></table></figure>



<p>默认参数的值可以是常量、全局符号（全局变量、函数名）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> v1 = <span class="number">5</span>, <span class="keyword">int</span> v2 = <span class="number">6</span>)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;test(int) - &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">void</span>(*p)(<span class="keyword">int</span>) = test)</span></span>&#123; <span class="comment">//函数指针</span></span><br><span class="line">    p(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>(*p)(<span class="keyword">int</span>) = test;</span><br><span class="line">    p(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum(<span class="number">10</span>) &lt;&lt;<span class="built_in">endl</span>;<span class="comment">// 16</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 30</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>如果函数的参数经常使用同一个值，推荐使用默认参数</strong></p>
<p>函数重载和默认参数共同使用的时候会产生冲突、二义性。在这种情况下建议优先选择默认参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    display(<span class="number">10</span>); <span class="comment">//报错，编译不通过</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认参数的本质：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">push		<span class="number">2</span></span><br><span class="line">push		<span class="number">1</span>    <span class="comment">//传参</span></span><br><span class="line"><span class="function">call		<span class="title">sum</span><span class="params">(<span class="number">0F</span>E1424h)</span></span></span><br><span class="line">add			esp,8</span><br><span class="line"></span><br><span class="line">sum(<span class="number">2</span>, <span class="number">4</span>); </span><br><span class="line">push		<span class="number">4</span></span><br><span class="line">push		<span class="number">2</span></span><br><span class="line"><span class="function">call		<span class="title">sum</span><span class="params">(<span class="number">0F</span>E1424h)</span> <span class="comment">//调用相同的函数地址</span></span></span><br><span class="line">add			esp,8</span><br></pre></td></tr></table></figure>

<p>添加默认参数</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2 = <span class="number">4</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>);</span><br><span class="line">push		<span class="number">4</span></span><br><span class="line">push		<span class="number">1</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//也就是说 sum(1); 和 sum(1, 4); 是完全一样的功能，经验证机器码也是几乎一样。</span></span><br><span class="line"><span class="function">E8 A3 F2 FF FF			call		<span class="title">sum</span><span class="params">(<span class="number">01271424</span>h)</span></span></span><br><span class="line">E8 97 F2 FF FF			call		sum(01271424h)  仅有E8 后面计算出的地址值有细微区别 (详见Intel机器码白皮书)</span><br></pre></td></tr></table></figure>



<h3 id="4、extern-“C”"><a href="#4、extern-“C”" class="headerlink" title="4、extern “C”"></a>4、extern “C”</h3><hr>
<p>被<code>extern &quot;C&quot;</code>修饰的代码会按照C语言的规范去编译</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line">exterm <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123; <span class="comment">//报错，因为C不支持重载</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果函数同时有声明与实现，要在声明处使用<code>extern &quot;C&quot;</code>，在实现处可以不用添加。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">为方便使用直接在头文件使用</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;****.h&quot;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<ul>
<li>使用用C语言开发的第三方框架\库</li>
</ul>
<p>在C\C++混合开发的时候会出现大量问题，推荐按一下方式使用<code>extern &quot;C&quot;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus <span class="comment">//使用宏</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>为了避免重复引用，用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ***</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ***</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>但是一定要保证每一个文件里的宏都不相同，推荐将宏和文件名字相同。<code>#pragma once</code> 可以保证整个文件内容只被编译一次，避免重复包含，但是 <code>#pragma once</code>不被某些编译器支持。</p>
<h3 id="5、内联函数"><a href="#5、内联函数" class="headerlink" title="5、内联函数"></a>5、内联函数</h3><hr>
<p>使用<code>inline</code>关键字将其变为内联函数。编译器直接将函数调用展开为函数体代码。</p>
<p>在函数开始的时候会开辟栈空间，函数结束的时候回收栈空间。内联函数在代码体积不大和使用次数过多的时候推荐使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">int</span> c = sum(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    不内联</span><br><span class="line">    push		<span class="number">14</span>h</span><br><span class="line">    push		<span class="number">0</span>Ah</span><br><span class="line">    <span class="function">call		<span class="title">sum</span><span class="params">(<span class="number">08110</span>A0h)</span></span></span><br><span class="line">    在release模式下，编译器会直接将sum函数优化，直接给出返回值，不再调用函数。</span><br><span class="line">    把优化关闭，进行相关调整后</span><br><span class="line">    mov			eax,<span class="number">0</span>Ah</span><br><span class="line">   	add 		eax,<span class="number">14</span>h</span><br><span class="line">    mov			dword ptr [c],eax  <span class="comment">//等同于直接实现 10 + 20 </span></span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内联函数与宏对比：</p>
<ul>
<li>两者都能减少函数调用</li>
<li>相比于宏内联函数具有函数特性，拥有语法检测和代码提示功能</li>
</ul>
<h3 id="6、表达式"><a href="#6、表达式" class="headerlink" title="6、表达式"></a>6、表达式</h3><hr>
<ul>
<li><p>C++有些表达式能被赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">(a = b) = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// a = 4; b = 2;</span></span><br><span class="line">(a &gt; b ? a : b) = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// b = 4</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="7、const"><a href="#7、const" class="headerlink" title="7、const"></a>7、const</h3><hr>
<ul>
<li><p>const是常量的意思，被修饰的变量不可修改</p>
<p>如果修饰的是类、结构体(的指针)，成员函数不可以更改</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p0 = &amp;age;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p1 = &amp;age; <span class="comment">// p0 p1 等价，都被const修饰</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p2 = &amp;age;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p3 = &amp;age;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p4 = &amp;age; <span class="comment">// p3 p4 等价</span></span><br></pre></td></tr></table></figure>

<p>对于const有以下结论：</p>
<ul>
<li><p>const修饰的是其右边的内容 </p>
<blockquote>
<p>const int * <code>const p3</code> = &age;  意味着p3为常量但是*p3不是常量，可以对 *p3进行修改</p>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span> <span class="keyword">int</span> age; &#125;;</span><br><span class="line">Student stu1 = &#123;<span class="number">20</span>&#125;;</span><br><span class="line">Student stu2 = &#123;<span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Student *pStu1 = &amp;stu1;</span><br><span class="line">*pStu1 = stu2; <span class="comment">// 报错，const修饰*pStu1不能被赋值</span></span><br><span class="line">(*pStu1).age = <span class="number">30</span>; </span><br><span class="line">pStu1-&gt;age = <span class="number">30</span>; <span class="comment">// 报错，为了保证const的严谨性，不允许通过指针访问成员属性</span></span><br><span class="line">pStu1 = &amp;stu2;</span><br><span class="line"></span><br><span class="line">Student * <span class="keyword">const</span> pStu2 = &amp;stu2;</span><br><span class="line">*pStu2 = stu1;</span><br><span class="line">(*pStu2).age = <span class="number">30</span>;</span><br><span class="line">pStu2-&gt;age = <span class="number">30</span>;</span><br><span class="line">pStu2 = &amp;stu1; <span class="comment">// 报错，不能修改pStu2的内容</span></span><br></pre></td></tr></table></figure>

<h3 id="8、引用-Reference"><a href="#8、引用-Reference" class="headerlink" title="8、引用(Reference)"></a>8、引用(Reference)</h3><hr>
<p>在C语言中，使用<code>指针(Pointer)</code>可以间接获取、修改某个变量的值</p>
<p>在C++中，使用<code>引用(Reference)</code>可以起到更指针类似的功能</p>
<p>引用的注意点：</p>
<ul>
<li>引用相当于变量的别名</li>
<li>对引用做计算等于对其指向的变量做运算</li>
<li>必须在定义的时候初始化，而且一旦指向某个变量就不可以再改变</li>
<li>可以利用一个引用初始化另一个引用，相当于一个变量有多个别名</li>
<li>不存在<code>引用的引用</code>、<code>指向引用的指针</code>、<code>引用数组</code></li>
</ul>
<p>引用的价值：比指针更安全、函数返回值可以被赋值</p>
<h5 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h5><ul>
<li>引用的本质就是指针，只是编译器削弱了它的功能，引用就是弱化了的指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> &amp;age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(student) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8 X64环境 也就是从侧面证明了引用的大小为8bit</span></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>汇编码(关闭显示符号):</p>
<ul>
<li>指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;age;</span><br><span class="line">lea			eax,[ebp<span class="number">-18</span>h],eax</span><br><span class="line">mov			dword ptr [ebp<span class="number">-18</span>h],eax</span><br><span class="line">*p = <span class="number">30</span>;</span><br><span class="line">mov 		eax,dword ptr [ebp<span class="number">-18</span>h]</span><br><span class="line">mov 		dword ptr [eax],<span class="number">1</span>Eh</span><br></pre></td></tr></table></figure>

<ul>
<li>引用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;ref = age;</span><br><span class="line">lea			eax,[ebp<span class="number">-18</span>h],eax</span><br><span class="line">mov			dword ptr [ebp<span class="number">-18</span>h],eax</span><br><span class="line">ref = <span class="number">30</span>;</span><br><span class="line">mov 		eax,dword ptr [ebp<span class="number">-18</span>h]</span><br><span class="line">mov 		dword ptr [eax],<span class="number">1</span>Eh</span><br></pre></td></tr></table></figure>

<p>通过对比发现两者的汇编码完全一样，所以一个引用也就占用一个指针的大小</p>
<h1 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a>二、基础语法</h1><h3 id="1、x86，x64汇编"><a href="#1、x86，x64汇编" class="headerlink" title="1、x86，x64汇编"></a>1、x86，x64汇编</h3><hr>
<p>汇编语言的种类</p>
<ul>
<li>8086汇编</li>
<li>x86汇编</li>
<li>x64汇编</li>
<li>ＡＲＭ汇编</li>
<li>．．．．．．</li>
</ul>
<p>根据编译器不同，有两种书写格式</p>
<ul>
<li>Intel(Visual Studio)</li>
<li>AT&amp;T(Mac)</li>
</ul>
<h5 id="x64汇编-寄存器"><a href="#x64汇编-寄存器" class="headerlink" title="x64汇编- 寄存器"></a>x64汇编- 寄存器</h5><p>不同汇编的寄存器不同</p>
<p>常用寄存器：</p>
<table>
<thead>
<tr>
<th align="left">标识符</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>RAX\RBX\RCX\RDX</strong></td>
<td align="left"><strong>(64bit下常见)通用寄存器</strong></td>
</tr>
<tr>
<td align="left"><strong>EAX\EBXECX\EDX</strong></td>
<td align="left"><strong>(32bit下常见))通用寄存器</strong></td>
</tr>
<tr>
<td align="left"><strong>AX\BX\CX\DX</strong></td>
<td align="left"><strong>(16bit下常见)通用寄存器</strong></td>
</tr>
</tbody></table>
<p>tips：</p>
<blockquote>
<ul>
<li><p>一个寄存器能存8个字节(x64)</p>
</li>
<li><p>为了使新的寄存器兼容老旧的寄存器将新寄存器分成更小的区块来存储旧的寄存器</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>63…32</th>
<th>31…16</th>
<th>15…8</th>
<th>7…0</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td><strong>AH…</strong></td>
<td><strong>AL…</strong></td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>AX…</strong></td>
<td><strong>…</strong></td>
</tr>
<tr>
<td></td>
<td><strong>EAX…</strong></td>
<td><strong>…</strong></td>
<td><strong>…</strong></td>
</tr>
<tr>
<td><strong>RAX…</strong></td>
<td><strong>…</strong></td>
<td><strong>…</strong></td>
<td><strong>…</strong></td>
</tr>
</tbody></table>
<p>AH H high</p>
<p>AL  L low</p>
</blockquote>
<h3 id="2、内联汇编"><a href="#2、内联汇编" class="headerlink" title="2、内联汇编"></a>2、内联汇编</h3><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    __asm&#123; <span class="comment">//x86</span></span><br><span class="line">        mov eax, a  <span class="comment">//真实的汇编不会存在a这个符号  实际的汇编码为 eax,dword ptr[ebp-oCh]</span></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;		</span><br></pre></td></tr></table></figure>

<h3 id="3、常见指令"><a href="#3、常见指令" class="headerlink" title="3、常见指令"></a>3、常见指令</h3><hr>
<ul>
<li><p>mov              dest, src</p>
<blockquote>
<p>将src内容赋值给dest，类似于dest = src</p>
</blockquote>
</li>
<li><p>[地址值]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = a + <span class="number">1</span>；</span><br><span class="line">    </span><br><span class="line">mov           dword ptr [ebp<span class="number">-8</span>], <span class="number">3</span></span><br><span class="line"><span class="comment">//mov [1122h], 3 意味着将3放入[1122h]所在的地址空间</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><strong>mov                 [1128h], 3</strong></p>
<p><strong><code>word</code>是2个字节，<code>dword</code>是4个字节，<code>qword</code>是8个字节</strong></p>
<p><strong>mov                 dword ptr [1128h], 3</strong>  //将3放到地址以1128h开始的内存中，并占用dword个内存地址**(向高地址合并)**</p>
<p>4个字节存储3：</p>
<blockquote>
<p>16进制: 00 00 00 03H </p>
<p>2进制: 00000000 00000000 00000000 00000011</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">内存地址</th>
<th align="center">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1122h</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1123h</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1124h</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1125h</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1126h</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1127h</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1128h</td>
<td align="center">3     (00 00 00 11) 小端模式</td>
</tr>
<tr>
<td align="center">1129h</td>
<td align="center">|      (00 00 00 00)</td>
</tr>
<tr>
<td align="center">112Ah</td>
<td align="center">|      (00 00 00 00)</td>
</tr>
<tr>
<td align="center">112Bh</td>
<td align="center">|      (00 00 00 00)</td>
</tr>
</tbody></table>
<p>大部分时候是小端模式(高字节放高地址，低字节放低地址)，注意在读地址的时候不论大小端模式，都是从低地址开始读，读取设定的字节后，如何排列顺序再考虑大小端模式问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="number">0x007DF968</span>		<span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> cc cc cc cc <span class="comment">//8个字节， a占用了4个字节</span></span><br><span class="line"><span class="number">0x007DF970</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>一个变量的地址值，是他所有字节地址中的最小值</p>
</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">mov 	dword ptr [ebp<span class="number">-8</span>], <span class="number">3</span></span><br><span class="line"><span class="comment">//[ebp-8] 即为变量a的地址</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;　&amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//a的地址为 010FFE4C</span></span><br><span class="line">汇编码为:</span><br><span class="line">mov		dword ptr [ebp<span class="number">-0</span>Ch], <span class="number">3</span> <span class="comment">//这里的值不能写死，因为每次调用函数时开辟栈空间</span></span><br><span class="line">    						 <span class="comment">//而且每一次分配的地址不同，里面的局部变量的地址会一直改变</span></span><br><span class="line">    						 <span class="comment">//每次调用都不同， -0ch 则涉及到函数栈的问题。</span></span><br><span class="line"><span class="comment">//ebp的值为 010FFE58</span></span><br><span class="line">a - ebp = c (<span class="number">16</span>进制)</span><br><span class="line">    </span><br><span class="line">如果是全局变量的地址值,该变量的地址值是写死的</span><br><span class="line">age = <span class="number">3</span>;</span><br><span class="line">mov			dword ptr ds:[<span class="number">00F</span>DA008h] <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">常量的话地址值也会变动</span><br></pre></td></tr></table></figure>

<ul>
<li>call 函数地址</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	test();   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">首先:</span><br><span class="line">call		<span class="number">003713</span>A2 <span class="comment">//并非真正函数地址 按F11</span></span><br><span class="line"></span><br><span class="line">jmp			<span class="number">00371780</span> <span class="comment">//跳转到真正的函数地址 进入这个地址</span></span><br><span class="line">    </span><br><span class="line"><span class="number">00371780</span> <span class="number">55</span>			push		ebp</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ul>
<li>lea               eax, [1122h]     //load effect address 装载一个有效的地址值</li>
</ul>
<blockquote>
<p>等同于 mov             eax, 1122h</p>
</blockquote>
<ul>
<li>ret</li>
</ul>
<blockquote>
<p>函数返回</p>
</blockquote>
<ul>
<li>xor</li>
</ul>
<blockquote>
<p>异或 xor            op1, op2将op1和op2异或的结果赋值给op1</p>
</blockquote>
<ul>
<li>add，sub</li>
</ul>
<blockquote>
<p>加法，减法</p>
</blockquote>
<ul>
<li>inc，dec</li>
</ul>
<blockquote>
<p>自增，自减</p>
</blockquote>
<ul>
<li>jmp</li>
</ul>
<blockquote>
<p>jmp             内存地址      跳转到指定的内存地址开始执行(无条件跳转)</p>
<p>以 j 开头的汇编指令一般都是跳转，一般跟test、cmp等指令配合使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a == b)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="number">007118F</span>8  mov         dword ptr [ebp<span class="number">-8</span>],<span class="number">0</span>Ah  </span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="number">007118F</span>F  mov         dword ptr [ebp<span class="number">-14</span>h],<span class="number">14</span>h  </span><br><span class="line"><span class="keyword">if</span> (a == b) &#123;</span><br><span class="line"><span class="number">00711906</span>  mov         eax,dword ptr [ebp<span class="number">-8</span>]  </span><br><span class="line"><span class="number">00711909</span>  cmp         eax,dword ptr [ebp<span class="number">-14</span>h]  </span><br><span class="line"><span class="number">0071190</span>C  jne         <span class="number">0071191</span>D  </span><br><span class="line"><span class="comment">// jump not equal</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="number">0071190</span>E  push        <span class="number">717B</span>30h  </span><br><span class="line"><span class="number">00711913</span>  call        <span class="number">00711046</span>  </span><br><span class="line"><span class="number">00711918</span>  add         esp,<span class="number">4</span>  </span><br><span class="line">	&#125;</span><br><span class="line"><span class="number">0071191B</span>  jmp         <span class="number">0071192</span>A  </span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="number">0071191</span>D  push        <span class="number">717B</span>34h  <span class="comment">// jne 跳转的地址</span></span><br><span class="line"><span class="number">00711922</span>  call        <span class="number">00711046</span>  </span><br><span class="line"><span class="number">00711927</span>  add         esp,<span class="number">4</span>  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0071192</span>A  <span class="keyword">xor</span>         eax,eax <span class="comment">// jmp 跳转的地址</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>汇编权威参考： Intel 白皮书</strong></p>
<h3 id="4、引用"><a href="#4、引用" class="headerlink" title="4、引用"></a>4、引用</h3><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> age = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> *p = &amp;age;</span><br><span class="line">	*p = <span class="number">5</span>;</span><br><span class="line">	</span><br><span class="line"><span class="number">007</span>D17F2  mov         dword ptr [ebp<span class="number">-0</span>C h],<span class="number">3</span>  </span><br><span class="line"><span class="number">007</span>D17F9  lea         eax,[ebp<span class="number">-0</span>Ch]  <span class="comment">// eax 存放age的地址值</span></span><br><span class="line"><span class="number">007</span>D17FC  mov         dword ptr [ebp<span class="number">-18</span>h],eax  </span><br><span class="line"><span class="comment">//将age的地址值存放到指针变量p所在的存储空间</span></span><br><span class="line"><span class="number">007</span>D17FF  mov         eax,dword ptr [ebp<span class="number">-18</span>h]  </span><br><span class="line"><span class="comment">//将age的地址值存放到 eax</span></span><br><span class="line"><span class="number">007</span>D1802  mov         dword ptr [eax],<span class="number">5</span>  </span><br><span class="line"><span class="comment">//将5放到age的地址值</span></span><br><span class="line"><span class="number">007</span>D1808  mov         esi,esp  </span><br><span class="line">    </span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以如果代码牵扯到指针，那么一定会牵扯到汇编的 <code>lea</code> 指令</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lea 		eax,[ebp<span class="number">-0</span>Ch] <span class="comment">// [ebp-0Ch]数据地址值</span></span><br><span class="line">mov 		dword ptr [ebp<span class="number">-18</span>h],eax <span class="comment">//[ebp-18h]指针变量自己的地址值</span></span><br></pre></td></tr></table></figure>

<p>如果是引用的话：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">3</span></span><br><span class="line"><span class="keyword">int</span> &amp;ref = age;</span><br><span class="line">ref = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">00B</span>817F2  mov         dword ptr [ebp<span class="number">-0</span>Ch],<span class="number">3</span>  </span><br><span class="line"><span class="number">00B</span>817F9  lea         eax,[ebp<span class="number">-0</span>Ch]  </span><br><span class="line"><span class="number">00B</span>817FC  mov         dword ptr [ebp<span class="number">-18</span>h],eax  </span><br><span class="line"><span class="number">00B</span>817FF  mov         eax,dword ptr [ebp<span class="number">-18</span>h]  </span><br><span class="line"><span class="number">00B</span>81802  mov         dword ptr [eax],<span class="number">5</span></span><br><span class="line"><span class="comment">// 和指针的汇编码完全一样</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指针引用</span></span><br><span class="line">*<span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;age;</span><br><span class="line"><span class="keyword">int</span> *&amp;ref = p;</span><br><span class="line">*ref = <span class="number">30</span>; <span class="comment">// ref == f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> height = <span class="number">30</span>;</span><br><span class="line">ref = &amp;height; <span class="comment">// p = 30;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组引用</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (&amp;ref)[<span class="number">3</span>] = <span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *arr[<span class="number">3</span>]; <span class="comment">//指针数组，数组内部能放3个int*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*arr)[<span class="number">3</span>]; <span class="comment">//数组指针，用于指向数组的指针  ----&gt;  推出数组指针的一种写法 int (&amp;arr)[3] = array;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h5><p>const必须写在&amp;符号的左边才是常饮用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref = age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp; <span class="keyword">const</span> ref = age;</span><br><span class="line">ref = <span class="number">30</span>;</span><br><span class="line"><span class="comment">//ref 不能修改指向，但是可以通过ref间接修改所指向的变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对比指针</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p1 = &amp;age; <span class="comment">// p1 = &amp;height</span></span><br><span class="line">*p1 = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p2可以修改指向，不可以利用p2间接修改所指向的变量</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p2 = &amp;age;</span><br></pre></td></tr></table></figure>

<h5 id="const-引用的特点"><a href="#const-引用的特点" class="headerlink" title="const 引用的特点"></a>const 引用的特点</h5><ul>
<li>const引用可以指向临时数据(常量、表达式、函数返回值等等)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref = <span class="number">30</span>; <span class="comment">//常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref = a + b; <span class="comment">// 表达式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;ref = func(); <span class="comment">// 函数返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>作为函数参数时(同时适用于const指针)</li>
</ul>
<blockquote>
<p>可以接受const和非const实参(非const引用，只能接受非const实参)</p>
<p>可以跟非const引用构成重载</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;v1, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> v1 + v2;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> &amp;v1, <span class="keyword">int</span> &amp;v2)</span></span>&#123; <span class="comment">// 构成重载</span></span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 非const实参</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//const实参</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> d = <span class="number">20</span></span><br><span class="line">    sum(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    sum(c, d);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当常引用指向了不同的数据时，会产生<code>临时变量</code>，即引用指向的并不是初始化时的那个变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> &amp;rAge = age;</span><br><span class="line">age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; age; <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; rAge; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="number">00</span>CB17F2  mov         dword ptr [ebp<span class="number">-0</span>Ch],<span class="number">0</span>Ah  <span class="comment">// </span></span><br><span class="line"><span class="number">00</span>CB17F9  mov         eax,dword ptr [ebp<span class="number">-0</span>Ch]  <span class="comment">// 10 放到 eax</span></span><br><span class="line"><span class="number">00</span>CB17FC  mov         dword ptr [ebp<span class="number">-24</span>h],eax  <span class="comment">// 10 放到另外一个存储空间</span></span><br><span class="line">相当于 <span class="keyword">const</span> <span class="keyword">long</span> &amp;rAge = temp;</span><br><span class="line"><span class="number">00</span>CB17FF  lea         ecx,[ebp<span class="number">-24</span>h]  </span><br><span class="line"><span class="number">00</span>CB1802  mov         dword ptr [ebp<span class="number">-18</span>h],ecx  </span><br><span class="line"><span class="number">00</span>CB1805  mov         dword ptr [ebp<span class="number">-0</span>Ch],<span class="number">1</span>Eh  </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (&amp;ref)[<span class="number">3</span>]arr = arr;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> &amp;ref = arr;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>学习笔记</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>并发：互斥与同步的各种实现</title>
    <url>/myblog/2020/10/07/C/%E5%B9%B6%E5%8F%91%EF%BC%9A%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="并发：互斥与同步的各种实现"><a href="#并发：互斥与同步的各种实现" class="headerlink" title="并发：互斥与同步的各种实现"></a>并发：互斥与同步的各种实现</h1><hr>
<p>在操作系统中，核心的设计问题在与进程和线程的管理。而在对于在<code>多道程序处理</code>, <code>多处理器环境</code>，<code>分布式系统</code>等相关领域的应用，以及操作系统设计的本身，最基础的问题就是并发(Concurrency)。</p>
<p><em>由于篇幅问题，在这里只讨论各种实现，不对其各种方案的优劣进行过多讨论，感兴趣的可以参考 《操作系统 精髓与设计原理》</em></p>
<h3 id="一、互斥的硬件支持方案"><a href="#一、互斥的硬件支持方案" class="headerlink" title="一、互斥的硬件支持方案"></a>一、互斥的硬件支持方案</h3><hr>
<h5 id="1、关中断"><a href="#1、关中断" class="headerlink" title="1、关中断"></a>1、关中断</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* disable interrupts */</span></span><br><span class="line">    <span class="comment">/* critical section */</span>  临界区执行</span><br><span class="line">    <span class="comment">/* enable interrupts */</span></span><br><span class="line">    <span class="comment">/* remainder */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过采用操作系统提供的原语的方式可以使临界区的执行不可以被打断，达到了互斥的效果。</p>
<p>但是该方案有两个明显缺陷：</p>
<ul>
<li>由于临界区的执行，导致处理器不能随意穿插执行进程，导致处理器效率明显降低</li>
<li>该方案不能直接用于多处理器系统中，因为在同一时间里，可能会有多个进程在同时进行，只对一个进程进行关中段不一定能保证互斥</li>
</ul>
<h5 id="2、特殊机器指令"><a href="#2、特殊机器指令" class="headerlink" title="2、特殊机器指令"></a>2、特殊机器指令</h5><p>当处理器访问某一内存地址的时候，为了通过硬件手段避免其他处理器对该内存地址的访问，设计了几条机器指令来实现两个或两个以上动作的原子性。</p>
<p>1&gt; 比较替换指令</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span><span class="params">(<span class="keyword">int</span> *word, <span class="keyword">int</span> testVal, <span class="keyword">int</span> newVal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldVal;</span><br><span class="line">    oldVal = *word;</span><br><span class="line">    <span class="keyword">if</span>(oldVal == testVal)</span><br><span class="line">    &#123;</span><br><span class="line">        *word = testVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125; <span class="comment">// 这个函数的操作不可被干扰或者打断，具有原子性。</span></span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* program mutualexclusion */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="comment">/* number of process */</span> 进程的数量</span><br><span class="line"><span class="keyword">int</span> bolt; 共享变量初值为 <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(compare_and_swap(bolt, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>) 只有当发现bolt为<span class="number">0</span>的进程才能进入临界区，而其他的进程不停的比较替换申请进入临界区</span><br><span class="line">            								  会造成忙等现象</span><br><span class="line">            <span class="comment">/* do nothing */</span>;</span><br><span class="line">        <span class="comment">/* critical section */</span>;</span><br><span class="line">        bolt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* remainder */</span>; bolt被置零后其他进程才有一个机会将bolt置<span class="number">1</span>进入临界区</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bolt = <span class="number">0</span>;</span><br><span class="line">    parbeging( p(<span class="number">1</span>), p(<span class="number">2</span>), p(<span class="number">3</span>) ......);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2&gt; 交换指令</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> *<span class="keyword">register</span>, <span class="keyword">int</span> *memory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = *memory;</span><br><span class="line">    *memory = *<span class="keyword">register</span>;</span><br><span class="line">    *<span class="keyword">register</span> = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* program mutualexclusin */</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> n = <span class="comment">/* number of process */</span>;</span><br><span class="line"><span class="keyword">int</span> bolt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> keyi = <span class="number">1</span>;</span><br><span class="line">        do exchange(&amp;key1, &amp;bolt) 如果交换后key = 1, 那么就进入临界区，否则在临界区外忙等</span><br><span class="line">        <span class="keyword">while</span>(keyi != <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* critical section */</span></span><br><span class="line">        bolt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* remainder */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bolt = <span class="number">0</span>;</span><br><span class="line">    parbegin( p(<span class="number">1</span>), p(<span class="number">2</span>), p(<span class="number">3</span>) ......);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对于共享变量和局部变量的交换方式，以下的表达式始终成立<br>$$<br>bolt + \sum_ikey_{i} = 1<br>$$<br>bolt = 0 没有进程进入临界区，blot = 1 有且只有一个进程在临界区</p>
<h3 id="二、信号灯-Semaphore"><a href="#二、信号灯-Semaphore" class="headerlink" title="二、信号灯(Semaphore)"></a>二、信号灯(Semaphore)</h3><hr>
<p>信号灯是一个特殊的整型变量。向信号灯 <code>s</code> 发送信号，进程可以调用 <code>semSignal(s)</code> 原语。从信号灯处接收信号，进程可以调用<code>semWait(s)</code> 原语。如果进程打算接受消息的时候，消息尚未到达，则该进程必须在信号灯上等待。因此对信号灯做以下定义：</p>
<ol>
<li><strong>信号灯初值为非负整数。</strong></li>
<li><strong>semWait 操作将信号灯的值减1。如果其值为负数，调用semWait的进程执行将被阻塞。否则进程将继续执行。</strong></li>
<li><strong>semSignal操作将信号灯的值加1。如果之后其值小于等于0，则进程唤醒在该信号灯上等待的一个进程，并继续自己的执行。</strong></li>
</ol>
<p>（除了以上的3种操作以外不允许对信号灯做其他的操作）</p>
<p>信号灯的定义和操作的定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    queueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semWait</span><span class="params">(semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="keyword">if</span>(count &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/* place this process in s.queue */</span>;</span><br><span class="line">        <span class="comment">/* block this process */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semSignal</span><span class="params">(semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.count++;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/* remove a process P from s.queue */</span>;</span><br><span class="line">        <span class="comment">/* palce process P on ready list */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>01信号灯，01信号灯只有两个取值：0和1，其操作原语定义如下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_semaphore</span>&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;zero, oen&#125; value; 初值可以取<span class="number">0</span>或<span class="number">1</span></span><br><span class="line">    queueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semWaitB</span><span class="params">(binary_semaphore s)</span> <span class="comment">//检测信号灯的取值，如果值为0，执行semWaitB操作的进程将被阻塞。如果值为1，信号灯的值将被置0，并且进程继续执行</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.value == one)</span><br><span class="line">        s.value = zero;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">/* place this process in s.queue */</span></span><br><span class="line">        <span class="comment">/* block this process */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> semSignalB(semaphore s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">queue</span> is empty()) <span class="comment">//检测是否有进程被阻塞在信号灯上，如果有将唤醒一个被阻塞的进程。如果没有则将信号灯的值置1。</span></span><br><span class="line">        s.value = one;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">/* remove a process P from s.queue */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1、互斥的实现"><a href="#1、互斥的实现" class="headerlink" title="1、互斥的实现"></a>1、互斥的实现</h5><p>采用信号灯实现互斥的例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* program mutualexclusion */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="comment">/* number of processes */</span>;</span><br><span class="line">semaphore s = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(s); <span class="comment">//进程在进入critical section前调用semWait(s)原语，如果s&lt;0,进程阻塞。如果s=1, s-1后，进程进入临界区访问公共资源</span></span><br><span class="line">        <span class="comment">/* critical section */</span>;</span><br><span class="line">        semSignal(s); <span class="comment">//最开始进入的进程执行完临界区后将信号灯的值加1，并将信号灯等待队列上的一个等待进程唤醒，并置为就绪态</span></span><br><span class="line">        <span class="comment">/* remainder */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parbegin( p(<span class="number">1</span>), p(<span class="number">2</span>), p(<span class="number">3</span>)...... );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于以上的实现，信号灯的取值 <code>s.count</code> 可以这样理解：</p>
<ul>
<li>s.count &gt;= 0：能够通过调用semWait(s)原语，而无需阻塞就能进入临界区的进程个数。信号灯的这一特性，还能用于实现进程协作。</li>
<li>s.count &lt; 0：其绝对值就是在s.queue上等待信号灯的进程的个数。</li>
</ul>
<h5 id="2、生产者-消费者问题"><a href="#2、生产者-消费者问题" class="headerlink" title="2、生产者/消费者问题"></a>2、生产者/消费者问题</h5><p>生产者生产数据放入缓冲区，消费者将数据从缓冲区取出，一次取一个，不允许两者对缓冲区同时操作。</p>
<p>假设缓冲区的结构是一个线性表。</p>
<p>采用01信号灯和无线缓冲来解决生产者/消费者问题的（<strong>错误</strong>）方案</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* program producer&amp;consumer */</span></span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">//记录缓冲区中“产品”的个数 n = in - out</span></span><br><span class="line">binary_semaphore s = <span class="number">1</span>, delay = <span class="number">0</span>; <span class="comment">//采用delay用于在缓冲区为0的时候迫使消费者等待</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWaitB(s); <span class="comment">//生产者可以在任何时候向缓冲区放入生产的数据</span></span><br><span class="line">       	append();</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) semSignalB(delay); <span class="comment">//n = 1, 之前缓冲区为0，唤醒消费者</span></span><br><span class="line">        semSignalB(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    semWaitB(delay); <span class="comment">//等待第一个可以“消费”的数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(B); </span><br><span class="line">        take();</span><br><span class="line">        n--;</span><br><span class="line">        semSignalB(B);</span><br><span class="line">        consume();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) semWaitB(delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    parbegin(producer, consumer);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">semWait(B); <span class="comment">//消费者消费完所有的数据后，需要重置delay信号，在生产者未产生出新的数据前等待</span></span><br><span class="line">		   <span class="comment">//就是 if(n == 0) semWaitB(delay); 语句的作用，但是实际上并没有执行该语句，导致消费者消费了不存在的数据</span></span><br><span class="line">take();</span><br><span class="line">n--;</span><br><span class="line">semSignalB(B);</span><br></pre></td></tr></table></figure>

<p>原因是生产者在消费者对n再次判断之前对n进行了加1操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">n++;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) semSignalB(delay); <span class="comment">//误以为是放入的第一个数据，其实是剩余的最后一个数据 </span></span><br></pre></td></tr></table></figure>

<p>再次调用了semSignal(delay)向delay信号灯发送了信号，而在这之前没有与之配对的semWait(delay)调用。</p>
<p>以下是正确方案</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* program producer&amp;consumer */</span></span><br><span class="line"><span class="keyword">int</span> n; </span><br><span class="line">binary_semaphore s = <span class="number">1</span>, delay = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWaitB(s); </span><br><span class="line">       	append(); </span><br><span class="line">        n++; </span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) semSignalB(delay); </span><br><span class="line">        semSignalB(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m; <span class="comment">/* a local variable */</span></span><br><span class="line">    semWaitB(delay); </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(B); </span><br><span class="line">        take(); </span><br><span class="line">        n--; </span><br><span class="line">        m = n;</span><br><span class="line">        semSignalB(B);</span><br><span class="line">        consume();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) semWaitB(delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    parbegin(producer, consumer);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用<code>信号灯和无线缓冲</code>来解决生产者/消费者问题的方案</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* program producer&amp;consumer */</span></span><br><span class="line">semphore n = <span class="number">0</span>, s = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWait(s);</span><br><span class="line">        append();</span><br><span class="line">        semSignal(s); <span class="comment">//生产者的semSignal(s)和semSignal(n)对换，将导致生产者在临界区内对n信号灯进行semSignal操作，不会有不好的影响</span></span><br><span class="line">        semSignal(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            semWait(n);</span><br><span class="line">            semWait(s); <span class="comment">//如果将semWait(s)与semWait(n)对换的话，如果n为0，缓冲区为空那么会阻塞在信号灯n上，同时生产者的执行也被阻塞，导致死锁。</span></span><br><span class="line">            take();</span><br><span class="line">            semSignal(s);</span><br><span class="line">            consume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parbegin (producer, consumer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后考虑实际情况，当缓冲区有限的时候，将缓冲区设置为一个环形的结构，指针的值为对缓冲区大小取模的值，并且考虑以下的阻塞唤醒关系</p>
<table>
<thead>
<tr>
<th align="center">阻塞时机</th>
<th align="center">唤醒时机</th>
</tr>
</thead>
<tbody><tr>
<td align="center">生产者：往满的缓冲区中放数据</td>
<td align="center">消费者：数据被放入</td>
</tr>
<tr>
<td align="center">消费者：从空的缓冲区中区数据</td>
<td align="center">生产者：数据被取出</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* program boundedBuffer */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sizeofbuffer = <span class="comment">/* buffer size */</span>;</span><br><span class="line">semaphore s = <span class="number">1</span>, n = <span class="number">0</span>, e = sizeofbuffer; <span class="comment">//用信号灯e来代表缓冲区的大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWait(e);</span><br><span class="line">        semWait(s);</span><br><span class="line">        append();</span><br><span class="line">        semSignal(s);</span><br><span class="line">        semSignal(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(n);</span><br><span class="line">        semWait(s);</span><br><span class="line">        take();</span><br><span class="line">        semSignal(s);</span><br><span class="line">        semSignal(e);</span><br><span class="line">        consume();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parbegin( producer, consumer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、信号灯的实现"><a href="#3、信号灯的实现" class="headerlink" title="3、信号灯的实现"></a>3、信号灯的实现</h5><p>比较和替换指令实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">semWait(s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(compare_and_swap(s.flag, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    	<span class="comment">/* do nothing */</span>;</span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* place this process in s.queue */</span>;</span><br><span class="line">        <span class="comment">/* block this process(must also set s.flag to 0) */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">semSignal(s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(compare_and_swap(s.flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        <span class="comment">/* do nothing */</span>;</span><br><span class="line">    s.count++;</span><br><span class="line">   	<span class="keyword">if</span>(s.count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* remove a process in form s.queue */</span>;</span><br><span class="line">        <span class="comment">/* place a process P on ready list */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中断实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">semWait(s)</span><br><span class="line">&#123;</span><br><span class="line">    inhibit interrupts;</span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* place this process in s.queue */</span>;</span><br><span class="line">        <span class="comment">/* block this process and allow interrupts */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        allow interrupts;</span><br><span class="line">&#125;</span><br><span class="line">semSignal(s)</span><br><span class="line">&#123;</span><br><span class="line">    inhibit interrupts;</span><br><span class="line">    s.count++;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* remove a process P from s.queue */</span>;</span><br><span class="line">        <span class="comment">/* place process P on ready list */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    allow interrupts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="三、管程-Monitor"><a href="#三、管程-Monitor" class="headerlink" title="三、管程(Monitor)"></a>三、管程(Monitor)</h3><hr>
<p>采用信号灯的方式实现正确的程序并不容易，因为semWait和semSignal操作分布于操作系统的各个地方，从而很难看到这些信号灯操作的整体效果所导致的。</p>
<p><code>管程</code> 的提出就是希望设计一种程序设计语言，它能够提供和信号灯相同的功能且易于控制。</p>
<h5 id="1、管程和信号"><a href="#1、管程和信号" class="headerlink" title="1、管程和信号"></a>1、管程和信号</h5><p>管程可以看作是包含了一个或者多个函数，一个初始化过程，以及本地数据的软件模块。主要特征如下</p>
<ul>
<li>本地数据只能够被管程的内部函数所访问，外部函数无法 访问其本地</li>
<li>进程只能通过调用管程自己定义的函数来进入管程</li>
<li>在管程内执行的进程一次只能有一个；当管程被占用，其他试图进入的进程将被阻塞，等待管程重新可用后才能进入。</li>
</ul>
<p>管程定义了一个同步工具用来更好地支持并发处理。当某一个进入管程的进程因为不满足某个执行条件而必须被阻塞的时候，那么便需要某种机制(同步工具)使得该进程在被阻塞后释放管程，之后在其满足运行条件后，该进程能够重新回到管程中继续执行。</p>
<p>管程采用了 <code>条件变量(Condition Variables)</code> 方法来实现这种同步工具，并且只能用以下两个函数来访问。</p>
<ul>
<li>cwait(c)：将调用该函数访问条件变量c的进程阻塞，并且释放管程给其他的进程使用。</li>
<li>csignal(c)：继续执行之前因为调用cwait函数访问条件变量c而阻塞的进程。如果这类进程有多个，那么选择其中之一；如果没有，则不做任何操作。</li>
</ul>
<p>采用管程来解决有限缓冲区生产者/消费者问题的方案</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* program production&amp;consumer */</span></span><br><span class="line">monitor bunderbuffer;</span><br><span class="line"><span class="keyword">char</span> buffer [N];</span><br><span class="line"><span class="keyword">int</span> nextin, next out;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">cond notfull, notempty;</span><br><span class="line"><span class="comment">//notfull: 缓冲区有剩余空间时为真 notempty：缓冲区中有有效计算结果时为真</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count == N) cwait(notfull); <span class="comment">// buffer满了，要避免overflow</span></span><br><span class="line">    buffer[nextin] = x;</span><br><span class="line">    nextin = (nextin + <span class="number">1</span>) % N;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">/* one more item in buffer */</span></span><br><span class="line">    csignal(notempty); <span class="comment">// resume any waiting consumer</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>) cwait(notempty); <span class="comment">//buffer空，避免underflow</span></span><br><span class="line">    x = buffer[nextout];</span><br><span class="line">    nextout = (nextout + <span class="number">1</span>) % N;</span><br><span class="line">    count--;</span><br><span class="line">    csignal(notfull); <span class="comment">//resume any waiting producer</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    nextin = <span class="number">0</span>; nextout = <span class="number">0</span>; count = <span class="number">0</span>; <span class="comment">//buffer 初始化为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        produce(x);</span><br><span class="line">        append(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        take(x);</span><br><span class="line">        consume(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parbegin( producer, consumer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>管程的真正优势就在于它所有的操作都被限制在管程内部，这样就更容易检查设计是否正确。</p>
<h5 id="2、采用通知和广播的管程模型"><a href="#2、采用通知和广播的管程模型" class="headerlink" title="2、采用通知和广播的管程模型"></a>2、采用通知和广播的管程模型</h5><p>在 <code>Mesa</code> 语言中，csignal原语被cnotify原语替代，当管程调用了cnotify(x)原语后，它将导致条件变量x的等待队列收到通知，且调用cnotify(x)原语的进程将继续执行。</p>
<p>用while语句替换if语句，这样就保证了条件变量的重新检测。同时避免了进程的额外切换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(count == N) cwait(notfull); <span class="comment">/* buffer is full avoid overflow */</span></span><br><span class="line">    buffer[nextin] = x;</span><br><span class="line">    nextin = &#123;nextin + <span class="number">1</span>&#125; % N;</span><br><span class="line">    count++;</span><br><span class="line">    cnotify(notempty); <span class="comment">/* notify any waiting consumer */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(count == <span class="number">0</span>) cwait(notempty); <span class="comment">/* buffer is empty; avoid underflow */</span></span><br><span class="line">    x = buffer[nextout];</span><br><span class="line">    nextout = (nextout + <span class="number">1</span>) % N; <span class="comment">/* one fewer item in buffer */</span></span><br><span class="line">    cnotify[notfull]; <span class="comment">/* notify ant waiting producer */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四、消息通信"><a href="#四、消息通信" class="headerlink" title="四、消息通信"></a>四、消息通信</h3><hr>
<p>一般来说，进程的交互和协作需要两个基本元素：同步和通信。同步用于进程的互斥，通信则用于进程间的协作。 <code> 消息通信</code> 就能提供这两个基本元素，而且应用范围很广。不同的操作系统对消息通信的实现的细节上有所出入。以下内容讨论其实现的共性的部分。</p>
<p>消息通信的基本形式为以下两个原语：</p>
<ul>
<li>send(destination, message)</li>
<li>receive(source, message)</li>
</ul>
<p>采用send原语，一个进程可以将消息发送给另一个进程(destination)；采用receive原语，一个进程可以接收来自消息源的消息。</p>
<h5 id="1、同步"><a href="#1、同步" class="headerlink" title="1、同步"></a>1、同步</h5><p>无论消息发送还是消息接受都有阻塞和非阻塞两种可能。在具体的系统设计中有以下3中组合。</p>
<ul>
<li><p>发送端阻塞，接收端阻塞</p>
<p>两端都阻塞，消息被接收后再将两端唤醒。这一组合又被称为交汇点(rendzvous)方案，常被用于要求进程强行同步通信的场合</p>
</li>
<li><p>发送端不阻塞，接收端阻塞</p>
<p>发送端在发送完消息后继续执行，而接收端必须阻塞，直到接收到消息后才被唤醒。这一方案是是被最广泛应用的，能够最快的将消息发送给多个目的进程，而接收端必须等待消息到达后才能做有用的工作。</p>
</li>
<li><p>发送端不阻塞，接收端阻塞</p>
</li>
</ul>
<h5 id="2、互斥的实现"><a href="#2、互斥的实现" class="headerlink" title="2、互斥的实现"></a>2、互斥的实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* program mutualexclusion */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="comment">/* number of process */</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    message msg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        receive(box, msg); <span class="comment">// 任何希望进入临界区的进程都必须先获得一个消息，如果邮箱为空</span></span><br><span class="line">        <span class="comment">/* critical section */</span>;</span><br><span class="line">        send(box, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">create <span class="title">mailbox</span><span class="params">(box)</span></span>; <span class="comment">//初始化阶段，邮箱中只存放了一个内容为null的消息</span></span><br><span class="line">    send(box, null);</span><br><span class="line">    parbegin( p(<span class="number">1</span>), p(<span class="number">2</span>), p(<span class="number">3</span>)...... );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果并发地调用消息接收原语，那么就会有：</p>
<ul>
<li>如果邮箱中有一个消息，该消息将被一个进程接收，而其他的进程都将阻塞</li>
<li>如果邮箱中没有消息，所有的进程都将被阻塞。而当之后有一个消息传入邮箱后，只有一个等待态的进程被唤醒，并获得该消息</li>
</ul>
<p>采用消息通信来解决有限缓冲的生产者/消费者问题的方案</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span></span><br><span class="line">    capacity = <span class="comment">/* buffering capacity */</span>;</span><br><span class="line">	null = <span class="comment">/* empty message */</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    message pmsg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        receive(mayproduce, pmsg); <span class="comment">//生产者接收到生产的消息</span></span><br><span class="line">        pmsg = produce(); <span class="comment">//pmsg 表示生产完成,等同于完成临界区</span></span><br><span class="line">        send(mayconsume, pmsg);  <span class="comment">//向消费者发送发消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    message cmsg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        receive(mayproduce, cmsg); <span class="comment">//从mayproduce接收到有数据的消息cmsg</span></span><br><span class="line">        consume(cmsg); <span class="comment">//进入消费的临界区</span></span><br><span class="line">        send(mayproduce, null); <span class="comment">//消费完成，向mayproduce发送空消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    create_mailbox(mayproduce); <span class="comment">//该方案设计了两个邮箱</span></span><br><span class="line">    create_mailbox(mayconsume);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; capacity; i++)	send(mayproduce, null);</span><br><span class="line">    parbegin( producer, consumer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方案非常灵活，可以容纳多个生产者以及多个消费者同时工作。另外，该方案也可以在分布式系统中实现有限缓冲的生产者消费者问题，其中生产者、消费者以及两个邮箱都可以放置在不同的机器上面。</p>
<h3 id="五、读者-写者问题"><a href="#五、读者-写者问题" class="headerlink" title="五、读者/写者问题"></a>五、读者/写者问题</h3><hr>
<p>读者/写者问题是另一个经典的同步和并发问题，描述如下：</p>
<p>有一块共享的数据区域(该区域可以是一个文件，一块内存或处理器中的一组寄存器)，有一组进程(读者)，它们对该共享数据区的访问都是只读的，另外还有一组进程(写者)，它们对该共享数据的访问只是只写。访问规则如下：</p>
<ol>
<li>可以有任意多个读者同时读取数据区的内容；</li>
<li>一次只有一个写者允许向数据区中写；</li>
<li>写者在向数据区中写时，不允许读者同时读取；</li>
</ol>
<p>读者对共享数据区的访问不是独占的，但写者对共享数据区的访问是独占的，无论读者或者写者都不允许同时访问该共享数据区。</p>
<h5 id="1、读者优先"><a href="#1、读者优先" class="headerlink" title="1、读者优先"></a>1、读者优先</h5><p>采用信号灯解决读者/写者问题的方案：读者优先</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* program readers&amp;writers */</span></span><br><span class="line"><span class="keyword">int</span> readcount;</span><br><span class="line">semaphore x = <span class="number">1</span>, wsem = <span class="number">1</span>; <span class="comment">//信号灯wsem用于互斥访问。当有写者在访问共享数据时，不允许读者或者写者同时访问共享数据。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(x);</span><br><span class="line">        readcount++;</span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">1</span>) <span class="comment">//为了使多个读者能够同时访问共享数据而且不会于写者冲突，该方案要求第一个读者必须等待wsem</span></span><br><span class="line">   	    	semWait(wsem); <span class="comment">//信号灯，但是后续到达的读者可以不用等待到达的信号灯就直接进入临界区</span></span><br><span class="line">        semSignal(x);</span><br><span class="line">        READUNIT();</span><br><span class="line">        semWait(x);</span><br><span class="line">        readcount--;</span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">0</span>)</span><br><span class="line">            semSignal(wsem);</span><br><span class="line">        semSignal(x); <span class="comment">// 信号灯x用于保证对readcount的更新操作的正确执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(wsem);</span><br><span class="line">        WRITEUNIT();</span><br><span class="line">        semSignal(wsem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    readcount = <span class="number">0</span>;</span><br><span class="line">    parbegin( reader, writer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方案的最大问题是如果读者过多的话会造成写者的饥饿问题。</p>
<p>采用写者优先方案可以解决这个问题</p>
<h5 id="2、写者优先"><a href="#2、写者优先" class="headerlink" title="2、写者优先"></a>2、写者优先</h5><ul>
<li>只要写者申请访问数据区时，阻止所有读者对共享数据的访问；</li>
<li>全局变量writecount，用于控制对rsem的设置</li>
<li>信号灯y，用于控制对writecount的更新</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> readcount, writecount, semphore x = <span class="number">1</span>, y = <span class="number">1</span>, z = <span class="number">1</span>, wsem = <span class="number">1</span>, rsem = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(z);</span><br><span class="line">        	semWait(rsem); <span class="comment">// 写者对rsem进行了设置，一个读者在rsem上等待，其他读者全在z上等待</span></span><br><span class="line">        		semWait(x);</span><br><span class="line">        			readcount++;</span><br><span class="line">        			<span class="keyword">if</span>(readcount == <span class="number">1</span>) <span class="comment">//新的方案只允许一个读者在rsem上等待，后续到达的读者必须在z上等待</span></span><br><span class="line">                 		semWait(wsem); </span><br><span class="line">        		semSignal(x);</span><br><span class="line">        	semSignal(rsem);</span><br><span class="line">        semSignal(z);</span><br><span class="line">        READUNIT();</span><br><span class="line">        semWait(x);</span><br><span class="line">        	readcount--;</span><br><span class="line">        	<span class="keyword">if</span>(readcount == <span class="number">0</span>) semSignal(wsem);</span><br><span class="line">        semSignal(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(y);</span><br><span class="line">        	writecount++;</span><br><span class="line">        	<span class="keyword">if</span>(writecount == <span class="number">1</span>) </span><br><span class="line">                semWait(rsem);</span><br><span class="line">        semSignal(y);</span><br><span class="line">        semWait(wsem); <span class="comment">// 写者全在wsem上排队</span></span><br><span class="line">        WRITEUNIT();</span><br><span class="line">        semSignal(wsem);</span><br><span class="line">        semWait(y);</span><br><span class="line">        	writecount--;</span><br><span class="line">        	<span class="keyword">if</span>(writecount == <span class="number">0</span>)		semSignal (rsem); <span class="comment">//</span></span><br><span class="line">        semSignal(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    readcount = writecount = <span class="number">0</span>;</span><br><span class="line">    parbegin( reader, writer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所示方案中进程队列情况</p>
<table>
<thead>
<tr>
<th align="center">读写者情况</th>
<th align="center">信号灯设置以及排队情况</th>
</tr>
</thead>
<tbody><tr>
<td align="center">系统中只有读者</td>
<td align="center">1、wsem设置  2、无排队</td>
</tr>
<tr>
<td align="center">系统中只有写者</td>
<td align="center">1、wsem和rsem设置  2、写者在wsem上排队</td>
</tr>
<tr>
<td align="center">有读者和写者，读者在前</td>
<td align="center">1、wsem被读者设置  2、rsem被写者设置  3、所有写者在wsem上排队</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">4、一个读者在resm上排队  5、其他读者在z上排队</td>
</tr>
<tr>
<td align="center">有读者和写者，写者在前</td>
<td align="center">1、wsem被写者设置  2、rsem被写者设置  3、写者在wsem上排队</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">4、一个读者在rsem上排队  5、其他读者在z上排队</td>
</tr>
</tbody></table>
<h5 id="3、采用消息通信来解决读者-写者问题-写者优先"><a href="#3、采用消息通信来解决读者-写者问题-写者优先" class="headerlink" title="3、采用消息通信来解决读者/写者问题(写者优先)"></a>3、采用消息通信来解决读者/写者问题(写者优先)</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    message rmsg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        send(readrequest, rmsg);</span><br><span class="line">        receive(mbox[i], rmsg);</span><br><span class="line">        READUNIT();</span><br><span class="line">        send(finished, rmsg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">(<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    message rmsg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        send(writerequest, rmsg);</span><br><span class="line">        receive(mbox[j], rmsg);</span><br><span class="line">        WRITEUNIT();</span><br><span class="line">        rmsg = j;</span><br><span class="line">        send(finished, rmsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">controller</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">0</span>) <span class="comment">// count&gt;0，说明没有写者在等待，且有读者在临界区。此时先处理finish消息，然后是写请求，最后是读者请求</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!empty(finshed))</span><br><span class="line">            &#123;</span><br><span class="line">                recevie(finished, msg);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!empty(writerequest))</span><br><span class="line">            &#123;</span><br><span class="line">                receive(writerequest, msg);</span><br><span class="line">                write_id = msg.id;</span><br><span class="line">                count = count - <span class="number">100</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!empty(readrequest))</span><br><span class="line">            &#123;</span><br><span class="line">                receive(readrequest, msg);</span><br><span class="line">                count--;</span><br><span class="line">                send(msg.id, <span class="string">&quot;OK&quot;</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) <span class="comment">//count=0，说明收到了写者的请求，允许写者进入临界区，并且等待“finish”消息</span></span><br><span class="line">        &#123;</span><br><span class="line">            send (write_id, <span class="string">&quot;OK&quot;</span>);</span><br><span class="line">            receive(finished, msg);</span><br><span class="line">            count = <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; <span class="number">0</span>) <span class="comment">//count&lt;0，说明收到了写者的请求，但此时有读者正在临界区中。此时，就只处理“finish”消息</span></span><br><span class="line">        &#123;</span><br><span class="line">            receive(finshed, msg);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; <strong>fine~~</strong></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统复习</title>
    <url>/myblog/2020/11/04/C/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%BB%E8%A6%81%E8%80%83%E5%AF%9F%E7%82%B9/</url>
    <content><![CDATA[<h3 id="操作系统主要考察点-期中"><a href="#操作系统主要考察点-期中" class="headerlink" title="操作系统主要考察点(期中)"></a>操作系统主要考察点(期中)</h3><hr>
<h4 id="1、操作系统主要功能及主要特征"><a href="#1、操作系统主要功能及主要特征" class="headerlink" title="1、操作系统主要功能及主要特征"></a>1、操作系统主要功能及主要特征</h4><p>操作系统是<strong>控制应用程序的执行程序</strong>，同时也是<strong>应用程序和系统硬件之间的接口</strong>。OS 的设计应该努力满足以下3个目标:</p>
<ul>
<li>便利性：使计算机便于使用</li>
<li>有效性：以更有效的方式使用系统资源</li>
<li>扩展能力：在不影响正常服务的前提下进行有效的开发、测试，并引入新的系统功能</li>
</ul>
<h5 id="作为用户与系统交互接口的操作系统"><a href="#作为用户与系统交互接口的操作系统" class="headerlink" title="作为用户与系统交互接口的操作系统"></a>作为用户与系统交互接口的操作系统</h5><p>一般来说 OS 通常从以下几个方面提供服务：</p>
<ul>
<li>程序开发</li>
<li>程序运行</li>
<li>I/O 设备的访问</li>
<li>系统的访问</li>
<li>错误检测和响应</li>
<li>日志</li>
</ul>
<p>典型的计算机系统中有以下3种主要接口：</p>
<ul>
<li>指令集架构 ISA：定义了计算机的机器语言指令系统，是<strong>计算机硬件和软件的分割线</strong>。我们通常使用的是其子集（用户级ISA），OS 能使用其他的一些机器语言指令（系统级ISA）。</li>
<li>应用程序二进制接口 ABI：定义了在程序间进行二进制移植的标准，定义了 OS 的系统调用接口，以及在系统中通过用户级 ISA 能够使用的硬件资源和服务。</li>
<li>应用程序编程接口 API ：API 允许应用程序访问系统的硬件资源和服务，这些服务由用户级 ISA 和高级语言库（HHL）来提供。</li>
</ul>
<h5 id="作为资源管理器的操作系统"><a href="#作为资源管理器的操作系统" class="headerlink" title="作为资源管理器的操作系统"></a>作为资源管理器的操作系统</h5><p>不能简单的说操作系统在控制数据的移动、储存和处理</p>
<p>OS 作为控制机制和其他的控制机制有以下的区别：</p>
<ul>
<li>操作系统和其他的普通软件一样，也是处理器执行的一组程序</li>
<li>操作系统经常转交控制权（给其他程序），然后需要借助处理器恢复得到控制权</li>
</ul>
<p>OS 的内核程序：包含操作系统中最经常使用的功能</p>
<h5 id="操作系统的易扩展性"><a href="#操作系统的易扩展性" class="headerlink" title="操作系统的易扩展性"></a>操作系统的易扩展性</h5><p>操作系统的发展由以下几个方面推动：</p>
<ul>
<li>硬件升级和新型硬件的出现</li>
<li>新设备的出现</li>
<li>错误修复</li>
</ul>
<h4 id="2、并行与并发的概念与区别"><a href="#2、并行与并发的概念与区别" class="headerlink" title="2、并行与并发的概念与区别"></a>2、并行与并发的概念与区别</h4><p>如果某个系统支持两个或者多个动作（Action）<strong>同时存在</strong>，那么这个系统就是一个<strong>并发系统</strong>。如果某个系统支持两个或者多个动作<strong>同时执行</strong>，那么这个系统就是一个<strong>并行系统</strong>。并发系统与并行系统这两个定义之间的关键差异在于<strong>“存在”</strong>这个词。</p>
<p>在并发程序中可以同时拥有两个或者多个线程。这意味着，如果程序在单核处理器上运行，那么这两个线程将交替地换入或者换出内存。这些线程是同时“存在”的——每个线程都处于执行过程中的某个状态。如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。</p>
<p><strong>“并行”概念是“并发”概念的一个子集</strong>。也就是说，你可以编写一个拥有多个线程或者进程的并发程序，但如果没有多核处理器来执行这个程序，那么就不能以并行方式来运行代码。因此，凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为，都属于并发编程的范畴。</p>
<h4 id="3、进程的概念及组成，进程的三程状态及转移"><a href="#3、进程的概念及组成，进程的三程状态及转移" class="headerlink" title="3、进程的概念及组成，进程的三程状态及转移"></a>3、进程的概念及组成，进程的三程状态及转移</h4><p>现代操作系统的设计。为了能满足系统中多个应用程序的执行的需要，且达到以下的设计目标：</p>
<ul>
<li>资源能被多个应用程序使用</li>
<li>处理器需要在多个多个应用程序的执行过程中切换，以使这些应用程序的执行看上去好像在同时进行</li>
<li>尽可能的提高处理器和I/O 设备的利用率</li>
</ul>
<p>为了能达到这些设计目标，所有的现代操作系统都将应用程序抽象为一个或者多个进程</p>
<p>对于进程可以有以下几个不同的定义：</p>
<ul>
<li>一个正在执行的程序</li>
<li>一个执行在计算机上的应用程序实例</li>
<li>一个能够调度到处理器上执行的实体</li>
<li>一个活动单元，包括一串指令的执行、当前状态，以及一组正在使用的资源</li>
</ul>
<p>我们还可以把进程当作一个包含多个元素的独立个体，其中最基本的两个元素—&gt; <strong>程序代码</strong>（可以在同一应用中创建的多个进程间共享） 和 与<strong>程序代码相关的一组数据</strong> </p>
<p>在其执行过程中的任意一个节点上，所对应的进程拥有唯一标识其存在的元素，包括：</p>
<ul>
<li>标识符</li>
<li>进程状态</li>
<li>优先级</li>
<li>进程计数器</li>
<li>内存指针</li>
<li>上下文</li>
<li>I/O 状态</li>
<li>记账信息</li>
</ul>
<p>这些信息被放在一个叫做 <strong>进程控制块</strong> 的数据结构中，往往由 OS 创建</p>
<p>进程的三状态： 1、就绪态     2、运行态     3、阻塞态</p>
<ul>
<li>运行态：进程正在运行</li>
<li>就绪态：进程已经准备好执行，如果分配了处理器，它可以立即投入执行</li>
<li>阻塞态：进程在等待某事件的发生</li>
</ul>
<p><strong>就绪态 —-&gt; 运行态</strong>：处理器空闲的时候，处理器从就绪的进程中挑选一个进程将其投入运行，其状态也变为运行态</p>
<p><strong>运行态 —-&gt; 就绪态</strong>：1、用完时间片 2、优先级调度（抢占和自愿）</p>
<p><strong>运行态 —-&gt; 阻塞态</strong>：进程在执行过程中，因为请求一些暂时得不到而必须等待的服务时，从运行态转移到阻塞态（i.e. 1、进程调用一个操作系统提供的的服务：读写文件，访问共享内存……这些服务OS有可能不能及时提供。2、或者进程在执行过程中发出了I/O请求。 3、由于进程间通信的原因，一个进程的执行过程必须等待另一个进程的信息。）</p>
<p><strong>阻塞态 —-&gt; 就绪态</strong>：当进程所等待的事件到达后，它的状态将从阻塞态转移到就绪态</p>
<h4 id="4、进程通信方式"><a href="#4、进程通信方式" class="headerlink" title="4、进程通信方式"></a>4、进程通信方式</h4><p>进程的交互协作需要两个基本元素：同步和通信</p>
<p>同步用于进程的互斥，通信则用于进程间的协作。消息通信就能提供这两个基本元素。</p>
<h4 id="5、进程间的制约关系"><a href="#5、进程间的制约关系" class="headerlink" title="5、进程间的制约关系"></a>5、进程间的制约关系</h4><p>进程间的制约关系可以分为以下两种：</p>
<ul>
<li>资源共享：间接制约关系</li>
<li>进程合作：直接制约关系</li>
</ul>
<h4 id="6、进程与线程之间的区别"><a href="#6、进程与线程之间的区别" class="headerlink" title="6、进程与线程之间的区别"></a>6、进程与线程之间的区别</h4><p>之前对进程概念的讨论体现了以下两个概念：<strong>资源占用</strong>，<strong>调度/执行</strong></p>
<p>这两个概念在进程的概念中得到了统一，但是在现代的操作系统设计上，这两个概念是相互独立的。为了区分这两个概念，把进程调度的实体称为：<strong>线程或者轻量级进程（Lightweight Process）</strong>，而在考虑资源的权属上把拥有资源的个体称为<strong>进程</strong>或者<strong>任务(Task)</strong></p>
<p>在多线程系统中，进程是参与资源分配，以及权限保护的基本单位，它包括：</p>
<ul>
<li>容纳进程镜像的虚拟地址空间</li>
<li>处理器的受保护访问，其他进程信息（用于通信），一组文件和I/O资源(设备和通道)</li>
</ul>
<p>进程可以包含一个或者多个线程，每个线程包括：</p>
<ul>
<li>线程的状态（运行态、就绪态等）</li>
<li>线程上下文（未执行时），以及线程在进程中的执行的位置</li>
<li>私有的执行栈</li>
<li>静态存储空间和局部变量</li>
<li>对系统资源的访问权限</li>
</ul>
<p>进程的线程共享它们父进程的状态，以及它们拥有的系统资源，并且它们共处于同一地址空间，访问同一组数据。</p>
<p>线程概念的产生实际上是对计算机系统性能进行优化的结果</p>
<h4 id="7、进程调度的原因，操作系统的三级调度"><a href="#7、进程调度的原因，操作系统的三级调度" class="headerlink" title="7、进程调度的原因，操作系统的三级调度"></a>7、进程调度的原因，操作系统的三级调度</h4><p>在多道程序系统中，内存中同时存在多个进程。每个进程要么在使用处理器，要么在等待某个事件发生（如I/O操作的完成）发生。如果在处理器或者处理器组执行一个进程的时候，还有其他进在等待执行，那么处理器就可以保持在忙碌状态。</p>
<p>处理器调度的目的：以符合系统目标的方式将进程分配到处理器或者处理器组上执行，这些系统目标包括，响应时间、吞吐率，以及处理器的利用率等等。</p>
<p>调度活动被分解为3个相互独立的功能：长期调度，中期调度，短期调度</p>
<table>
<thead>
<tr>
<th align="center">调度类型</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">长期调度</td>
<td align="center">决定是否将一个新进程加入将待执行的进程池中</td>
</tr>
<tr>
<td align="center">中期调度</td>
<td align="center">决定哪个就绪进程部分或者全部载入内存</td>
</tr>
<tr>
<td align="center">短期调度</td>
<td align="center">决定哪个就绪进程将被处理器执行</td>
</tr>
</tbody></table>
<h4 id="8、进程调度算法（FCFS，SPF，RR），周转时间的概念"><a href="#8、进程调度算法（FCFS，SPF，RR），周转时间的概念" class="headerlink" title="8、进程调度算法（FCFS，SPF，RR），周转时间的概念"></a>8、进程调度算法（FCFS，SPF，RR），周转时间的概念</h4><p>各种调度策略的特征</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">FCFS</th>
<th align="center">RR</th>
<th align="center">SPN</th>
</tr>
</thead>
<tbody><tr>
<td align="center">选择函数</td>
<td align="center">max[w]</td>
<td align="center">常量</td>
<td align="center">min[s]</td>
</tr>
<tr>
<td align="center">策略模式</td>
<td align="center">非抢占</td>
<td align="center">抢占（用完时间片）</td>
<td align="center">非抢占</td>
</tr>
<tr>
<td align="center">吞吐量</td>
<td align="center">不强调</td>
<td align="center">如果时间片太小，吞吐量会降低</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">响应时间</td>
<td align="center">可能很高，特别是进程时间差别很大的时候</td>
<td align="center">为短进程提供良好的相应时间</td>
<td align="center">为短进程提供良好的相应时间</td>
</tr>
<tr>
<td align="center">开销</td>
<td align="center">最小</td>
<td align="center">最小</td>
<td align="center">可能高</td>
</tr>
<tr>
<td align="center">对进程的影响</td>
<td align="center">对短进程和I/O型进程不利</td>
<td align="center">公平对待</td>
<td align="center">对长进程不利</td>
</tr>
<tr>
<td align="center">饥饿现象</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">可能</td>
</tr>
</tbody></table>
<p>与非抢占式策略相比，抢占式策略会导致更大的开销，但是可以从整体上为进程提供更好的服务。此外，采用高效的进程切换机制（可能有求于硬件），提供大容量的内存以便将更多的进程放入内存中……通过这些方法可以有效降低抢占式的开销。</p>
<p>根据排队模型，周转时间(Turnaround Time, TAT)等于驻留时间Tr，或者这一进程在系统中花费的总时间(等待时间 + 服务时间)。另一个更有用的数据称为带权周转时间(Normalized Turnaround Time)，它是周转时间与服务时间的比值。这个值反映了进程的相对延迟。通常来说，进程的执行时间越长，可以容忍的延迟时间也越长。带权周转时间的最小值为1，该值增加，则意味着服务水平的增加。</p>
<h4 id="9、死锁概念，原因，必要条件，预防及避免算法"><a href="#9、死锁概念，原因，必要条件，预防及避免算法" class="headerlink" title="9、死锁概念，原因，必要条件，预防及避免算法"></a>9、死锁概念，原因，必要条件，预防及避免算法</h4><p>死锁是指<strong>一组进程因为竞争系统资源或相互等待消息</strong>，而无法向前推进的状态。</p>
<p>死锁一般都涉及两个或更多进程之间的相互冲突的资源请求。死锁的发生不仅取决于进程的动态执行路径，还取决于应用实现的具体细节。</p>
<p>死锁发生的条件：</p>
<p>(1) 互斥：资源只能由一个进程占用，如果资源被分配给了一个进程，则其他进程不可使用该进程</p>
<p>(2) 占用并等待：进程必须占用分配给它的资源，且同时申请和等待其他资源</p>
<p>(3) 不可剥夺：如果资源被某些进程占用，那么则不可能将其从进程中强行剥夺出来</p>
<p>注意： 以上3个条件只是 必要条件 并非充分条件死锁的发生还需要第4个条件：</p>
<p>(4) 环路等待：资源和进程的分配关系在资源分配图上表现为一个封闭的环路，其中，每个进程至少占用一个资源，且该资源同时被环路中的其他进程所申请</p>
<p>导致死锁的条件</p>
<table>
<thead>
<tr>
<th align="center">可能导致死锁</th>
<th align="center">死锁发生</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1、互斥</td>
<td align="center">1、互斥</td>
</tr>
<tr>
<td align="center">2、不可抢占</td>
<td align="center">2、不可抢占</td>
</tr>
<tr>
<td align="center">3、占用并等待</td>
<td align="center">3、占用并等待</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">4、环路等待</td>
</tr>
</tbody></table>
<p>解决死锁问题有3个方案：</p>
<p>一、死锁预防：方案是破除死锁发生的4个条件之一</p>
<p>二、死锁避免：方案是基于资源分配的当前状况，动态的做出资源分配决策</p>
<p>三、死锁检测：方案检测系统中已经发生的死锁，并想办法打破进程间的死锁状态</p>
<h5 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h5><p>简单的说，死锁的预防方案思想是设计一个系统，该系统能够<strong>去除死锁发生的可能</strong>。可以将死锁预防的方案可以归纳为2种：一种是<strong>直接方案</strong>，还有一种是<strong>间接方案</strong>。间接方案是破除死锁发生条件的前3条中的任意一条，而直接方案是预防环路等待条件的发生。</p>
<p>1、互斥条件：</p>
<p>一般来说，互斥条件与具体的资源属性有关，是很难破除的。如果对某些资源的访问需要互斥，则<strong>操作系统必须提供某种互斥机制</strong>。如文件的读写限制。但是当有多个进程在对该文件并发的写的时候</p>
<p>2、占有并等待条件：</p>
<p>可以采用以下的方法来破除：</p>
<p>要求进程在执行前，一次性申请完它在执行过程种所有可能用到的资源。如果系统暂时无法满足它的资源申请要求，则进程必须等待直到系统拥有足够多的资源，并将资源一次性全部分配给它才能开始运行。</p>
<p>注意：该方案可能导致系统的效率降低：</p>
<ul>
<li>进程可能在获得它运行所需的全部资源前需要等待很长时间。然而实际上，如果给它一部分资源，它便可以开始运行了</li>
<li>分配给进程的资源可能长时间得不到使用，但别的进程也无法利用这些资源，然而，这些资源可能在它实际的执行路径中根被没有被使用</li>
</ul>
<p>3、不可抢占条件：</p>
<p>破除该条件的方法有：</p>
<ul>
<li>如果进程占用了一些资源，且在后续资源请求下得不到满足的情况下，它就必须释放它已经占用的资源，并在后续的执行中一次性申请全部的资源(包括之前释放的和申请不到的资源)</li>
<li>如果一个(高优先级)进程申请已经被一个(低优先级)进程把资源占用了。那么OS将从后者抢占资源将其分配给前者，该方法仅仅适用于任意两个进程都拥有不同优先级的情况，而且只能用在资源状态很容易保存和恢复的情况。(i.e. 处理器中的资源)</li>
</ul>
<p>4、环路等待条件：</p>
<p>可以用有序资源分配的方法破除环路等待条件：先将资源进行线性编序，如果进程获得资源R，那么后续请求的资源序号都只能大于或者都小于R。</p>
<p>然而破除环路等待条件还是可能会导致系统效率的降低，或者进程的执行速度降低，亦或不必要的资源分配请求拒绝等问题。</p>
<h5 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h5><p>死锁预防的方法实际上是在满足资源请求的方式上做出某种限制，使其破除死锁发生的某一个条件，从而使得死锁不可能发生。破除死锁条件的方法上面已经讨论过了，正如讨论的那样，这些方法都会导致资源利用率的下降，或者进程执行速度的降低。死锁避免的方法与之有细微的差别，该方案允许死锁发生的前三个必要条件的存在，但是在资源分配的时候做出谨慎的决策，以避免死锁的发生。</p>
<p>在死锁避免方案中，资源分配决策的制订，是基于(假如将资源分配出去)在未来是否会发生死锁来判断的。所以，死锁避免方案需要知道进程未来的资源请求。这种方案有很多种解法，这里主要介绍两种：</p>
<ul>
<li>(如果会导致死锁)拒绝创建进程</li>
</ul>
<p>$$<br>考虑一个有n个处理器，m种不同类型资源的系统：R = (R_1, R_2,……, R_m)系统种的全部资源<br>$$</p>
<p>资源申请矩阵：(这个模板不支持矩阵，很烦，请自行想象)<br>$$<br>\begin{bmatrix}<br>C_{11} &amp; C_{12} &amp; \ldots &amp; C_{1n} \<br>C_{21} &amp; C_{22} &amp; \ldots &amp; C_{2n} \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>C_{n1} &amp; C_{n2} &amp; \ldots &amp; C_{nn} \<br>\end{bmatrix}<br>$$</p>
<p>$$<br>C_{ij} = 进程i申请资源j的总数量,死锁避免方案可以要求在创建一个新进程的P(n + 1)时有：<br>$$</p>
<p>$$<br>R \geq C_{(n+1)j} + \sum_{i=1}^{n}C_{ij}<br>$$</p>
<p>也就是说，仅当所创建的进程对各类资源的最大资源需求量加上系统中已有进程对各类资源的申请量的总和，小于系统中各类资源的总量时，该进程才被允许创建。</p>
<p>很显然，这个策略并不是最有效的，因为它假设的是最坏情况：所有进程同时申请最大数量的资源。</p>
<ul>
<li>(如果会导致死锁)拒绝分配资源 —-&gt; 又称为银行家算法</li>
</ul>
<h4 id="10、信号量机制，PV操作基本概念"><a href="#10、信号量机制，PV操作基本概念" class="headerlink" title="10、信号量机制，PV操作基本概念"></a>10、信号量机制，PV操作基本概念</h4><p>（想要详细了解进程的同步，通信，信号量等机制详见我的另一篇博客 并发：互斥与同步的各种实现 ）</p>
<p>当然，这些东西仅供参考，60分左右没有问题吧。。。<strong>想要考好还是得去背书</strong>(建议还是去看课本)</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Get Started with Win32 and C++</title>
    <url>/myblog/2021/04/24/C/Get%20Started%20with%20Win32%20and%20C++/</url>
    <content><![CDATA[<h2 id="Get-Started-with-Win32-and-C"><a href="#Get-Started-with-Win32-and-C" class="headerlink" title="Get Started with Win32 and C++"></a>Get Started with Win32 and C++</h2><p>原文的链接：<a href="https://docs.microsoft.com/en-us/windows/win32/learnwin32/learn-to-program-for-windows">https://docs.microsoft.com/en-us/windows/win32/learnwin32/learn-to-program-for-windows</a></p>
<h3 id="1-OverView"><a href="#1-OverView" class="headerlink" title="1. OverView"></a>1. OverView</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">wWinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Register the window class.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">wchar_t</span> CLASS_NAME[]  = <span class="string">L&quot;Sample Window Class&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    WNDCLASS wc = &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    wc.lpfnWndProc   = WindowProc;</span><br><span class="line">    wc.hInstance     = hInstance;</span><br><span class="line">    wc.lpszClassName = CLASS_NAME;</span><br><span class="line"></span><br><span class="line">    RegisterClass(&amp;wc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the window.</span></span><br><span class="line"></span><br><span class="line">    HWND hwnd = CreateWindowEx(</span><br><span class="line">        <span class="number">0</span>,                              <span class="comment">// Optional window styles.</span></span><br><span class="line">        CLASS_NAME,                     <span class="comment">// Window class</span></span><br><span class="line">        <span class="string">L&quot;Learn to Program Windows&quot;</span>,    <span class="comment">// Window text</span></span><br><span class="line">        WS_OVERLAPPEDWINDOW,            <span class="comment">// Window style</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Size and position</span></span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line"></span><br><span class="line">        <span class="literal">NULL</span>,       <span class="comment">// Parent window    </span></span><br><span class="line">        <span class="literal">NULL</span>,       <span class="comment">// Menu</span></span><br><span class="line">        hInstance,  <span class="comment">// Instance handle</span></span><br><span class="line">        <span class="literal">NULL</span>        <span class="comment">// Additional application data</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hwnd == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ShowWindow(hwnd, nCmdShow);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run the message loop.</span></span><br><span class="line"></span><br><span class="line">    MSG msg = &#123; &#125;;</span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        TranslateMessage(&amp;msg);</span><br><span class="line">        DispatchMessage(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        &#123;</span><br><span class="line">            PAINTSTRUCT ps;</span><br><span class="line">            HDC hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            FillRect(hdc, &amp;ps.rcPaint, (HBRUSH) (COLOR_WINDOW+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            EndPaint(hwnd, &amp;ps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是一个最简单的 Win32 窗口应用程序</p>
<p><code>WindowProc</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br></pre></td></tr></table></figure>

<p>程序并没有明显的调用 WindowProc 函数，但是这个函数是整个应用程序的逻辑处理区域 Windows 通过传递一系列的 message 来进行通信。</p>
<p>每当程序调用一次 <code>DispatchMessage</code> 分发一个消息的时候，程序会直接的调用一次 WindowProc函数。</p>
<p><code> wWinMain</code> 是整个程序的入口点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">wWinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注册一系列的信息，其中最重要的是 WindowProc 的函数地址</span></span><br><span class="line">    WNDCLASS wc = &#123; &#125;;</span><br><span class="line">    ...</span><br><span class="line">    wc.lpfnWndProc   = WindowProc;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 然后是创建窗口设置相关属性并且返回一个唯一指向该窗口的句柄</span></span><br><span class="line">    HWND hwnd = CreateWindowEx(</span><br><span class="line">        ...</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果窗口创建成功，那么便要进入消息循环队列，直到用户退出该窗口并关闭该程序之前，程序一直运行在这个消息队列中</span></span><br><span class="line">    MSG msg = &#123; &#125;;</span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        TranslateMessage(&amp;msg);</span><br><span class="line">        DispatchMessage(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-Creating-A-Window"><a href="#2-Creating-A-Window" class="headerlink" title="2. Creating A Window"></a>2. Creating A Window</h3><p>每一个 Window 都需要绑定一个 Window class 类，但是这个 ‘class’ 和常规的 C++ class 含义并不完全相同，它更像是一个用于操作系统在运行时调用用于创建窗口的数据结构，注册一个 Window class 要填充一个 WNDCLASS 数据结构</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Register the window class.</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">wchar_t</span> CLASS_NAME[]  = <span class="string">L&quot;Sample Window Class&quot;</span>;</span><br><span class="line"></span><br><span class="line">WNDCLASS wc = &#123; &#125;;</span><br><span class="line"></span><br><span class="line">wc.lpfnWndProc   = WindowProc;</span><br><span class="line">wc.hInstance     = hInstance;</span><br><span class="line">wc.lpszClassName = CLASS_NAME;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>当然还有很多其他的属性可以设置，在完成设置后将 WNDCLASS 的地址传递给操作系统来完成对Window的注册</p>
<p><code> RegisterClass(&amp;wc);</code></p>
<p>在完成对 WNDCLASS 的注册之后使用 <code> CreateWindowEx</code> 来创建一个窗口的实例，函数返回一个句柄表示创建成功，返回 0 表示失败</p>
<p>之后再调用 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ShowWindow(hwnd, nCmdShow); <span class="comment">// hwnd: 窗口句柄 nCmdShow: mininize or maxmize a window </span></span><br></pre></td></tr></table></figure>

<p>便可以创建窗口了。 </p>
<h3 id="3-Window-Messages"><a href="#3-Window-Messages" class="headerlink" title="3. Window Messages"></a>3. Window Messages</h3><p>windows 使用的是消息传递模型来完成用户和操作系统的通信。操作系统通过调用 window procedure registered for that window 来传递消息。</p>
<p> windows 通过一个消息队列来管理所有的消息。我们不能直接操作这个队列而是使用下面的函数将消息从队列中提取出来</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MSG msg;</span><br><span class="line">GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>要完成对消息的处理接下来便要调用下面的两个函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TranslateMessage(&amp;msg); <span class="comment">// 将消息处理为程序能处理的格式</span></span><br><span class="line">DispatchMessage(&amp;msg); 	<span class="comment">// 告诉操作系统去调用和该消息联系的windows procedure（函数调用过程在这之中发生）</span></span><br></pre></td></tr></table></figure>

<p>如果想要关闭窗口退出消息队列，调用下面的函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PostQuitMessage(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 该函数将一个 WM_QUIT 消息放在消息队列中</span></span><br></pre></td></tr></table></figure>

<p>WM_QUIT 将导致 <code> GetMessage</code> 返回一个 0，然后退出消息循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完整流程</span></span><br><span class="line">MSG msg = &#123; &#125;;</span><br><span class="line"><span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    TranslateMessage(&amp;msg);</span><br><span class="line">    DispatchMessage(&amp;msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-Writing-the-Windows-Procedure"><a href="#4-Writing-the-Windows-Procedure" class="headerlink" title="4.  Writing the Windows Procedure"></a>4.  Writing the Windows Procedure</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>CALLBACK </code> : 一个调用约定</p>
<p><code> uMsg</code> : 传递的消息</p>
<p><code> wParam, lParam</code> : 属于消息的额外数据，其准确含义取决于 uMsg</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_SIZE:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> width = LOWORD(lParam);  <span class="comment">// Macro to get the low-order word.</span></span><br><span class="line">            <span class="keyword">int</span> height = HIWORD(lParam); <span class="comment">// Macro to get the high-order word.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Respond to the message:</span></span><br><span class="line">            OnSize(hwnd, (UINT)wParam, width, height);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnSize</span><span class="params">(HWND hwnd, UINT flag, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Handle resizing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有特别的消息需要处理可以简单的使用默认的 WindowProc</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> DefWindowProc(hwnd, uMsg, wParam, lParam);</span><br></pre></td></tr></table></figure>

<p>由于消息队列的特性，在处理当前消息的时候不能处理其他的消息，一定要注意线程安全。</p>
<p>通常来说有以下几种方法避免这个问题：</p>
<ul>
<li>创建一个新线程</li>
<li>使用线程池</li>
<li>使用异步</li>
</ul>
<h3 id="5-Painting-the-Window"><a href="#5-Painting-the-Window" class="headerlink" title="5. Painting the Window"></a>5. Painting the Window</h3><h3 id="6-Closing-the-Window"><a href="#6-Closing-the-Window" class="headerlink" title="6. Closing the Window"></a>6. Closing the Window</h3><p>在做出一些列的关闭窗口的行为后 Windows 会发送一个关闭窗口的消息 <code> WM_CLOSE</code> ， WM_CLOSE 并不会直接关闭你的窗口，调用 <code> DestoryWindow</code> 才会关闭你的窗口。下面是一个调用的实例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">    <span class="keyword">if</span> (MessageBox(hwnd, <span class="string">L&quot;Really quit?&quot;</span>, <span class="string">L&quot;My application&quot;</span>, MB_OKCANCEL) == IDOK)</span><br><span class="line">    &#123;</span><br><span class="line">        DestroyWindow(hwnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Else: User canceled. Do nothing.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>当你的窗口将要被关闭的时候窗口会收到 <code> WM_DESTORY</code> 消息，然后进行下面的调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">    PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>整个的调用流程如下图所示:</p>
<p><img src="C:\Users\28594\OneDrive\博客用图\WM_DESTORY.PNG" alt="https://1drv.ms/u/s!Ak-edkVXxLEUlCTS1JDm1G1w04Q6?e=Z2E69e"></p>
<h3 id="7-Managing-Application-State"><a href="#7-Managing-Application-State" class="headerlink" title="7. Managing Application State"></a>7. Managing Application State</h3><p>由于窗口的过程函数仅仅每条消息调用的函数，本质上是无状态的。因此我们需要一个能够跟踪应用程序状态的方法</p>
<p><code> CreateWindowEx</code> 提供了一个将任何数据结构传递给窗口的方法。当调用 <code> CreateWindowEx</code> 的时候它将会发送下面的两个消息到窗口 procdure </p>
<p><code> WM_NCCREATE,WM_CREATE</code> : 它们在窗口可以看见之前就已经发送，因此这两个消息可以用来初始化窗口。</p>
<p>CreateWindowEx 的最后一个参数是 <code>void*</code>  ，当窗口过程处理 WM_NCCREATE, WM_CREATE 的时候，可以通过它获取额外的数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Define a structure to hold some state information.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StateInfo</span> &#123;</span></span><br><span class="line">    <span class="comment">// ... (struct members not shown)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">StateInfo *pState = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) StateInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pState == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the structure members (not shown).</span></span><br><span class="line"></span><br><span class="line">HWND hwnd = CreateWindowEx(</span><br><span class="line">    <span class="number">0</span>,                              <span class="comment">// Optional window styles.</span></span><br><span class="line">    CLASS_NAME,                     <span class="comment">// Window class</span></span><br><span class="line">    <span class="string">L&quot;Learn to Program Windows&quot;</span>,    <span class="comment">// Window text</span></span><br><span class="line">    WS_OVERLAPPEDWINDOW,            <span class="comment">// Window style</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Size and position</span></span><br><span class="line">    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line"></span><br><span class="line">    <span class="literal">NULL</span>,       <span class="comment">// Parent window    </span></span><br><span class="line">    <span class="literal">NULL</span>,       <span class="comment">// Menu</span></span><br><span class="line">    hInstance,  <span class="comment">// Instance handle</span></span><br><span class="line">    pState      <span class="comment">// Additional application data</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>当收到 WM_NCCREATE 和 WM_CREATE 消息的时候，每个消息的 lParam 参数是一个指向 CREATESTRUCT 的指针，这个 CREATESTRUCT 数据结构同时包含了传递给 CreateWindowEx 的指针</p>
<p><img src="C:\Users\28594\OneDrive\博客用图\CreateStruct.PNG" alt="https://1drv.ms/u/s!Ak-edkVXxLEUlCTS1JDm1G1w04Q6?e=Z2E69e"></p>
<p>下面是从自己的数据结构中获取指针的过程:</p>
<ol>
<li><p>通过转换 lParam 参数获取 CREATESTRUCT</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CREATESTRUCT *pCreate = <span class="keyword">reinterpret_cast</span>&lt;CREATESTRUCT*&gt;(lParam);</span><br></pre></td></tr></table></figure>
</li>
<li><p>应为 lpCreateParams 是 自定义的数据结构的指针，转换 lpCreateParams 获得需要的指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pState = <span class="keyword">reinterpret_cast</span>&lt;StateInfo*&gt;(pCreate-&gt;lpCreateParams);</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 SetWindowLongPtr 函数并且传入 自定义的数据结构的指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pState);</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后是将 Stateinfo 的指针存在窗口是实例数据中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LONG_PTR ptr = GetWindowLongPtr(hwnd, GWLP_USERDATA);</span><br><span class="line">StateInfo *pState = <span class="keyword">reinterpret_cast</span>&lt;StateInfo*&gt;(ptr);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>该过程最大的意义是创建多个窗口，并为每个窗口提供其自己的数据结构实例。如果您定义一类窗口并创建该类的多个窗口，例如，如果您创建一个自定义控件类，则此方法特别有用。将 GetWindowLongPtr 调用包装在一个小的辅助函数中非常方便。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> StateInfo* <span class="title">GetAppState</span><span class="params">(HWND hwnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LONG_PTR ptr = GetWindowLongPtr(hwnd, GWLP_USERDATA);</span><br><span class="line">    StateInfo *pState = <span class="keyword">reinterpret_cast</span>&lt;StateInfo*&gt;(ptr);</span><br><span class="line">    <span class="keyword">return</span> pState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>现在我们可以创建自定义的窗口过程了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StateInfo *pState;</span><br><span class="line">    <span class="keyword">if</span> (uMsg == WM_CREATE)</span><br><span class="line">    &#123;</span><br><span class="line">        CREATESTRUCT *pCreate = <span class="keyword">reinterpret_cast</span>&lt;CREATESTRUCT*&gt;(lParam);</span><br><span class="line">        pState = <span class="keyword">reinterpret_cast</span>&lt;StateInfo*&gt;(pCreate-&gt;lpCreateParams);</span><br><span class="line">        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pState);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pState = GetAppState(hwnd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remainder of the window procedure not shown ...</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="面向对象的方法"><a href="#面向对象的方法" class="headerlink" title="面向对象的方法"></a>面向对象的方法</h4><p>我们可以进一步扩展此方法。我们已经定义了一个数据结构来保存有关窗口的状态信息。为这种数据结构提供对数据进行操作的成员函数（方法）是有意义的。这自然导致了一种设计，其中结构（或类）负责窗口上的所有操作。然后，窗口过程将成为该类的一部分。</p>
<p>也就是我们可以从下面的步骤开始创建我们的窗口</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pseudocode</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StateInfo *pState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get pState from the HWND. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_SIZE:</span><br><span class="line">            HandleResize(pState, ...);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">            HandlePaint(pState, ...);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// And so forth.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来的问题就是如何找到 <code> MyWindow::WinProc</code> 方法。 RegisterClass 函数需要窗口过程是一个函数指针。在这种情况下，您不能将指针传递给（非静态）成员函数。但是，您可以将指针传递给<em>静态</em>成员函数，然后再委托给成员函数。这是一个显示此方法的类模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">DERIVED_TYPE</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">BaseWindow</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DERIVED_TYPE *pThis = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (uMsg == WM_NCCREATE)</span><br><span class="line">        &#123;</span><br><span class="line">            CREATESTRUCT* pCreate = (CREATESTRUCT*)lParam;</span><br><span class="line">            pThis = (DERIVED_TYPE*)pCreate-&gt;lpCreateParams;</span><br><span class="line">            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pThis);</span><br><span class="line"></span><br><span class="line">            pThis-&gt;m_hwnd = hwnd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pThis = (DERIVED_TYPE*)GetWindowLongPtr(hwnd, GWLP_USERDATA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pThis)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> pThis-&gt;HandleMessage(uMsg, wParam, lParam);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> DefWindowProc(hwnd, uMsg, wParam, lParam);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BaseWindow() : m_hwnd(<span class="literal">NULL</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">Create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        PCWSTR lpWindowName,</span></span></span><br><span class="line"><span class="function"><span class="params">        DWORD dwStyle,</span></span></span><br><span class="line"><span class="function"><span class="params">        DWORD dwExStyle = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> x = CW_USEDEFAULT,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> y = CW_USEDEFAULT,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> nWidth = CW_USEDEFAULT,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> nHeight = CW_USEDEFAULT,</span></span></span><br><span class="line"><span class="function"><span class="params">        HWND hWndParent = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        HMENU hMenu = <span class="number">0</span></span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        WNDCLASS wc = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        wc.lpfnWndProc   = DERIVED_TYPE::WindowProc;</span><br><span class="line">        wc.hInstance     = GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line">        wc.lpszClassName = ClassName();</span><br><span class="line"></span><br><span class="line">        RegisterClass(&amp;wc);</span><br><span class="line"></span><br><span class="line">        m_hwnd = CreateWindowEx(</span><br><span class="line">            dwExStyle, ClassName(), lpWindowName, dwStyle, x, y,</span><br><span class="line">            nWidth, nHeight, hWndParent, hMenu, GetModuleHandle(<span class="literal">NULL</span>), <span class="keyword">this</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (m_hwnd ? TRUE : FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HWND <span class="title">Window</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_hwnd; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> PCWSTR  <span class="title">ClassName</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> LRESULT <span class="title">HandleMessage</span><span class="params">(UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    HWND m_hwnd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>所述<code>BaseWindow</code>类是一个抽象基类，从该特定窗口类衍生的。例如，以下是派生自的简单类的声明<code>BaseWindow</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span> :</span> <span class="keyword">public</span> BaseWindow&lt;MainWindow&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">PCWSTR  <span class="title">ClassName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">L&quot;Sample Window Class&quot;</span>; &#125;</span><br><span class="line">    <span class="function">LRESULT <span class="title">HandleMessage</span><span class="params">(UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>要创建窗口，调用 <code> BaseWindow::Create</code> :</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">wWinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE, PWSTR pCmdLine, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MainWindow win;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!win.Create(<span class="string">L&quot;Learn to Program Windows&quot;</span>, WS_OVERLAPPEDWINDOW))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ShowWindow(win.Window(), nCmdShow);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run the message loop.</span></span><br><span class="line"></span><br><span class="line">    MSG msg = &#123; &#125;;</span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        TranslateMessage(&amp;msg);</span><br><span class="line">        DispatchMessage(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>纯虚函数 <code> BaseWindow::HandleMessage</code> 用来实现窗口过程，下面的实现就和最开始的示例实现等价：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">MainWindow::HandleMessage</span><span class="params">(UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        &#123;</span><br><span class="line">            PAINTSTRUCT ps;</span><br><span class="line">            HDC hdc = BeginPaint(m_hwnd, &amp;ps);</span><br><span class="line">            FillRect(hdc, &amp;ps.rcPaint, (HBRUSH) (COLOR_WINDOW+<span class="number">1</span>));</span><br><span class="line">            EndPaint(m_hwnd, &amp;ps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> DefWindowProc(m_hwnd, uMsg, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，窗口句柄存储在成员变量（<em>m_hwnd</em>）中，因此我们无需将其作为参数传递给<code>HandleMessage</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> PCWSTR  <span class="title">ClassName</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> LRESULT <span class="title">HandleMessage</span><span class="params">(UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    HWND m_hwnd;</span><br></pre></td></tr></table></figure>























]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>GameDev</tag>
      </tags>
  </entry>
</search>
