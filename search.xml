<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C/C++ 内存布局</title>
    <url>/myblog/2020/09/22/C/C++%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<hr>
<h2 id="C-C-内存布局"><a href="#C-C-内存布局" class="headerlink" title="C/C++ 内存布局"></a>C/C++ 内存布局</h2><h4 id="一、可执行映像"><a href="#一、可执行映像" class="headerlink" title="一、可执行映像"></a>一、可执行映像</h4><p>&emsp;&emsp;当生成C/C++程序的时候，链接器生成可执行文件。在UNIX和大多数游戏主机上面使用一种 <strong><em>可执行与可链接格式(executable and linkable format, ELF)</em></strong> 。在这些平台上的可执行文件使用后缀 <strong><em>.elf</em></strong> 。在Windows中的可执行文件同意类似与ELF，使用 <strong><em>.exe</em></strong> 作为扩展名。</p>
<p>映像文件一般最少由一下几个部分构成：</p>
<ul>
<li><p>代码段(text/code segement)</p>
<blockquote>
<p>程序中定义的函数的全部机械码</p>
</blockquote>
</li>
<li><p>数据段(data segment)</p>
<blockquote>
<p>已经初始化的全部静态变量<br>将由连接器为其分配内存，并且填如适当的初始值</p>
</blockquote>
</li>
<li><p>BBS 段(BBS segement)</p>
<blockquote>
<p>BBS是一种老旧的叫法，意为 <strong><em>“由符号开始的块(block started by symbol)”</em></strong>。包含程序定义中所有的未初始化的全局变量和静态变量，在C/C++中未初始化的全局变量和静态变量全为零。</p>
</blockquote>
</li>
<li><p>只读数据段(read only data segement)</p>
<blockquote>
<p> 又称为 <strong><em>rodata</em></strong> 段,包含程序中定义的只读(常量)全局变量。<br> 比如：浮点常量，用const关键字声名的全局对象实例……</p>
<blockquote>
<p>tips: 编译器通常会把整数常量视为<strong>明示常量</strong>(manifast constant)，并且直接把明示常量插入机器码中，直接占用代码段的存储空间而不存储于只读数据段。</p>
</blockquote>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>Memory Management</tag>
        <tag>GameDev</tag>
      </tags>
  </entry>
  <entry>
    <title>利用汇编深入学习C++</title>
    <url>/myblog/2020/09/26/C/%E5%88%A9%E7%94%A8%E6%B1%87%E7%BC%96%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0C++/</url>
    <content><![CDATA[<h1 id="一、基础内容"><a href="#一、基础内容" class="headerlink" title="一、基础内容"></a>一、基础内容</h1><h3 id="1、杂项"><a href="#1、杂项" class="headerlink" title="1、杂项"></a>1、杂项</h3><hr>
<h5 id="（1）汇编语言，机器语言，高级语言"><a href="#（1）汇编语言，机器语言，高级语言" class="headerlink" title="（1）汇编语言，机器语言，高级语言"></a>（1）汇编语言，机器语言，高级语言</h5><p><code>汇编语言</code>与<code>机器语言</code>一一对应，每一条机器指令都有与之相对的汇编指令</p>
<p><code>汇编语言</code>可以通过编译得到<code>机器语言</code>，<code>机器语言</code>可以通过反汇编得到<code>汇编语言</code></p>
<p><code>高级语言</code>可以通过编译得到<code>汇编语言\机器语言</code>，但是<code>汇编语言\机器语言</code>几乎不可能还原成<code>高级语言</code></p>
<p>​&emsp;&emsp;&emsp;&emsp;&emsp;编译        </p>
<p>​&emsp;汇编语言 ——&gt; 机器语言</p>
<p>​            mov ax, bx&lt;—— 0010101011</p>
<p>​&emsp;&emsp;&emsp;&emsp;反编译</p>
<p>eg：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line">Date d = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">C7 <span class="number">45</span> F0 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov			dword ptr [ebp<span class="number">-10</span>h],<span class="number">1</span></span><br><span class="line">C7 <span class="number">45</span> F4 <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov			dword ptr [ebp<span class="number">-0</span>Ch],<span class="number">2</span></span><br><span class="line">C7 <span class="number">45</span> F8 <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov			dword ptr [ebp<span class="number">-8</span>],<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">C7 <span class="number">45</span> F0 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov			dword ptr [ebp<span class="number">-10</span>h],<span class="number">1</span></span><br><span class="line">C7 <span class="number">45</span> F4 <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov			dword ptr [ebp<span class="number">-0</span>Ch],<span class="number">2</span></span><br><span class="line">C7 <span class="number">45</span> F8 <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov			dword ptr [ebp<span class="number">-8</span>],<span class="number">3</span></span><br><span class="line"><span class="comment">/*注意到两者的机器码和汇编码完全一样，所以只确定汇编\机器语言不能还原为唯一确定的高级语言，如果一定需要</span></span><br><span class="line"><span class="comment">相关高级语言，那么可以将其还原为伪代码，在人为还原为高级语言。*/</span></span><br></pre></td></tr></table></figure>

<p>​    <strong>在不同架构的CPU下，生成的汇编码不一样</strong></p>
<h5 id="（2）一些编程语言的本质区别"><a href="#（2）一些编程语言的本质区别" class="headerlink" title="（2）一些编程语言的本质区别"></a>（2）一些编程语言的本质区别</h5><ul>
<li><p>C++</p>
<blockquote>
<p>轻易反汇编</p>
</blockquote>
<p>编译器编译为汇编代码，可以和机器码进行转换</p>
</li>
<li><p>JavaScript</p>
<blockquote>
<p>脚本语言，由浏览器进行解析</p>
</blockquote>
</li>
<li><p>PHP</p>
<blockquote>
<p>脚本语言，由Zend Engine(ZE)进行解析</p>
</blockquote>
<p>JS 和 PHP 在通过引擎解析后变为中间代码，然后转为<code>机器码(不同语言的机器码不同)</code>，所以不好接触到底层</p>
</li>
<li><p>Java</p>
<blockquote>
<p>由JVM进行装载字节码</p>
</blockquote>
<p>编译器编译为class（字节码），然后通过JVM虚拟机形转为器码</p>
</li>
</ul>
<p>无论用什么语言编写代码，最终会形成几乎相同的机器码。</p>
<h3 id="2、函数重载（Overload）"><a href="#2、函数重载（Overload）" class="headerlink" title="2、函数重载（Overload）"></a>2、函数重载（Overload）</h3><hr>
<ul>
<li><p>规则</p>
<blockquote>
<p>函数名相同</p>
<p>参数个数不同、参数类型不同、参数顺序不同</p>
</blockquote>
</li>
<li><p>注意</p>
<blockquote>
<p>返回值类型与函数重载无关</p>
<p>调用函数时，实参的隐式类型转换可能会产生二义性</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>本质</p>
<blockquote>
<p>采用了name mangling或者叫name decoration的技术，C++编译器默认会对符号名（比如函数名）进行改变，修饰。</p>
<p>重载时产生的函数名字和编译器有关，不同编译器不同，产生的名字不同。</p>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;        			 		<span class="function">call		<span class="title">display</span><span class="params">(<span class="number">0</span>CA1429h)</span>		</span></span><br><span class="line"><span class="function">    <span class="comment">//...</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;					<span class="function">call		<span class="title">display</span><span class="params">(<span class="number">0</span>CA13F7h)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//...</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">long</span> a)</span></span>&#123;					<span class="function">call		<span class="title">display</span><span class="params">(<span class="number">0</span>CA1230h)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//...</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(doble a)</span></span>&#123;					<span class="function">call		<span class="title">display</span><span class="params">(<span class="number">0</span>CA10B4h)</span>	</span></span><br><span class="line"><span class="function">    <span class="comment">//...																</span></span></span><br><span class="line">&#125;</span><br><span class="line">VS简化了函数名，使其看上去一样，但函数后面括号里的不同数值表示调用的函数地址并不相同。</span><br></pre></td></tr></table></figure>

<p>使用IDA进行逆向工程，在main文件里查看汇编码：</p>
<blockquote>
<p>记得将程序以release版本生成，去除调试信息，使文件精简。但是相对的release会对程序进行相应的优化，比如上面4个打印函数，编译器会直接将4个函数改为4个直接输出，不再进行函数调用。所以要将编译器的优化选项关闭。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call		display</span><br><span class="line">call		display_1</span><br><span class="line">call		display_2</span><br><span class="line">call		display_3			可见的确进行了name mangling使函数重载得以实现</span><br></pre></td></tr></table></figure>



<h3 id="3、默认参数"><a href="#3、默认参数" class="headerlink" title="3、默认参数"></a>3、默认参数</h3><hr>
<p>C++允许函数设置默认参数，在调用时可以根据情况省略实参。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> v1 = <span class="number">5</span>, <span class="keyword">int</span> v2 = <span class="number">6</span>)</span></span>&#123; <span class="comment">// 默认参数值必须从右边开始 int v1 = 10, int v2 ---&gt; 编译不通过</span></span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum(<span class="number">10</span>) &lt;&lt;<span class="built_in">endl</span>;<span class="comment">// 16</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 30</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//同时有声明和实现的时候，只能在声明处填默认参数</span></span><br></pre></td></tr></table></figure>



<p>默认参数的值可以是常量、全局符号（全局变量、函数名）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> v1 = <span class="number">5</span>, <span class="keyword">int</span> v2 = <span class="number">6</span>)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;test(int) - &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">void</span>(*p)(<span class="keyword">int</span>) = test)</span></span>&#123; <span class="comment">//函数指针</span></span><br><span class="line">    p(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>(*p)(<span class="keyword">int</span>) = test;</span><br><span class="line">    p(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum(<span class="number">10</span>) &lt;&lt;<span class="built_in">endl</span>;<span class="comment">// 16</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 30</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>如果函数的参数经常使用同一个值，推荐使用默认参数</strong></p>
<p>函数重载和默认参数共同使用的时候会产生冲突、二义性。在这种情况下建议优先选择默认参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    display(<span class="number">10</span>); <span class="comment">//报错，编译不通过</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认参数的本质：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">push		<span class="number">2</span></span><br><span class="line">push		<span class="number">1</span>    <span class="comment">//传参</span></span><br><span class="line"><span class="function">call		<span class="title">sum</span><span class="params">(<span class="number">0F</span>E1424h)</span></span></span><br><span class="line">add			esp,8</span><br><span class="line"></span><br><span class="line">sum(<span class="number">2</span>, <span class="number">4</span>); </span><br><span class="line">push		<span class="number">4</span></span><br><span class="line">push		<span class="number">2</span></span><br><span class="line"><span class="function">call		<span class="title">sum</span><span class="params">(<span class="number">0F</span>E1424h)</span> <span class="comment">//调用相同的函数地址</span></span></span><br><span class="line">add			esp,8</span><br></pre></td></tr></table></figure>

<p>添加默认参数</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2 = <span class="number">4</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>);</span><br><span class="line">push		<span class="number">4</span></span><br><span class="line">push		<span class="number">1</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//也就是说 sum(1); 和 sum(1, 4); 是完全一样的功能，经验证机器码也是几乎一样。</span></span><br><span class="line"><span class="function">E8 A3 F2 FF FF			call		<span class="title">sum</span><span class="params">(<span class="number">01271424</span>h)</span></span></span><br><span class="line">E8 97 F2 FF FF			call		sum(01271424h)  仅有E8 后面计算出的地址值有细微区别 (详见Intel机器码白皮书)</span><br></pre></td></tr></table></figure>



<h3 id="4、extern-“C”"><a href="#4、extern-“C”" class="headerlink" title="4、extern “C”"></a>4、extern “C”</h3><hr>
<p>被<code>extern &quot;C&quot;</code>修饰的代码会按照C语言的规范去编译</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line">exterm <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123; <span class="comment">//报错，因为C不支持重载</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果函数同时有声明与实现，要在声明处使用<code>extern &quot;C&quot;</code>，在实现处可以不用添加。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">为方便使用直接在头文件使用</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;****.h&quot;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<ul>
<li>使用用C语言开发的第三方框架\库</li>
</ul>
<p>在C\C++混合开发的时候会出现大量问题，推荐按一下方式使用<code>extern &quot;C&quot;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus <span class="comment">//使用宏</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>为了避免重复引用，用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ***</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ***</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>但是一定要保证每一个文件里的宏都不相同，推荐将宏和文件名字相同。<code>#pragma once</code> 可以保证整个文件内容只被编译一次，避免重复包含，但是 <code>#pragma once</code>不被某些编译器支持。</p>
<h3 id="5、内联函数"><a href="#5、内联函数" class="headerlink" title="5、内联函数"></a>5、内联函数</h3><hr>
<p>使用<code>inline</code>关键字将其变为内联函数。编译器直接将函数调用展开为函数体代码。</p>
<p>在函数开始的时候会开辟栈空间，函数结束的时候回收栈空间。内联函数在代码体积不大和使用次数过多的时候推荐使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">int</span> c = sum(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    不内联</span><br><span class="line">    push		<span class="number">14</span>h</span><br><span class="line">    push		<span class="number">0</span>Ah</span><br><span class="line">    <span class="function">call		<span class="title">sum</span><span class="params">(<span class="number">08110</span>A0h)</span></span></span><br><span class="line">    在release模式下，编译器会直接将sum函数优化，直接给出返回值，不再调用函数。</span><br><span class="line">    把优化关闭，进行相关调整后</span><br><span class="line">    mov			eax,<span class="number">0</span>Ah</span><br><span class="line">   	add 		eax,<span class="number">14</span>h</span><br><span class="line">    mov			dword ptr [c],eax  <span class="comment">//等同于直接实现 10 + 20 </span></span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内联函数与宏对比：</p>
<ul>
<li>两者都能减少函数调用</li>
<li>相比于宏内联函数具有函数特性，拥有语法检测和代码提示功能</li>
</ul>
<h3 id="6、表达式"><a href="#6、表达式" class="headerlink" title="6、表达式"></a>6、表达式</h3><hr>
<ul>
<li><p>C++有些表达式能被赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">(a = b) = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// a = 4; b = 2;</span></span><br><span class="line">(a &gt; b ? a : b) = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// b = 4</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="7、const"><a href="#7、const" class="headerlink" title="7、const"></a>7、const</h3><hr>
<ul>
<li><p>const是常量的意思，被修饰的变量不可修改</p>
<p>如果修饰的是类、结构体(的指针)，成员函数不可以更改</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p0 = &amp;age;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p1 = &amp;age; <span class="comment">// p0 p1 等价，都被const修饰</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p2 = &amp;age;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p3 = &amp;age;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p4 = &amp;age; <span class="comment">// p3 p4 等价</span></span><br></pre></td></tr></table></figure>

<p>对于const有以下结论：</p>
<ul>
<li><p>const修饰的是其右边的内容 </p>
<blockquote>
<p>const int * <code>const p3</code> = &age;  意味着p3为常量但是*p3不是常量，可以对 *p3进行修改</p>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span> <span class="keyword">int</span> age; &#125;;</span><br><span class="line">Student stu1 = &#123;<span class="number">20</span>&#125;;</span><br><span class="line">Student stu2 = &#123;<span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Student *pStu1 = &amp;stu1;</span><br><span class="line">*pStu1 = stu2; <span class="comment">// 报错，const修饰*pStu1不能被赋值</span></span><br><span class="line">(*pStu1).age = <span class="number">30</span>; </span><br><span class="line">pStu1-&gt;age = <span class="number">30</span>; <span class="comment">// 报错，为了保证const的严谨性，不允许通过指针访问成员属性</span></span><br><span class="line">pStu1 = &amp;stu2;</span><br><span class="line"></span><br><span class="line">Student * <span class="keyword">const</span> pStu2 = &amp;stu2;</span><br><span class="line">*pStu2 = stu1;</span><br><span class="line">(*pStu2).age = <span class="number">30</span>;</span><br><span class="line">pStu2-&gt;age = <span class="number">30</span>;</span><br><span class="line">pStu2 = &amp;stu1; <span class="comment">// 报错，不能修改pStu2的内容</span></span><br></pre></td></tr></table></figure>

<h3 id="8、引用-Reference"><a href="#8、引用-Reference" class="headerlink" title="8、引用(Reference)"></a>8、引用(Reference)</h3><hr>
<p>在C语言中，使用<code>指针(Pointer)</code>可以间接获取、修改某个变量的值</p>
<p>在C++中，使用<code>引用(Reference)</code>可以起到更指针类似的功能</p>
<p>引用的注意点：</p>
<ul>
<li>引用相当于变量的别名</li>
<li>对引用做计算等于对其指向的变量做运算</li>
<li>必须在定义的时候初始化，而且一旦指向某个变量就不可以再改变</li>
<li>可以利用一个引用初始化另一个引用，相当于一个变量有多个别名</li>
<li>不存在<code>引用的引用</code>、<code>指向引用的指针</code>、<code>引用数组</code></li>
</ul>
<p>引用的价值：比指针更安全、函数返回值可以被赋值</p>
<h5 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h5><ul>
<li>引用的本质就是指针，只是编译器削弱了它的功能，引用就是弱化了的指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> &amp;age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(student) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8 X64环境 也就是从侧面证明了引用的大小为8bit</span></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>汇编码(关闭显示符号):</p>
<ul>
<li>指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;age;</span><br><span class="line">lea			eax,[ebp<span class="number">-18</span>h],eax</span><br><span class="line">mov			dword ptr [ebp<span class="number">-18</span>h],eax</span><br><span class="line">*p = <span class="number">30</span>;</span><br><span class="line">mov 		eax,dword ptr [ebp<span class="number">-18</span>h]</span><br><span class="line">mov 		dword ptr [eax],<span class="number">1</span>Eh</span><br></pre></td></tr></table></figure>

<ul>
<li>引用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;ref = age;</span><br><span class="line">lea			eax,[ebp<span class="number">-18</span>h],eax</span><br><span class="line">mov			dword ptr [ebp<span class="number">-18</span>h],eax</span><br><span class="line">ref = <span class="number">30</span>;</span><br><span class="line">mov 		eax,dword ptr [ebp<span class="number">-18</span>h]</span><br><span class="line">mov 		dword ptr [eax],<span class="number">1</span>Eh</span><br></pre></td></tr></table></figure>

<p>通过对比发现两者的汇编码完全一样，所以一个引用也就占用一个指针的大小</p>
<h1 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a>二、基础语法</h1><h3 id="1、x86，x64汇编"><a href="#1、x86，x64汇编" class="headerlink" title="1、x86，x64汇编"></a>1、x86，x64汇编</h3><hr>
<p>汇编语言的种类</p>
<ul>
<li>8086汇编</li>
<li>x86汇编</li>
<li>x64汇编</li>
<li>ＡＲＭ汇编</li>
<li>．．．．．．</li>
</ul>
<p>根据编译器不同，有两种书写格式</p>
<ul>
<li>Intel(Visual Studio)</li>
<li>AT&amp;T(Mac)</li>
</ul>
<h5 id="x64汇编-寄存器"><a href="#x64汇编-寄存器" class="headerlink" title="x64汇编- 寄存器"></a>x64汇编- 寄存器</h5><p>不同汇编的寄存器不同</p>
<p>常用寄存器：</p>
<table>
<thead>
<tr>
<th align="left">标识符</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>RAX\RBX\RCX\RDX</strong></td>
<td align="left"><strong>(64bit下常见)通用寄存器</strong></td>
</tr>
<tr>
<td align="left"><strong>EAX\EBXECX\EDX</strong></td>
<td align="left"><strong>(32bit下常见))通用寄存器</strong></td>
</tr>
<tr>
<td align="left"><strong>AX\BX\CX\DX</strong></td>
<td align="left"><strong>(16bit下常见)通用寄存器</strong></td>
</tr>
</tbody></table>
<p>tips：</p>
<blockquote>
<ul>
<li><p>一个寄存器能存8个字节(x64)</p>
</li>
<li><p>为了使新的寄存器兼容老旧的寄存器将新寄存器分成更小的区块来存储旧的寄存器</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>63…32</th>
<th>31…16</th>
<th>15…8</th>
<th>7…0</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td><strong>AH…</strong></td>
<td><strong>AL…</strong></td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>AX…</strong></td>
<td><strong>…</strong></td>
</tr>
<tr>
<td></td>
<td><strong>EAX…</strong></td>
<td><strong>…</strong></td>
<td><strong>…</strong></td>
</tr>
<tr>
<td><strong>RAX…</strong></td>
<td><strong>…</strong></td>
<td><strong>…</strong></td>
<td><strong>…</strong></td>
</tr>
</tbody></table>
<p>AH H high</p>
<p>AL  L low</p>
</blockquote>
<h3 id="2、内联汇编"><a href="#2、内联汇编" class="headerlink" title="2、内联汇编"></a>2、内联汇编</h3><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    __asm&#123; <span class="comment">//x86</span></span><br><span class="line">        mov eax, a  <span class="comment">//真实的汇编不会存在a这个符号  实际的汇编码为 eax,dword ptr[ebp-oCh]</span></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;		</span><br></pre></td></tr></table></figure>

<h3 id="3、常见指令"><a href="#3、常见指令" class="headerlink" title="3、常见指令"></a>3、常见指令</h3><hr>
<ul>
<li><p>mov              dest, src</p>
<blockquote>
<p>将src内容赋值给dest，类似于dest = src</p>
</blockquote>
</li>
<li><p>[地址值]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = a + <span class="number">1</span>；</span><br><span class="line">    </span><br><span class="line">mov           dword ptr [ebp<span class="number">-8</span>], <span class="number">3</span></span><br><span class="line"><span class="comment">//mov [1122h], 3 意味着将3放入[1122h]所在的地址空间</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><strong>mov                 [1128h], 3</strong></p>
<p><strong><code>word</code>是2个字节，<code>dword</code>是4个字节，<code>qword</code>是8个字节</strong></p>
<p><strong>mov                 dword ptr [1128h], 3</strong>  //将3放到地址以1128h开始的内存中，并占用dword个内存地址**(向高地址合并)**</p>
<p>4个字节存储3：</p>
<blockquote>
<p>16进制: 00 00 00 03H </p>
<p>2进制: 00000000 00000000 00000000 00000011</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">内存地址</th>
<th align="center">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1122h</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1123h</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1124h</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1125h</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1126h</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1127h</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1128h</td>
<td align="center">3     (00 00 00 11) 小端模式</td>
</tr>
<tr>
<td align="center">1129h</td>
<td align="center">|      (00 00 00 00)</td>
</tr>
<tr>
<td align="center">112Ah</td>
<td align="center">|      (00 00 00 00)</td>
</tr>
<tr>
<td align="center">112Bh</td>
<td align="center">|      (00 00 00 00)</td>
</tr>
</tbody></table>
<p>大部分时候是小端模式(高字节放高地址，低字节放低地址)，注意在读地址的时候不论大小端模式，都是从低地址开始读，读取设定的字节后，如何排列顺序再考虑大小端模式问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="number">0x007DF968</span>		<span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> cc cc cc cc <span class="comment">//8个字节， a占用了4个字节</span></span><br><span class="line"><span class="number">0x007DF970</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>一个变量的地址值，是他所有字节地址中的最小值</p>
</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">mov 	dword ptr [ebp<span class="number">-8</span>], <span class="number">3</span></span><br><span class="line"><span class="comment">//[ebp-8] 即为变量a的地址</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;　&amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//a的地址为 010FFE4C</span></span><br><span class="line">汇编码为:</span><br><span class="line">mov		dword ptr [ebp<span class="number">-0</span>Ch], <span class="number">3</span> <span class="comment">//这里的值不能写死，因为每次调用函数时开辟栈空间</span></span><br><span class="line">    						 <span class="comment">//而且每一次分配的地址不同，里面的局部变量的地址会一直改变</span></span><br><span class="line">    						 <span class="comment">//每次调用都不同， -0ch 则涉及到函数栈的问题。</span></span><br><span class="line"><span class="comment">//ebp的值为 010FFE58</span></span><br><span class="line">a - ebp = c (<span class="number">16</span>进制)</span><br><span class="line">    </span><br><span class="line">如果是全局变量的地址值,该变量的地址值是写死的</span><br><span class="line">age = <span class="number">3</span>;</span><br><span class="line">mov			dword ptr ds:[<span class="number">00F</span>DA008h] <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">常量的话地址值也会变动</span><br></pre></td></tr></table></figure>

<ul>
<li>call 函数地址</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	test();   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">首先:</span><br><span class="line">call		<span class="number">003713</span>A2 <span class="comment">//并非真正函数地址 按F11</span></span><br><span class="line"></span><br><span class="line">jmp			<span class="number">00371780</span> <span class="comment">//跳转到真正的函数地址 进入这个地址</span></span><br><span class="line">    </span><br><span class="line"><span class="number">00371780</span> <span class="number">55</span>			push		ebp</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ul>
<li>lea               eax, [1122h]     //load effect address 装载一个有效的地址值</li>
</ul>
<blockquote>
<p>等同于 mov             eax, 1122h</p>
</blockquote>
<ul>
<li>ret</li>
</ul>
<blockquote>
<p>函数返回</p>
</blockquote>
<ul>
<li>xor</li>
</ul>
<blockquote>
<p>异或 xor            op1, op2将op1和op2异或的结果赋值给op1</p>
</blockquote>
<ul>
<li>add，sub</li>
</ul>
<blockquote>
<p>加法，减法</p>
</blockquote>
<ul>
<li>inc，dec</li>
</ul>
<blockquote>
<p>自增，自减</p>
</blockquote>
<ul>
<li>jmp</li>
</ul>
<blockquote>
<p>jmp             内存地址      跳转到指定的内存地址开始执行(无条件跳转)</p>
<p>以 j 开头的汇编指令一般都是跳转，一般跟test、cmp等指令配合使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a == b)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="number">007118F</span>8  mov         dword ptr [ebp<span class="number">-8</span>],<span class="number">0</span>Ah  </span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="number">007118F</span>F  mov         dword ptr [ebp<span class="number">-14</span>h],<span class="number">14</span>h  </span><br><span class="line"><span class="keyword">if</span> (a == b) &#123;</span><br><span class="line"><span class="number">00711906</span>  mov         eax,dword ptr [ebp<span class="number">-8</span>]  </span><br><span class="line"><span class="number">00711909</span>  cmp         eax,dword ptr [ebp<span class="number">-14</span>h]  </span><br><span class="line"><span class="number">0071190</span>C  jne         <span class="number">0071191</span>D  </span><br><span class="line"><span class="comment">// jump not equal</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="number">0071190</span>E  push        <span class="number">717B</span>30h  </span><br><span class="line"><span class="number">00711913</span>  call        <span class="number">00711046</span>  </span><br><span class="line"><span class="number">00711918</span>  add         esp,<span class="number">4</span>  </span><br><span class="line">	&#125;</span><br><span class="line"><span class="number">0071191B</span>  jmp         <span class="number">0071192</span>A  </span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="number">0071191</span>D  push        <span class="number">717B</span>34h  <span class="comment">// jne 跳转的地址</span></span><br><span class="line"><span class="number">00711922</span>  call        <span class="number">00711046</span>  </span><br><span class="line"><span class="number">00711927</span>  add         esp,<span class="number">4</span>  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0071192</span>A  <span class="keyword">xor</span>         eax,eax <span class="comment">// jmp 跳转的地址</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>汇编权威参考： Intel 白皮书</strong></p>
<h3 id="4、引用"><a href="#4、引用" class="headerlink" title="4、引用"></a>4、引用</h3><hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> age = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> *p = &amp;age;</span><br><span class="line">	*p = <span class="number">5</span>;</span><br><span class="line">	</span><br><span class="line"><span class="number">007</span>D17F2  mov         dword ptr [ebp<span class="number">-0</span>C h],<span class="number">3</span>  </span><br><span class="line"><span class="number">007</span>D17F9  lea         eax,[ebp<span class="number">-0</span>Ch]  <span class="comment">// eax 存放age的地址值</span></span><br><span class="line"><span class="number">007</span>D17FC  mov         dword ptr [ebp<span class="number">-18</span>h],eax  </span><br><span class="line"><span class="comment">//将age的地址值存放到指针变量p所在的存储空间</span></span><br><span class="line"><span class="number">007</span>D17FF  mov         eax,dword ptr [ebp<span class="number">-18</span>h]  </span><br><span class="line"><span class="comment">//将age的地址值存放到 eax</span></span><br><span class="line"><span class="number">007</span>D1802  mov         dword ptr [eax],<span class="number">5</span>  </span><br><span class="line"><span class="comment">//将5放到age的地址值</span></span><br><span class="line"><span class="number">007</span>D1808  mov         esi,esp  </span><br><span class="line">    </span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以如果代码牵扯到指针，那么一定会牵扯到汇编的 <code>lea</code> 指令</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lea 		eax,[ebp<span class="number">-0</span>Ch] <span class="comment">// [ebp-0Ch]数据地址值</span></span><br><span class="line">mov 		dword ptr [ebp<span class="number">-18</span>h],eax <span class="comment">//[ebp-18h]指针变量自己的地址值</span></span><br></pre></td></tr></table></figure>

<p>如果是引用的话：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">3</span></span><br><span class="line"><span class="keyword">int</span> &amp;ref = age;</span><br><span class="line">ref = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">00B</span>817F2  mov         dword ptr [ebp<span class="number">-0</span>Ch],<span class="number">3</span>  </span><br><span class="line"><span class="number">00B</span>817F9  lea         eax,[ebp<span class="number">-0</span>Ch]  </span><br><span class="line"><span class="number">00B</span>817FC  mov         dword ptr [ebp<span class="number">-18</span>h],eax  </span><br><span class="line"><span class="number">00B</span>817FF  mov         eax,dword ptr [ebp<span class="number">-18</span>h]  </span><br><span class="line"><span class="number">00B</span>81802  mov         dword ptr [eax],<span class="number">5</span></span><br><span class="line"><span class="comment">// 和指针的汇编码完全一样</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指针引用</span></span><br><span class="line">*<span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;age;</span><br><span class="line"><span class="keyword">int</span> *&amp;ref = p;</span><br><span class="line">*ref = <span class="number">30</span>; <span class="comment">// ref == f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> height = <span class="number">30</span>;</span><br><span class="line">ref = &amp;height; <span class="comment">// p = 30;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组引用</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (&amp;ref)[<span class="number">3</span>] = <span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *arr[<span class="number">3</span>]; <span class="comment">//指针数组，数组内部能放3个int*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*arr)[<span class="number">3</span>]; <span class="comment">//数组指针，用于指向数组的指针  ----&gt;  推出数组指针的一种写法 int (&amp;arr)[3] = array;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h5><p>const必须写在&amp;符号的左边才是常饮用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref = age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp; <span class="keyword">const</span> ref = age;</span><br><span class="line">ref = <span class="number">30</span>;</span><br><span class="line"><span class="comment">//ref 不能修改指向，但是可以通过ref间接修改所指向的变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对比指针</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p1 = &amp;age; <span class="comment">// p1 = &amp;height</span></span><br><span class="line">*p1 = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p2可以修改指向，不可以利用p2间接修改所指向的变量</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p2 = &amp;age;</span><br></pre></td></tr></table></figure>

<h5 id="const-引用的特点"><a href="#const-引用的特点" class="headerlink" title="const 引用的特点"></a>const 引用的特点</h5><ul>
<li>const引用可以指向临时数据(常量、表达式、函数返回值等等)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref = <span class="number">30</span>; <span class="comment">//常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref = a + b; <span class="comment">// 表达式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;ref = func(); <span class="comment">// 函数返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>作为函数参数时(同时适用于const指针)</li>
</ul>
<blockquote>
<p>可以接受const和非const实参(非const引用，只能接受非const实参)</p>
<p>可以跟非const引用构成重载</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;v1, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> v1 + v2;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> &amp;v1, <span class="keyword">int</span> &amp;v2)</span></span>&#123; <span class="comment">// 构成重载</span></span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 非const实参</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//const实参</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> d = <span class="number">20</span></span><br><span class="line">    sum(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    sum(c, d);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当常引用指向了不同的数据时，会产生<code>临时变量</code>，即引用指向的并不是初始化时的那个变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> &amp;rAge = age;</span><br><span class="line">age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; age; <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; rAge; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="number">00</span>CB17F2  mov         dword ptr [ebp<span class="number">-0</span>Ch],<span class="number">0</span>Ah  <span class="comment">// </span></span><br><span class="line"><span class="number">00</span>CB17F9  mov         eax,dword ptr [ebp<span class="number">-0</span>Ch]  <span class="comment">// 10 放到 eax</span></span><br><span class="line"><span class="number">00</span>CB17FC  mov         dword ptr [ebp<span class="number">-24</span>h],eax  <span class="comment">// 10 放到另外一个存储空间</span></span><br><span class="line">相当于 <span class="keyword">const</span> <span class="keyword">long</span> &amp;rAge = temp;</span><br><span class="line"><span class="number">00</span>CB17FF  lea         ecx,[ebp<span class="number">-24</span>h]  </span><br><span class="line"><span class="number">00</span>CB1802  mov         dword ptr [ebp<span class="number">-18</span>h],ecx  </span><br><span class="line"><span class="number">00</span>CB1805  mov         dword ptr [ebp<span class="number">-0</span>Ch],<span class="number">1</span>Eh  </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (&amp;ref)[<span class="number">3</span>]arr = arr;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> &amp;ref = arr;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>C/C++</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>并发：互斥与同步的各种实现</title>
    <url>/myblog/2020/10/07/C/%E5%B9%B6%E5%8F%91%EF%BC%9A%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="并发：互斥与同步的各种实现"><a href="#并发：互斥与同步的各种实现" class="headerlink" title="并发：互斥与同步的各种实现"></a>并发：互斥与同步的各种实现</h1><hr>
<p>在操作系统中，核心的设计问题在与进程和线程的管理。而在对于在<code>多道程序处理</code>, <code>多处理器环境</code>，<code>分布式系统</code>等相关领域的应用，以及操作系统设计的本身，最基础的问题就是并发(Concurrency)。</p>
<p><em>由于篇幅问题，在这里只讨论各种实现，不对其各种方案的优劣进行过多讨论，感兴趣的可以参考 《操作系统 精髓与设计原理》</em></p>
<h3 id="一、互斥的硬件支持方案"><a href="#一、互斥的硬件支持方案" class="headerlink" title="一、互斥的硬件支持方案"></a>一、互斥的硬件支持方案</h3><hr>
<h5 id="1、关中断"><a href="#1、关中断" class="headerlink" title="1、关中断"></a>1、关中断</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* disable interrupts */</span></span><br><span class="line">    <span class="comment">/* critical section */</span>  临界区执行</span><br><span class="line">    <span class="comment">/* enable interrupts */</span></span><br><span class="line">    <span class="comment">/* remainder */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过采用操作系统提供的原语的方式可以使临界区的执行不可以被打断，达到了互斥的效果。</p>
<p>但是该方案有两个明显缺陷：</p>
<ul>
<li>由于临界区的执行，导致处理器不能随意穿插执行进程，导致处理器效率明显降低</li>
<li>该方案不能直接用于多处理器系统中，因为在同一时间里，可能会有多个进程在同时进行，只对一个进程进行关中段不一定能保证互斥</li>
</ul>
<h5 id="2、特殊机器指令"><a href="#2、特殊机器指令" class="headerlink" title="2、特殊机器指令"></a>2、特殊机器指令</h5><p>当处理器访问某一内存地址的时候，为了通过硬件手段避免其他处理器对该内存地址的访问，设计了几条机器指令来实现两个或两个以上动作的原子性。</p>
<p>1&gt; 比较替换指令</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span><span class="params">(<span class="keyword">int</span> *word, <span class="keyword">int</span> testVal, <span class="keyword">int</span> newVal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldVal;</span><br><span class="line">    oldVal = *word;</span><br><span class="line">    <span class="keyword">if</span>(oldVal == testVal)</span><br><span class="line">    &#123;</span><br><span class="line">        *word = testVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125; <span class="comment">// 这个函数的操作不可被干扰或者打断，具有原子性。</span></span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* program mutualexclusion */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="comment">/* number of process */</span> 进程的数量</span><br><span class="line"><span class="keyword">int</span> bolt; 共享变量初值为 <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(compare_and_swap(bolt, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>) 只有当发现bolt为<span class="number">0</span>的进程才能进入临界区，而其他的进程不停的比较替换申请进入临界区</span><br><span class="line">            								  会造成忙等现象</span><br><span class="line">            <span class="comment">/* do nothing */</span>;</span><br><span class="line">        <span class="comment">/* critical section */</span>;</span><br><span class="line">        bolt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* remainder */</span>; bolt被置零后其他进程才有一个机会将bolt置<span class="number">1</span>进入临界区</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bolt = <span class="number">0</span>;</span><br><span class="line">    parbeging( p(<span class="number">1</span>), p(<span class="number">2</span>), p(<span class="number">3</span>) ......);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2&gt; 交换指令</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> *<span class="keyword">register</span>, <span class="keyword">int</span> *memory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = *memory;</span><br><span class="line">    *memory = *<span class="keyword">register</span>;</span><br><span class="line">    *<span class="keyword">register</span> = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* program mutualexclusin */</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> n = <span class="comment">/* number of process */</span>;</span><br><span class="line"><span class="keyword">int</span> bolt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> keyi = <span class="number">1</span>;</span><br><span class="line">        do exchange(&amp;key1, &amp;bolt) 如果交换后key = 1, 那么就进入临界区，否则在临界区外忙等</span><br><span class="line">        <span class="keyword">while</span>(keyi != <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* critical section */</span></span><br><span class="line">        bolt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* remainder */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bolt = <span class="number">0</span>;</span><br><span class="line">    parbegin( p(<span class="number">1</span>), p(<span class="number">2</span>), p(<span class="number">3</span>) ......);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对于共享变量和局部变量的交换方式，以下的表达式始终成立<br>$$<br>bolt + \sum_ikey_{i} = 1<br>$$<br>bolt = 0 没有进程进入临界区，blot = 1 有且只有一个进程在临界区</p>
<h3 id="二、信号灯-Semaphore"><a href="#二、信号灯-Semaphore" class="headerlink" title="二、信号灯(Semaphore)"></a>二、信号灯(Semaphore)</h3><hr>
<p>信号灯是一个特殊的整型变量。向信号灯 <code>s</code> 发送信号，进程可以调用 <code>semSignal(s)</code> 原语。从信号灯处接收信号，进程可以调用<code>semWait(s)</code> 原语。如果进程打算接受消息的时候，消息尚未到达，则该进程必须在信号灯上等待。因此对信号灯做以下定义：</p>
<ol>
<li><strong>信号灯初值为非负整数。</strong></li>
<li><strong>semWait 操作将信号灯的值减1。如果其值为负数，调用semWait的进程执行将被阻塞。否则进程将继续执行。</strong></li>
<li><strong>semSignal操作将信号灯的值加1。如果之后其值小于等于0，则进程唤醒在该信号灯上等待的一个进程，并继续自己的执行。</strong></li>
</ol>
<p>（除了以上的3种操作以外不允许对信号灯做其他的操作）</p>
<p>信号灯的定义和操作的定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    queueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semWait</span><span class="params">(semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="keyword">if</span>(count &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/* place this process in s.queue */</span>;</span><br><span class="line">        <span class="comment">/* block this process */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semSignal</span><span class="params">(semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.count++;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/* remove a process P from s.queue */</span>;</span><br><span class="line">        <span class="comment">/* palce process P on ready list */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>01信号灯，01信号灯只有两个取值：0和1，其操作原语定义如下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_semaphore</span>&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;zero, oen&#125; value; 初值可以取<span class="number">0</span>或<span class="number">1</span></span><br><span class="line">    queueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semWaitB</span><span class="params">(binary_semaphore s)</span> <span class="comment">//检测信号灯的取值，如果值为0，执行semWaitB操作的进程将被阻塞。如果值为1，信号灯的值将被置0，并且进程继续执行</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.value == one)</span><br><span class="line">        s.value = zero;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">/* place this process in s.queue */</span></span><br><span class="line">        <span class="comment">/* block this process */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> semSignalB(semaphore s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">queue</span> is empty()) <span class="comment">//检测是否有进程被阻塞在信号灯上，如果有将唤醒一个被阻塞的进程。如果没有则将信号灯的值置1。</span></span><br><span class="line">        s.value = one;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">/* remove a process P from s.queue */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1、互斥的实现"><a href="#1、互斥的实现" class="headerlink" title="1、互斥的实现"></a>1、互斥的实现</h5><p>采用信号灯实现互斥的例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* program mutualexclusion */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="comment">/* number of processes */</span>;</span><br><span class="line">semaphore s = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(s); <span class="comment">//进程在进入critical section前调用semWait(s)原语，如果s&lt;0,进程阻塞。如果s=1, s-1后，进程进入临界区访问公共资源</span></span><br><span class="line">        <span class="comment">/* critical section */</span>;</span><br><span class="line">        semSignal(s); <span class="comment">//最开始进入的进程执行完临界区后将信号灯的值加1，并将信号灯等待队列上的一个等待进程唤醒，并置为就绪态</span></span><br><span class="line">        <span class="comment">/* remainder */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parbegin( p(<span class="number">1</span>), p(<span class="number">2</span>), p(<span class="number">3</span>)...... );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于以上的实现，信号灯的取值 <code>s.count</code> 可以这样理解：</p>
<ul>
<li>s.count &gt;= 0：能够通过调用semWait(s)原语，而无需阻塞就能进入临界区的进程个数。信号灯的这一特性，还能用于实现进程协作。</li>
<li>s.count &lt; 0：其绝对值就是在s.queue上等待信号灯的进程的个数。</li>
</ul>
<h5 id="2、生产者-消费者问题"><a href="#2、生产者-消费者问题" class="headerlink" title="2、生产者/消费者问题"></a>2、生产者/消费者问题</h5><p>生产者生产数据放入缓冲区，消费者将数据从缓冲区取出，一次取一个，不允许两者对缓冲区同时操作。</p>
<p>假设缓冲区的结构是一个线性表。</p>
<p>采用01信号灯和无线缓冲来解决生产者/消费者问题的（<strong>错误</strong>）方案</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* program producer&amp;consumer */</span></span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">//记录缓冲区中“产品”的个数 n = in - out</span></span><br><span class="line">binary_semaphore s = <span class="number">1</span>, delay = <span class="number">0</span>; <span class="comment">//采用delay用于在缓冲区为0的时候迫使消费者等待</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWaitB(s); <span class="comment">//生产者可以在任何时候向缓冲区放入生产的数据</span></span><br><span class="line">       	append();</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) semSignalB(delay); <span class="comment">//n = 1, 之前缓冲区为0，唤醒消费者</span></span><br><span class="line">        semSignalB(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    semWaitB(delay); <span class="comment">//等待第一个可以“消费”的数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(B); </span><br><span class="line">        take();</span><br><span class="line">        n--;</span><br><span class="line">        semSignalB(B);</span><br><span class="line">        consume();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) semWaitB(delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    parbegin(producer, consumer);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">semWait(B); <span class="comment">//消费者消费完所有的数据后，需要重置delay信号，在生产者未产生出新的数据前等待</span></span><br><span class="line">		   <span class="comment">//就是 if(n == 0) semWaitB(delay); 语句的作用，但是实际上并没有执行该语句，导致消费者消费了不存在的数据</span></span><br><span class="line">take();</span><br><span class="line">n--;</span><br><span class="line">semSignalB(B);</span><br></pre></td></tr></table></figure>

<p>原因是生产者在消费者对n再次判断之前对n进行了加1操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">n++;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) semSignalB(delay); <span class="comment">//误以为是放入的第一个数据，其实是剩余的最后一个数据 </span></span><br></pre></td></tr></table></figure>

<p>再次调用了semSignal(delay)向delay信号灯发送了信号，而在这之前没有与之配对的semWait(delay)调用。</p>
<p>以下是正确方案</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* program producer&amp;consumer */</span></span><br><span class="line"><span class="keyword">int</span> n; </span><br><span class="line">binary_semaphore s = <span class="number">1</span>, delay = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWaitB(s); </span><br><span class="line">       	append(); </span><br><span class="line">        n++; </span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) semSignalB(delay); </span><br><span class="line">        semSignalB(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m; <span class="comment">/* a local variable */</span></span><br><span class="line">    semWaitB(delay); </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(B); </span><br><span class="line">        take(); </span><br><span class="line">        n--; </span><br><span class="line">        m = n;</span><br><span class="line">        semSignalB(B);</span><br><span class="line">        consume();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) semWaitB(delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    parbegin(producer, consumer);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用<code>信号灯和无线缓冲</code>来解决生产者/消费者问题的方案</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* program producer&amp;consumer */</span></span><br><span class="line">semphore n = <span class="number">0</span>, s = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWait(s);</span><br><span class="line">        append();</span><br><span class="line">        semSignal(s); <span class="comment">//生产者的semSignal(s)和semSignal(n)对换，将导致生产者在临界区内对n信号灯进行semSignal操作，不会有不好的影响</span></span><br><span class="line">        semSignal(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            semWait(n);</span><br><span class="line">            semWait(s); <span class="comment">//如果将semWait(s)与semWait(n)对换的话，如果n为0，缓冲区为空那么会阻塞在信号灯n上，同时生产者的执行也被阻塞，导致死锁。</span></span><br><span class="line">            take();</span><br><span class="line">            semSignal(s);</span><br><span class="line">            consume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parbegin (producer, consumer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后考虑实际情况，当缓冲区有限的时候，将缓冲区设置为一个环形的结构，指针的值为对缓冲区大小取模的值，并且考虑以下的阻塞唤醒关系</p>
<table>
<thead>
<tr>
<th align="center">阻塞时机</th>
<th align="center">唤醒时机</th>
</tr>
</thead>
<tbody><tr>
<td align="center">生产者：往满的缓冲区中放数据</td>
<td align="center">消费者：数据被放入</td>
</tr>
<tr>
<td align="center">消费者：从空的缓冲区中区数据</td>
<td align="center">生产者：数据被取出</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* program boundedBuffer */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sizeofbuffer = <span class="comment">/* buffer size */</span>;</span><br><span class="line">semaphore s = <span class="number">1</span>, n = <span class="number">0</span>, e = sizeofbuffer; <span class="comment">//用信号灯e来代表缓冲区的大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWait(e);</span><br><span class="line">        semWait(s);</span><br><span class="line">        append();</span><br><span class="line">        semSignal(s);</span><br><span class="line">        semSignal(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(n);</span><br><span class="line">        semWait(s);</span><br><span class="line">        take();</span><br><span class="line">        semSignal(s);</span><br><span class="line">        semSignal(e);</span><br><span class="line">        consume();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parbegin( producer, consumer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、信号灯的实现"><a href="#3、信号灯的实现" class="headerlink" title="3、信号灯的实现"></a>3、信号灯的实现</h5><p>比较和替换指令实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">semWait(s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(compare_and_swap(s.flag, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    	<span class="comment">/* do nothing */</span>;</span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* place this process in s.queue */</span>;</span><br><span class="line">        <span class="comment">/* block this process(must also set s.flag to 0) */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">semSignal(s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(compare_and_swap(s.flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        <span class="comment">/* do nothing */</span>;</span><br><span class="line">    s.count++;</span><br><span class="line">   	<span class="keyword">if</span>(s.count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* remove a process in form s.queue */</span>;</span><br><span class="line">        <span class="comment">/* place a process P on ready list */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中断实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">semWait(s)</span><br><span class="line">&#123;</span><br><span class="line">    inhibit interrupts;</span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* place this process in s.queue */</span>;</span><br><span class="line">        <span class="comment">/* block this process and allow interrupts */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        allow interrupts;</span><br><span class="line">&#125;</span><br><span class="line">semSignal(s)</span><br><span class="line">&#123;</span><br><span class="line">    inhibit interrupts;</span><br><span class="line">    s.count++;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* remove a process P from s.queue */</span>;</span><br><span class="line">        <span class="comment">/* place process P on ready list */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    allow interrupts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="三、管程-Monitor"><a href="#三、管程-Monitor" class="headerlink" title="三、管程(Monitor)"></a>三、管程(Monitor)</h3><hr>
<p>采用信号灯的方式实现正确的程序并不容易，因为semWait和semSignal操作分布于操作系统的各个地方，从而很难看到这些信号灯操作的整体效果所导致的。</p>
<p><code>管程</code> 的提出就是希望设计一种程序设计语言，它能够提供和信号灯相同的功能且易于控制。</p>
<h5 id="1、管程和信号"><a href="#1、管程和信号" class="headerlink" title="1、管程和信号"></a>1、管程和信号</h5><p>管程可以看作是包含了一个或者多个函数，一个初始化过程，以及本地数据的软件模块。主要特征如下</p>
<ul>
<li>本地数据只能够被管程的内部函数所访问，外部函数无法 访问其本地</li>
<li>进程只能通过调用管程自己定义的函数来进入管程</li>
<li>在管程内执行的进程一次只能有一个；当管程被占用，其他试图进入的进程将被阻塞，等待管程重新可用后才能进入。</li>
</ul>
<p>管程定义了一个同步工具用来更好地支持并发处理。当某一个进入管程的进程因为不满足某个执行条件而必须被阻塞的时候，那么便需要某种机制(同步工具)使得该进程在被阻塞后释放管程，之后在其满足运行条件后，该进程能够重新回到管程中继续执行。</p>
<p>管程采用了 <code>条件变量(Condition Variables)</code> 方法来实现这种同步工具，并且只能用以下两个函数来访问。</p>
<ul>
<li>cwait(c)：将调用该函数访问条件变量c的进程阻塞，并且释放管程给其他的进程使用。</li>
<li>csignal(c)：继续执行之前因为调用cwait函数访问条件变量c而阻塞的进程。如果这类进程有多个，那么选择其中之一；如果没有，则不做任何操作。</li>
</ul>
<p>采用管程来解决有限缓冲区生产者/消费者问题的方案</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* program production&amp;consumer */</span></span><br><span class="line">monitor bunderbuffer;</span><br><span class="line"><span class="keyword">char</span> buffer [N];</span><br><span class="line"><span class="keyword">int</span> nextin, next out;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">cond notfull, notempty;</span><br><span class="line"><span class="comment">//notfull: 缓冲区有剩余空间时为真 notempty：缓冲区中有有效计算结果时为真</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count == N) cwait(notfull); <span class="comment">// buffer满了，要避免overflow</span></span><br><span class="line">    buffer[nextin] = x;</span><br><span class="line">    nextin = (nextin + <span class="number">1</span>) % N;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">/* one more item in buffer */</span></span><br><span class="line">    csignal(notempty); <span class="comment">// resume any waiting consumer</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>) cwait(notempty); <span class="comment">//buffer空，避免underflow</span></span><br><span class="line">    x = buffer[nextout];</span><br><span class="line">    nextout = (nextout + <span class="number">1</span>) % N;</span><br><span class="line">    count--;</span><br><span class="line">    csignal(notfull); <span class="comment">//resume any waiting producer</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    nextin = <span class="number">0</span>; nextout = <span class="number">0</span>; count = <span class="number">0</span>; <span class="comment">//buffer 初始化为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        produce(x);</span><br><span class="line">        append(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        take(x);</span><br><span class="line">        consume(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parbegin( producer, consumer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>管程的真正优势就在于它所有的操作都被限制在管程内部，这样就更容易检查设计是否正确。</p>
<h5 id="2、采用通知和广播的管程模型"><a href="#2、采用通知和广播的管程模型" class="headerlink" title="2、采用通知和广播的管程模型"></a>2、采用通知和广播的管程模型</h5><p>在 <code>Mesa</code> 语言中，csignal原语被cnotify原语替代，当管程调用了cnotify(x)原语后，它将导致条件变量x的等待队列收到通知，且调用cnotify(x)原语的进程将继续执行。</p>
<p>用while语句替换if语句，这样就保证了条件变量的重新检测。同时避免了进程的额外切换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(count == N) cwait(notfull); <span class="comment">/* buffer is full avoid overflow */</span></span><br><span class="line">    buffer[nextin] = x;</span><br><span class="line">    nextin = &#123;nextin + <span class="number">1</span>&#125; % N;</span><br><span class="line">    count++;</span><br><span class="line">    cnotify(notempty); <span class="comment">/* notify any waiting consumer */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(count == <span class="number">0</span>) cwait(notempty); <span class="comment">/* buffer is empty; avoid underflow */</span></span><br><span class="line">    x = buffer[nextout];</span><br><span class="line">    nextout = (nextout + <span class="number">1</span>) % N; <span class="comment">/* one fewer item in buffer */</span></span><br><span class="line">    cnotify[notfull]; <span class="comment">/* notify ant waiting producer */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四、消息通信"><a href="#四、消息通信" class="headerlink" title="四、消息通信"></a>四、消息通信</h3><hr>
<p>一般来说，进程的交互和协作需要两个基本元素：同步和通信。同步用于进程的互斥，通信则用于进程间的协作。 <code> 消息通信</code> 就能提供这两个基本元素，而且应用范围很广。不同的操作系统对消息通信的实现的细节上有所出入。以下内容讨论其实现的共性的部分。</p>
<p>消息通信的基本形式为以下两个原语：</p>
<ul>
<li>send(destination, message)</li>
<li>receive(source, message)</li>
</ul>
<p>采用send原语，一个进程可以将消息发送给另一个进程(destination)；采用receive原语，一个进程可以接收来自消息源的消息。</p>
<h5 id="1、同步"><a href="#1、同步" class="headerlink" title="1、同步"></a>1、同步</h5><p>无论消息发送还是消息接受都有阻塞和非阻塞两种可能。在具体的系统设计中有以下3中组合。</p>
<ul>
<li><p>发送端阻塞，接收端阻塞</p>
<p>两端都阻塞，消息被接收后再将两端唤醒。这一组合又被称为交汇点(rendzvous)方案，常被用于要求进程强行同步通信的场合</p>
</li>
<li><p>发送端不阻塞，接收端阻塞</p>
<p>发送端在发送完消息后继续执行，而接收端必须阻塞，直到接收到消息后才被唤醒。这一方案是是被最广泛应用的，能够最快的将消息发送给多个目的进程，而接收端必须等待消息到达后才能做有用的工作。</p>
</li>
<li><p>发送端不阻塞，接收端阻塞</p>
</li>
</ul>
<h5 id="2、互斥的实现"><a href="#2、互斥的实现" class="headerlink" title="2、互斥的实现"></a>2、互斥的实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* program mutualexclusion */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="comment">/* number of process */</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    message msg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        receive(box, msg); <span class="comment">// 任何希望进入临界区的进程都必须先获得一个消息，如果邮箱为空</span></span><br><span class="line">        <span class="comment">/* critical section */</span>;</span><br><span class="line">        send(box, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">create <span class="title">mailbox</span><span class="params">(box)</span></span>; <span class="comment">//初始化阶段，邮箱中只存放了一个内容为null的消息</span></span><br><span class="line">    send(box, null);</span><br><span class="line">    parbegin( p(<span class="number">1</span>), p(<span class="number">2</span>), p(<span class="number">3</span>)...... );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果并发地调用消息接收原语，那么就会有：</p>
<ul>
<li>如果邮箱中有一个消息，该消息将被一个进程接收，而其他的进程都将阻塞</li>
<li>如果邮箱中没有消息，所有的进程都将被阻塞。而当之后有一个消息传入邮箱后，只有一个等待态的进程被唤醒，并获得该消息</li>
</ul>
<p>采用消息通信来解决有限缓冲的生产者/消费者问题的方案</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span></span><br><span class="line">    capacity = <span class="comment">/* buffering capacity */</span>;</span><br><span class="line">	null = <span class="comment">/* empty message */</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    message pmsg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        receive(mayproduce, pmsg); <span class="comment">//生产者接收到生产的消息</span></span><br><span class="line">        pmsg = produce(); <span class="comment">//pmsg 表示生产完成,等同于完成临界区</span></span><br><span class="line">        send(mayconsume, pmsg);  <span class="comment">//向消费者发送发消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    message cmsg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        receive(mayproduce, cmsg); <span class="comment">//从mayproduce接收到有数据的消息cmsg</span></span><br><span class="line">        consume(cmsg); <span class="comment">//进入消费的临界区</span></span><br><span class="line">        send(mayproduce, null); <span class="comment">//消费完成，向mayproduce发送空消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    create_mailbox(mayproduce); <span class="comment">//该方案设计了两个邮箱</span></span><br><span class="line">    create_mailbox(mayconsume);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; capacity; i++)	send(mayproduce, null);</span><br><span class="line">    parbegin( producer, consumer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方案非常灵活，可以容纳多个生产者以及多个消费者同时工作。另外，该方案也可以在分布式系统中实现有限缓冲的生产者消费者问题，其中生产者、消费者以及两个邮箱都可以放置在不同的机器上面。</p>
<h3 id="五、读者-写者问题"><a href="#五、读者-写者问题" class="headerlink" title="五、读者/写者问题"></a>五、读者/写者问题</h3><hr>
<p>读者/写者问题是另一个经典的同步和并发问题，描述如下：</p>
<p>有一块共享的数据区域(该区域可以是一个文件，一块内存或处理器中的一组寄存器)，有一组进程(读者)，它们对该共享数据区的访问都是只读的，另外还有一组进程(写者)，它们对该共享数据的访问只是只写。访问规则如下：</p>
<ol>
<li>可以有任意多个读者同时读取数据区的内容；</li>
<li>一次只有一个写者允许向数据区中写；</li>
<li>写者在向数据区中写时，不允许读者同时读取；</li>
</ol>
<p>读者对共享数据区的访问不是独占的，但写者对共享数据区的访问是独占的，无论读者或者写者都不允许同时访问该共享数据区。</p>
<h5 id="1、读者优先"><a href="#1、读者优先" class="headerlink" title="1、读者优先"></a>1、读者优先</h5><p>采用信号灯解决读者/写者问题的方案：读者优先</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* program readers&amp;writers */</span></span><br><span class="line"><span class="keyword">int</span> readcount;</span><br><span class="line">semaphore x = <span class="number">1</span>, wsem = <span class="number">1</span>; <span class="comment">//信号灯wsem用于互斥访问。当有写者在访问共享数据时，不允许读者或者写者同时访问共享数据。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(x);</span><br><span class="line">        readcount++;</span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">1</span>) <span class="comment">//为了使多个读者能够同时访问共享数据而且不会于写者冲突，该方案要求第一个读者必须等待wsem</span></span><br><span class="line">   	    	semWait(wsem); <span class="comment">//信号灯，但是后续到达的读者可以不用等待到达的信号灯就直接进入临界区</span></span><br><span class="line">        semSignal(x);</span><br><span class="line">        READUNIT();</span><br><span class="line">        semWait(x);</span><br><span class="line">        readcount--;</span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">0</span>)</span><br><span class="line">            semSignal(wsem);</span><br><span class="line">        semSignal(x); <span class="comment">// 信号灯x用于保证对readcount的更新操作的正确执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(wsem);</span><br><span class="line">        WRITEUNIT();</span><br><span class="line">        semSignal(wsem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    readcount = <span class="number">0</span>;</span><br><span class="line">    parbegin( reader, writer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方案的最大问题是如果读者过多的话会造成写者的饥饿问题。</p>
<p>采用写者优先方案可以解决这个问题</p>
<h5 id="2、写者优先"><a href="#2、写者优先" class="headerlink" title="2、写者优先"></a>2、写者优先</h5><ul>
<li>只要写者申请访问数据区时，阻止所有读者对共享数据的访问；</li>
<li>全局变量writecount，用于控制对rsem的设置</li>
<li>信号灯y，用于控制对writecount的更新</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> readcount, writecount, semphore x = <span class="number">1</span>, y = <span class="number">1</span>, z = <span class="number">1</span>, wsem = <span class="number">1</span>, rsem = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(z);</span><br><span class="line">        	semWait(rsem); <span class="comment">// 写者对rsem进行了设置，一个读者在rsem上等待，其他读者全在z上等待</span></span><br><span class="line">        		semWait(x);</span><br><span class="line">        			readcount++;</span><br><span class="line">        			<span class="keyword">if</span>(readcount == <span class="number">1</span>) <span class="comment">//新的方案只允许一个读者在rsem上等待，后续到达的读者必须在z上等待</span></span><br><span class="line">                 		semWait(wsem); </span><br><span class="line">        		semSignal(x);</span><br><span class="line">        	semSignal(rsem);</span><br><span class="line">        semSignal(z);</span><br><span class="line">        READUNIT();</span><br><span class="line">        semWait(x);</span><br><span class="line">        	readcount--;</span><br><span class="line">        	<span class="keyword">if</span>(readcount == <span class="number">0</span>) semSignal(wsem);</span><br><span class="line">        semSignal(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(y);</span><br><span class="line">        	writecount++;</span><br><span class="line">        	<span class="keyword">if</span>(writecount == <span class="number">1</span>) </span><br><span class="line">                semWait(rsem);</span><br><span class="line">        semSignal(y);</span><br><span class="line">        semWait(wsem); <span class="comment">// 写者全在wsem上排队</span></span><br><span class="line">        WRITEUNIT();</span><br><span class="line">        semSignal(wsem);</span><br><span class="line">        semWait(y);</span><br><span class="line">        	writecount--;</span><br><span class="line">        	<span class="keyword">if</span>(writecount == <span class="number">0</span>)		semSignal (rsem); <span class="comment">//</span></span><br><span class="line">        semSignal(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    readcount = writecount = <span class="number">0</span>;</span><br><span class="line">    parbegin( reader, writer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所示方案中进程队列情况</p>
<table>
<thead>
<tr>
<th align="center">读写者情况</th>
<th align="center">信号灯设置以及排队情况</th>
</tr>
</thead>
<tbody><tr>
<td align="center">系统中只有读者</td>
<td align="center">1、wsem设置  2、无排队</td>
</tr>
<tr>
<td align="center">系统中只有写者</td>
<td align="center">1、wsem和rsem设置  2、写者在wsem上排队</td>
</tr>
<tr>
<td align="center">有读者和写者，读者在前</td>
<td align="center">1、wsem被读者设置  2、rsem被写者设置  3、所有写者在wsem上排队</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">4、一个读者在resm上排队  5、其他读者在z上排队</td>
</tr>
<tr>
<td align="center">有读者和写者，写者在前</td>
<td align="center">1、wsem被写者设置  2、rsem被写者设置  3、写者在wsem上排队</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">4、一个读者在rsem上排队  5、其他读者在z上排队</td>
</tr>
</tbody></table>
<h5 id="3、采用消息通信来解决读者-写者问题-写者优先"><a href="#3、采用消息通信来解决读者-写者问题-写者优先" class="headerlink" title="3、采用消息通信来解决读者/写者问题(写者优先)"></a>3、采用消息通信来解决读者/写者问题(写者优先)</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    message rmsg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        send(readrequest, rmsg);</span><br><span class="line">        receive(mbox[i], rmsg);</span><br><span class="line">        READUNIT();</span><br><span class="line">        send(finished, rmsg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">(<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    message rmsg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        send(writerequest, rmsg);</span><br><span class="line">        receive(mbox[j], rmsg);</span><br><span class="line">        WRITEUNIT();</span><br><span class="line">        rmsg = j;</span><br><span class="line">        send(finished, rmsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">controller</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">0</span>) <span class="comment">// count&gt;0，说明没有写者在等待，且有读者在临界区。此时先处理finish消息，然后是写请求，最后是读者请求</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!empty(finshed))</span><br><span class="line">            &#123;</span><br><span class="line">                recevie(finished, msg);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!empty(writerequest))</span><br><span class="line">            &#123;</span><br><span class="line">                receive(writerequest, msg);</span><br><span class="line">                write_id = msg.id;</span><br><span class="line">                count = count - <span class="number">100</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!empty(readrequest))</span><br><span class="line">            &#123;</span><br><span class="line">                receive(readrequest, msg);</span><br><span class="line">                count--;</span><br><span class="line">                send(msg.id, <span class="string">&quot;OK&quot;</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) <span class="comment">//count=0，说明收到了写者的请求，允许写者进入临界区，并且等待“finish”消息</span></span><br><span class="line">        &#123;</span><br><span class="line">            send (write_id, <span class="string">&quot;OK&quot;</span>);</span><br><span class="line">            receive(finished, msg);</span><br><span class="line">            count = <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; <span class="number">0</span>) <span class="comment">//count&lt;0，说明收到了写者的请求，但此时有读者正在临界区中。此时，就只处理“finish”消息</span></span><br><span class="line">        &#123;</span><br><span class="line">            receive(finshed, msg);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; <strong>fine~~</strong></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
