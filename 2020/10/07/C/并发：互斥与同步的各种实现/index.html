<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>并发：互斥与同步的各种实现 | WuTai's Blog</title><meta name="keywords" content="学习笔记,操作系统"><meta name="author" content="WuTai"><meta name="copyright" content="WuTai"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="并发：互斥与同步的各种实现 在操作系统中，核心的设计问题在与进程和线程的管理。而在对于在多道程序处理, 多处理器环境，分布式系统等相关领域的应用，以及操作系统设计的本身，最基础的问题就是并发(Concurrency)。 由于篇幅问题，在这里只讨论各种实现，不对其各种方案的优劣进行过多讨论，感兴趣的可以参考 《操作系统 精髓与设计原理》 一、互斥的硬件支持方案 1、关中断1234567while(t">
<meta property="og:type" content="article">
<meta property="og:title" content="并发：互斥与同步的各种实现">
<meta property="og:url" content="http://example.com/2020/10/07/C/%E5%B9%B6%E5%8F%91%EF%BC%9A%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="WuTai&#39;s Blog">
<meta property="og:description" content="并发：互斥与同步的各种实现 在操作系统中，核心的设计问题在与进程和线程的管理。而在对于在多道程序处理, 多处理器环境，分布式系统等相关领域的应用，以及操作系统设计的本身，最基础的问题就是并发(Concurrency)。 由于篇幅问题，在这里只讨论各种实现，不对其各种方案的优劣进行过多讨论，感兴趣的可以参考 《操作系统 精髓与设计原理》 一、互斥的硬件支持方案 1、关中断1234567while(t">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://lwth6g.sn.files.1drv.com/y4pXnYO2S7NHiAUeFmVQHKfem6mCardrridBn_Y2rH8ZdYvdKzzh4ZB5YYgXuK6gtjYJqJaIiwHxZYMZmiiYzvBJdpdRfP6Z1A543oQ5QmsnfZVw4KjFnn3vXPD_1I6eelmx20Y_rA-YQItQXESfdf3YSzFKBpxIV6drkY7FfHkgKMOPpk5pCiY7OijCsXLL49I3gTCP3zcZgieBRE7Qn5LCw/hui-7.png?psid=1">
<meta property="article:published_time" content="2020-10-07T15:21:44.913Z">
<meta property="article:modified_time" content="2020-10-29T07:14:03.952Z">
<meta property="article:author" content="WuTai">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lwth6g.sn.files.1drv.com/y4pXnYO2S7NHiAUeFmVQHKfem6mCardrridBn_Y2rH8ZdYvdKzzh4ZB5YYgXuK6gtjYJqJaIiwHxZYMZmiiYzvBJdpdRfP6Z1A543oQ5QmsnfZVw4KjFnn3vXPD_1I6eelmx20Y_rA-YQItQXESfdf3YSzFKBpxIV6drkY7FfHkgKMOPpk5pCiY7OijCsXLL49I3gTCP3zcZgieBRE7Qn5LCw/hui-7.png?psid=1"><link rel="shortcut icon" href="/myblog/img/favicon.png"><link rel="canonical" href="http://example.com/2020/10/07/C/%E5%B9%B6%E5%8F%91%EF%BC%9A%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/myblog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/myblog/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-10-29 15:14:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {
  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }

  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }
})()</script><meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/myblog/atom.xml" title="WuTai's Blog" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/myblog/img/richang-1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/myblog/archives/"><div class="headline">Articles</div><div class="length_num">6</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/myblog/tags/"><div class="headline">Tags</div><div class="length_num">9</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/myblog/categories/"><div class="headline">Categories</div><div class="length_num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/myblog/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/myblog/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/myblog/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/myblog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/myblog/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/myblog/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/myblog/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/myblog/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%EF%BC%9A%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0"><span class="toc-text">并发：互斥与同步的各种实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BA%92%E6%96%A5%E7%9A%84%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81%E6%96%B9%E6%A1%88"><span class="toc-text">一、互斥的硬件支持方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%85%B3%E4%B8%AD%E6%96%AD"><span class="toc-text">1、关中断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E7%89%B9%E6%AE%8A%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-text">2、特殊机器指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BF%A1%E5%8F%B7%E7%81%AF-Semaphore"><span class="toc-text">二、信号灯(Semaphore)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BA%92%E6%96%A5%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">1、互斥的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">2、生产者&#x2F;消费者问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E4%BF%A1%E5%8F%B7%E7%81%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">3、信号灯的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%AE%A1%E7%A8%8B-Monitor"><span class="toc-text">三、管程(Monitor)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E7%AE%A1%E7%A8%8B%E5%92%8C%E4%BF%A1%E5%8F%B7"><span class="toc-text">1、管程和信号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E9%87%87%E7%94%A8%E9%80%9A%E7%9F%A5%E5%92%8C%E5%B9%BF%E6%92%AD%E7%9A%84%E7%AE%A1%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">2、采用通知和广播的管程模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1"><span class="toc-text">四、消息通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%90%8C%E6%AD%A5"><span class="toc-text">1、同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E4%BA%92%E6%96%A5%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">2、互斥的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">五、读者&#x2F;写者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E8%AF%BB%E8%80%85%E4%BC%98%E5%85%88"><span class="toc-text">1、读者优先</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%86%99%E8%80%85%E4%BC%98%E5%85%88"><span class="toc-text">2、写者优先</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E9%87%87%E7%94%A8%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%E6%9D%A5%E8%A7%A3%E5%86%B3%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98-%E5%86%99%E8%80%85%E4%BC%98%E5%85%88"><span class="toc-text">3、采用消息通信来解决读者&#x2F;写者问题(写者优先)</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://lwth6g.sn.files.1drv.com/y4pXnYO2S7NHiAUeFmVQHKfem6mCardrridBn_Y2rH8ZdYvdKzzh4ZB5YYgXuK6gtjYJqJaIiwHxZYMZmiiYzvBJdpdRfP6Z1A543oQ5QmsnfZVw4KjFnn3vXPD_1I6eelmx20Y_rA-YQItQXESfdf3YSzFKBpxIV6drkY7FfHkgKMOPpk5pCiY7OijCsXLL49I3gTCP3zcZgieBRE7Qn5LCw/hui-7.png?psid=1)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/myblog/">WuTai's Blog</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/myblog/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/myblog/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/myblog/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/myblog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/myblog/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/myblog/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/myblog/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/myblog/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">并发：互斥与同步的各种实现</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-10-07T15:21:44.913Z" title="Created 2020-10-07 23:21:44">2020-10-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2020-10-29T07:14:03.952Z" title="Updated 2020-10-29 15:14:03">2020-10-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/myblog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="并发：互斥与同步的各种实现"><a href="#并发：互斥与同步的各种实现" class="headerlink" title="并发：互斥与同步的各种实现"></a>并发：互斥与同步的各种实现</h1><hr>
<p>在操作系统中，核心的设计问题在与进程和线程的管理。而在对于在<code>多道程序处理</code>, <code>多处理器环境</code>，<code>分布式系统</code>等相关领域的应用，以及操作系统设计的本身，最基础的问题就是并发(Concurrency)。</p>
<p><em>由于篇幅问题，在这里只讨论各种实现，不对其各种方案的优劣进行过多讨论，感兴趣的可以参考 《操作系统 精髓与设计原理》</em></p>
<h3 id="一、互斥的硬件支持方案"><a href="#一、互斥的硬件支持方案" class="headerlink" title="一、互斥的硬件支持方案"></a>一、互斥的硬件支持方案</h3><hr>
<h5 id="1、关中断"><a href="#1、关中断" class="headerlink" title="1、关中断"></a>1、关中断</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* disable interrupts */</span></span><br><span class="line">    <span class="comment">/* critical section */</span>  临界区执行</span><br><span class="line">    <span class="comment">/* enable interrupts */</span></span><br><span class="line">    <span class="comment">/* remainder */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过采用操作系统提供的原语的方式可以使临界区的执行不可以被打断，达到了互斥的效果。</p>
<p>但是该方案有两个明显缺陷：</p>
<ul>
<li>由于临界区的执行，导致处理器不能随意穿插执行进程，导致处理器效率明显降低</li>
<li>该方案不能直接用于多处理器系统中，因为在同一时间里，可能会有多个进程在同时进行，只对一个进程进行关中段不一定能保证互斥</li>
</ul>
<h5 id="2、特殊机器指令"><a href="#2、特殊机器指令" class="headerlink" title="2、特殊机器指令"></a>2、特殊机器指令</h5><p>当处理器访问某一内存地址的时候，为了通过硬件手段避免其他处理器对该内存地址的访问，设计了几条机器指令来实现两个或两个以上动作的原子性。</p>
<p>1&gt; 比较替换指令</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span><span class="params">(<span class="keyword">int</span> *word, <span class="keyword">int</span> testVal, <span class="keyword">int</span> newVal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldVal;</span><br><span class="line">    oldVal = *word;</span><br><span class="line">    <span class="keyword">if</span>(oldVal == testVal)</span><br><span class="line">    &#123;</span><br><span class="line">        *word = testVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125; <span class="comment">// 这个函数的操作不可被干扰或者打断，具有原子性。</span></span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* program mutualexclusion */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="comment">/* number of process */</span> 进程的数量</span><br><span class="line"><span class="keyword">int</span> bolt; 共享变量初值为 <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(compare_and_swap(bolt, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>) 只有当发现bolt为<span class="number">0</span>的进程才能进入临界区，而其他的进程不停的比较替换申请进入临界区</span><br><span class="line">            								  会造成忙等现象</span><br><span class="line">            <span class="comment">/* do nothing */</span>;</span><br><span class="line">        <span class="comment">/* critical section */</span>;</span><br><span class="line">        bolt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* remainder */</span>; bolt被置零后其他进程才有一个机会将bolt置<span class="number">1</span>进入临界区</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bolt = <span class="number">0</span>;</span><br><span class="line">    parbeging( p(<span class="number">1</span>), p(<span class="number">2</span>), p(<span class="number">3</span>) ......);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2&gt; 交换指令</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> *<span class="keyword">register</span>, <span class="keyword">int</span> *memory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = *memory;</span><br><span class="line">    *memory = *<span class="keyword">register</span>;</span><br><span class="line">    *<span class="keyword">register</span> = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* program mutualexclusin */</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> n = <span class="comment">/* number of process */</span>;</span><br><span class="line"><span class="keyword">int</span> bolt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> keyi = <span class="number">1</span>;</span><br><span class="line">        do exchange(&amp;key1, &amp;bolt) 如果交换后key = 1, 那么就进入临界区，否则在临界区外忙等</span><br><span class="line">        <span class="keyword">while</span>(keyi != <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* critical section */</span></span><br><span class="line">        bolt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* remainder */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bolt = <span class="number">0</span>;</span><br><span class="line">    parbegin( p(<span class="number">1</span>), p(<span class="number">2</span>), p(<span class="number">3</span>) ......);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对于共享变量和局部变量的交换方式，以下的表达式始终成立<br>$$<br>bolt + \sum_ikey_{i} = 1<br>$$<br>bolt = 0 没有进程进入临界区，blot = 1 有且只有一个进程在临界区</p>
<h3 id="二、信号灯-Semaphore"><a href="#二、信号灯-Semaphore" class="headerlink" title="二、信号灯(Semaphore)"></a>二、信号灯(Semaphore)</h3><hr>
<p>信号灯是一个特殊的整型变量。向信号灯 <code>s</code> 发送信号，进程可以调用 <code>semSignal(s)</code> 原语。从信号灯处接收信号，进程可以调用<code>semWait(s)</code> 原语。如果进程打算接受消息的时候，消息尚未到达，则该进程必须在信号灯上等待。因此对信号灯做以下定义：</p>
<ol>
<li><strong>信号灯初值为非负整数。</strong></li>
<li><strong>semWait 操作将信号灯的值减1。如果其值为负数，调用semWait的进程执行将被阻塞。否则进程将继续执行。</strong></li>
<li><strong>semSignal操作将信号灯的值加1。如果之后其值小于等于0，则进程唤醒在该信号灯上等待的一个进程，并继续自己的执行。</strong></li>
</ol>
<p>（除了以上的3种操作以外不允许对信号灯做其他的操作）</p>
<p>信号灯的定义和操作的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    queueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semWait</span><span class="params">(semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="keyword">if</span>(count &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/* place this process in s.queue */</span>;</span><br><span class="line">        <span class="comment">/* block this process */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semSignal</span><span class="params">(semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.count++;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/* remove a process P from s.queue */</span>;</span><br><span class="line">        <span class="comment">/* palce process P on ready list */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>01信号灯，01信号灯只有两个取值：0和1，其操作原语定义如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_semaphore</span>&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;zero, oen&#125; value; 初值可以取<span class="number">0</span>或<span class="number">1</span></span><br><span class="line">    queueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semWaitB</span><span class="params">(binary_semaphore s)</span> <span class="comment">//检测信号灯的取值，如果值为0，执行semWaitB操作的进程将被阻塞。如果值为1，信号灯的值将被置0，并且进程继续执行</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.value == one)</span><br><span class="line">        s.value = zero;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">/* place this process in s.queue */</span></span><br><span class="line">        <span class="comment">/* block this process */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> semSignalB(semaphore s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">queue</span> is empty()) <span class="comment">//检测是否有进程被阻塞在信号灯上，如果有将唤醒一个被阻塞的进程。如果没有则将信号灯的值置1。</span></span><br><span class="line">        s.value = one;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">/* remove a process P from s.queue */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1、互斥的实现"><a href="#1、互斥的实现" class="headerlink" title="1、互斥的实现"></a>1、互斥的实现</h5><p>采用信号灯实现互斥的例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* program mutualexclusion */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="comment">/* number of processes */</span>;</span><br><span class="line">semaphore s = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(s); <span class="comment">//进程在进入critical section前调用semWait(s)原语，如果s&lt;0,进程阻塞。如果s=1, s-1后，进程进入临界区访问公共资源</span></span><br><span class="line">        <span class="comment">/* critical section */</span>;</span><br><span class="line">        semSignal(s); <span class="comment">//最开始进入的进程执行完临界区后将信号灯的值加1，并将信号灯等待队列上的一个等待进程唤醒，并置为就绪态</span></span><br><span class="line">        <span class="comment">/* remainder */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parbegin( p(<span class="number">1</span>), p(<span class="number">2</span>), p(<span class="number">3</span>)...... );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于以上的实现，信号灯的取值 <code>s.count</code> 可以这样理解：</p>
<ul>
<li>s.count &gt;= 0：能够通过调用semWait(s)原语，而无需阻塞就能进入临界区的进程个数。信号灯的这一特性，还能用于实现进程协作。</li>
<li>s.count &lt; 0：其绝对值就是在s.queue上等待信号灯的进程的个数。</li>
</ul>
<h5 id="2、生产者-消费者问题"><a href="#2、生产者-消费者问题" class="headerlink" title="2、生产者/消费者问题"></a>2、生产者/消费者问题</h5><p>生产者生产数据放入缓冲区，消费者将数据从缓冲区取出，一次取一个，不允许两者对缓冲区同时操作。</p>
<p>假设缓冲区的结构是一个线性表。</p>
<p>采用01信号灯和无线缓冲来解决生产者/消费者问题的（<strong>错误</strong>）方案</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* program producer&amp;consumer */</span></span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">//记录缓冲区中“产品”的个数 n = in - out</span></span><br><span class="line">binary_semaphore s = <span class="number">1</span>, delay = <span class="number">0</span>; <span class="comment">//采用delay用于在缓冲区为0的时候迫使消费者等待</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWaitB(s); <span class="comment">//生产者可以在任何时候向缓冲区放入生产的数据</span></span><br><span class="line">       	append();</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) semSignalB(delay); <span class="comment">//n = 1, 之前缓冲区为0，唤醒消费者</span></span><br><span class="line">        semSignalB(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    semWaitB(delay); <span class="comment">//等待第一个可以“消费”的数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(B); </span><br><span class="line">        take();</span><br><span class="line">        n--;</span><br><span class="line">        semSignalB(B);</span><br><span class="line">        consume();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) semWaitB(delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    parbegin(producer, consumer);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">semWait(B); <span class="comment">//消费者消费完所有的数据后，需要重置delay信号，在生产者未产生出新的数据前等待</span></span><br><span class="line">		   <span class="comment">//就是 if(n == 0) semWaitB(delay); 语句的作用，但是实际上并没有执行该语句，导致消费者消费了不存在的数据</span></span><br><span class="line">take();</span><br><span class="line">n--;</span><br><span class="line">semSignalB(B);</span><br></pre></td></tr></table></figure>

<p>原因是生产者在消费者对n再次判断之前对n进行了加1操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n++;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) semSignalB(delay); <span class="comment">//误以为是放入的第一个数据，其实是剩余的最后一个数据 </span></span><br></pre></td></tr></table></figure>

<p>再次调用了semSignal(delay)向delay信号灯发送了信号，而在这之前没有与之配对的semWait(delay)调用。</p>
<p>以下是正确方案</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* program producer&amp;consumer */</span></span><br><span class="line"><span class="keyword">int</span> n; </span><br><span class="line">binary_semaphore s = <span class="number">1</span>, delay = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWaitB(s); </span><br><span class="line">       	append(); </span><br><span class="line">        n++; </span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) semSignalB(delay); </span><br><span class="line">        semSignalB(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m; <span class="comment">/* a local variable */</span></span><br><span class="line">    semWaitB(delay); </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(B); </span><br><span class="line">        take(); </span><br><span class="line">        n--; </span><br><span class="line">        m = n;</span><br><span class="line">        semSignalB(B);</span><br><span class="line">        consume();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) semWaitB(delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    parbegin(producer, consumer);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用<code>信号灯和无线缓冲</code>来解决生产者/消费者问题的方案</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* program producer&amp;consumer */</span></span><br><span class="line">semphore n = <span class="number">0</span>, s = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWait(s);</span><br><span class="line">        append();</span><br><span class="line">        semSignal(s); <span class="comment">//生产者的semSignal(s)和semSignal(n)对换，将导致生产者在临界区内对n信号灯进行semSignal操作，不会有不好的影响</span></span><br><span class="line">        semSignal(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            semWait(n);</span><br><span class="line">            semWait(s); <span class="comment">//如果将semWait(s)与semWait(n)对换的话，如果n为0，缓冲区为空那么会阻塞在信号灯n上，同时生产者的执行也被阻塞，导致死锁。</span></span><br><span class="line">            take();</span><br><span class="line">            semSignal(s);</span><br><span class="line">            consume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parbegin (producer, consumer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后考虑实际情况，当缓冲区有限的时候，将缓冲区设置为一个环形的结构，指针的值为对缓冲区大小取模的值，并且考虑以下的阻塞唤醒关系</p>
<table>
<thead>
<tr>
<th align="center">阻塞时机</th>
<th align="center">唤醒时机</th>
</tr>
</thead>
<tbody><tr>
<td align="center">生产者：往满的缓冲区中放数据</td>
<td align="center">消费者：数据被放入</td>
</tr>
<tr>
<td align="center">消费者：从空的缓冲区中区数据</td>
<td align="center">生产者：数据被取出</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* program boundedBuffer */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sizeofbuffer = <span class="comment">/* buffer size */</span>;</span><br><span class="line">semaphore s = <span class="number">1</span>, n = <span class="number">0</span>, e = sizeofbuffer; <span class="comment">//用信号灯e来代表缓冲区的大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWait(e);</span><br><span class="line">        semWait(s);</span><br><span class="line">        append();</span><br><span class="line">        semSignal(s);</span><br><span class="line">        semSignal(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(n);</span><br><span class="line">        semWait(s);</span><br><span class="line">        take();</span><br><span class="line">        semSignal(s);</span><br><span class="line">        semSignal(e);</span><br><span class="line">        consume();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parbegin( producer, consumer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、信号灯的实现"><a href="#3、信号灯的实现" class="headerlink" title="3、信号灯的实现"></a>3、信号灯的实现</h5><p>比较和替换指令实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">semWait(s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(compare_and_swap(s.flag, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    	<span class="comment">/* do nothing */</span>;</span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* place this process in s.queue */</span>;</span><br><span class="line">        <span class="comment">/* block this process(must also set s.flag to 0) */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">semSignal(s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(compare_and_swap(s.flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        <span class="comment">/* do nothing */</span>;</span><br><span class="line">    s.count++;</span><br><span class="line">   	<span class="keyword">if</span>(s.count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* remove a process in form s.queue */</span>;</span><br><span class="line">        <span class="comment">/* place a process P on ready list */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中断实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">semWait(s)</span><br><span class="line">&#123;</span><br><span class="line">    inhibit interrupts;</span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* place this process in s.queue */</span>;</span><br><span class="line">        <span class="comment">/* block this process and allow interrupts */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        allow interrupts;</span><br><span class="line">&#125;</span><br><span class="line">semSignal(s)</span><br><span class="line">&#123;</span><br><span class="line">    inhibit interrupts;</span><br><span class="line">    s.count++;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* remove a process P from s.queue */</span>;</span><br><span class="line">        <span class="comment">/* place process P on ready list */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    allow interrupts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="三、管程-Monitor"><a href="#三、管程-Monitor" class="headerlink" title="三、管程(Monitor)"></a>三、管程(Monitor)</h3><hr>
<p>采用信号灯的方式实现正确的程序并不容易，因为semWait和semSignal操作分布于操作系统的各个地方，从而很难看到这些信号灯操作的整体效果所导致的。</p>
<p><code>管程</code> 的提出就是希望设计一种程序设计语言，它能够提供和信号灯相同的功能且易于控制。</p>
<h5 id="1、管程和信号"><a href="#1、管程和信号" class="headerlink" title="1、管程和信号"></a>1、管程和信号</h5><p>管程可以看作是包含了一个或者多个函数，一个初始化过程，以及本地数据的软件模块。主要特征如下</p>
<ul>
<li>本地数据只能够被管程的内部函数所访问，外部函数无法 访问其本地</li>
<li>进程只能通过调用管程自己定义的函数来进入管程</li>
<li>在管程内执行的进程一次只能有一个；当管程被占用，其他试图进入的进程将被阻塞，等待管程重新可用后才能进入。</li>
</ul>
<p>管程定义了一个同步工具用来更好地支持并发处理。当某一个进入管程的进程因为不满足某个执行条件而必须被阻塞的时候，那么便需要某种机制(同步工具)使得该进程在被阻塞后释放管程，之后在其满足运行条件后，该进程能够重新回到管程中继续执行。</p>
<p>管程采用了 <code>条件变量(Condition Variables)</code> 方法来实现这种同步工具，并且只能用以下两个函数来访问。</p>
<ul>
<li>cwait(c)：将调用该函数访问条件变量c的进程阻塞，并且释放管程给其他的进程使用。</li>
<li>csignal(c)：继续执行之前因为调用cwait函数访问条件变量c而阻塞的进程。如果这类进程有多个，那么选择其中之一；如果没有，则不做任何操作。</li>
</ul>
<p>采用管程来解决有限缓冲区生产者/消费者问题的方案</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* program production&amp;consumer */</span></span><br><span class="line">monitor bunderbuffer;</span><br><span class="line"><span class="keyword">char</span> buffer [N];</span><br><span class="line"><span class="keyword">int</span> nextin, next out;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">cond notfull, notempty;</span><br><span class="line"><span class="comment">//notfull: 缓冲区有剩余空间时为真 notempty：缓冲区中有有效计算结果时为真</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count == N) cwait(notfull); <span class="comment">// buffer满了，要避免overflow</span></span><br><span class="line">    buffer[nextin] = x;</span><br><span class="line">    nextin = (nextin + <span class="number">1</span>) % N;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">/* one more item in buffer */</span></span><br><span class="line">    csignal(notempty); <span class="comment">// resume any waiting consumer</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>) cwait(notempty); <span class="comment">//buffer空，避免underflow</span></span><br><span class="line">    x = buffer[nextout];</span><br><span class="line">    nextout = (nextout + <span class="number">1</span>) % N;</span><br><span class="line">    count--;</span><br><span class="line">    csignal(notfull); <span class="comment">//resume any waiting producer</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    nextin = <span class="number">0</span>; nextout = <span class="number">0</span>; count = <span class="number">0</span>; <span class="comment">//buffer 初始化为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        produce(x);</span><br><span class="line">        append(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        take(x);</span><br><span class="line">        consume(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parbegin( producer, consumer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>管程的真正优势就在于它所有的操作都被限制在管程内部，这样就更容易检查设计是否正确。</p>
<h5 id="2、采用通知和广播的管程模型"><a href="#2、采用通知和广播的管程模型" class="headerlink" title="2、采用通知和广播的管程模型"></a>2、采用通知和广播的管程模型</h5><p>在 <code>Mesa</code> 语言中，csignal原语被cnotify原语替代，当管程调用了cnotify(x)原语后，它将导致条件变量x的等待队列收到通知，且调用cnotify(x)原语的进程将继续执行。</p>
<p>用while语句替换if语句，这样就保证了条件变量的重新检测。同时避免了进程的额外切换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(count == N) cwait(notfull); <span class="comment">/* buffer is full avoid overflow */</span></span><br><span class="line">    buffer[nextin] = x;</span><br><span class="line">    nextin = &#123;nextin + <span class="number">1</span>&#125; % N;</span><br><span class="line">    count++;</span><br><span class="line">    cnotify(notempty); <span class="comment">/* notify any waiting consumer */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(count == <span class="number">0</span>) cwait(notempty); <span class="comment">/* buffer is empty; avoid underflow */</span></span><br><span class="line">    x = buffer[nextout];</span><br><span class="line">    nextout = (nextout + <span class="number">1</span>) % N; <span class="comment">/* one fewer item in buffer */</span></span><br><span class="line">    cnotify[notfull]; <span class="comment">/* notify ant waiting producer */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四、消息通信"><a href="#四、消息通信" class="headerlink" title="四、消息通信"></a>四、消息通信</h3><hr>
<p>一般来说，进程的交互和协作需要两个基本元素：同步和通信。同步用于进程的互斥，通信则用于进程间的协作。 <code> 消息通信</code> 就能提供这两个基本元素，而且应用范围很广。不同的操作系统对消息通信的实现的细节上有所出入。以下内容讨论其实现的共性的部分。</p>
<p>消息通信的基本形式为以下两个原语：</p>
<ul>
<li>send(destination, message)</li>
<li>receive(source, message)</li>
</ul>
<p>采用send原语，一个进程可以将消息发送给另一个进程(destination)；采用receive原语，一个进程可以接收来自消息源的消息。</p>
<h5 id="1、同步"><a href="#1、同步" class="headerlink" title="1、同步"></a>1、同步</h5><p>无论消息发送还是消息接受都有阻塞和非阻塞两种可能。在具体的系统设计中有以下3中组合。</p>
<ul>
<li><p>发送端阻塞，接收端阻塞</p>
<p>两端都阻塞，消息被接收后再将两端唤醒。这一组合又被称为交汇点(rendzvous)方案，常被用于要求进程强行同步通信的场合</p>
</li>
<li><p>发送端不阻塞，接收端阻塞</p>
<p>发送端在发送完消息后继续执行，而接收端必须阻塞，直到接收到消息后才被唤醒。这一方案是是被最广泛应用的，能够最快的将消息发送给多个目的进程，而接收端必须等待消息到达后才能做有用的工作。</p>
</li>
<li><p>发送端不阻塞，接收端阻塞</p>
</li>
</ul>
<h5 id="2、互斥的实现"><a href="#2、互斥的实现" class="headerlink" title="2、互斥的实现"></a>2、互斥的实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* program mutualexclusion */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="comment">/* number of process */</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    message msg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        receive(box, msg); <span class="comment">// 任何希望进入临界区的进程都必须先获得一个消息，如果邮箱为空</span></span><br><span class="line">        <span class="comment">/* critical section */</span>;</span><br><span class="line">        send(box, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">create <span class="title">mailbox</span><span class="params">(box)</span></span>; <span class="comment">//初始化阶段，邮箱中只存放了一个内容为null的消息</span></span><br><span class="line">    send(box, null);</span><br><span class="line">    parbegin( p(<span class="number">1</span>), p(<span class="number">2</span>), p(<span class="number">3</span>)...... );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果并发地调用消息接收原语，那么就会有：</p>
<ul>
<li>如果邮箱中有一个消息，该消息将被一个进程接收，而其他的进程都将阻塞</li>
<li>如果邮箱中没有消息，所有的进程都将被阻塞。而当之后有一个消息传入邮箱后，只有一个等待态的进程被唤醒，并获得该消息</li>
</ul>
<p>采用消息通信来解决有限缓冲的生产者/消费者问题的方案</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span></span><br><span class="line">    capacity = <span class="comment">/* buffering capacity */</span>;</span><br><span class="line">	null = <span class="comment">/* empty message */</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    message pmsg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        receive(mayproduce, pmsg); <span class="comment">//生产者接收到生产的消息</span></span><br><span class="line">        pmsg = produce(); <span class="comment">//pmsg 表示生产完成,等同于完成临界区</span></span><br><span class="line">        send(mayconsume, pmsg);  <span class="comment">//向消费者发送发消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    message cmsg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        receive(mayproduce, cmsg); <span class="comment">//从mayproduce接收到有数据的消息cmsg</span></span><br><span class="line">        consume(cmsg); <span class="comment">//进入消费的临界区</span></span><br><span class="line">        send(mayproduce, null); <span class="comment">//消费完成，向mayproduce发送空消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    create_mailbox(mayproduce); <span class="comment">//该方案设计了两个邮箱</span></span><br><span class="line">    create_mailbox(mayconsume);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; capacity; i++)	send(mayproduce, null);</span><br><span class="line">    parbegin( producer, consumer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方案非常灵活，可以容纳多个生产者以及多个消费者同时工作。另外，该方案也可以在分布式系统中实现有限缓冲的生产者消费者问题，其中生产者、消费者以及两个邮箱都可以放置在不同的机器上面。</p>
<h3 id="五、读者-写者问题"><a href="#五、读者-写者问题" class="headerlink" title="五、读者/写者问题"></a>五、读者/写者问题</h3><hr>
<p>读者/写者问题是另一个经典的同步和并发问题，描述如下：</p>
<p>有一块共享的数据区域(该区域可以是一个文件，一块内存或处理器中的一组寄存器)，有一组进程(读者)，它们对该共享数据区的访问都是只读的，另外还有一组进程(写者)，它们对该共享数据的访问只是只写。访问规则如下：</p>
<ol>
<li>可以有任意多个读者同时读取数据区的内容；</li>
<li>一次只有一个写者允许向数据区中写；</li>
<li>写者在向数据区中写时，不允许读者同时读取；</li>
</ol>
<p>读者对共享数据区的访问不是独占的，但写者对共享数据区的访问是独占的，无论读者或者写者都不允许同时访问该共享数据区。</p>
<h5 id="1、读者优先"><a href="#1、读者优先" class="headerlink" title="1、读者优先"></a>1、读者优先</h5><p>采用信号灯解决读者/写者问题的方案：读者优先</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* program readers&amp;writers */</span></span><br><span class="line"><span class="keyword">int</span> readcount;</span><br><span class="line">semaphore x = <span class="number">1</span>, wsem = <span class="number">1</span>; <span class="comment">//信号灯wsem用于互斥访问。当有写者在访问共享数据时，不允许读者或者写者同时访问共享数据。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(x);</span><br><span class="line">        readcount++;</span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">1</span>) <span class="comment">//为了使多个读者能够同时访问共享数据而且不会于写者冲突，该方案要求第一个读者必须等待wsem</span></span><br><span class="line">   	    	semWait(wsem); <span class="comment">//信号灯，但是后续到达的读者可以不用等待到达的信号灯就直接进入临界区</span></span><br><span class="line">        semSignal(x);</span><br><span class="line">        READUNIT();</span><br><span class="line">        semWait(x);</span><br><span class="line">        readcount--;</span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">0</span>)</span><br><span class="line">            semSignal(wsem);</span><br><span class="line">        semSignal(x); <span class="comment">// 信号灯x用于保证对readcount的更新操作的正确执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(wsem);</span><br><span class="line">        WRITEUNIT();</span><br><span class="line">        semSignal(wsem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    readcount = <span class="number">0</span>;</span><br><span class="line">    parbegin( reader, writer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方案的最大问题是如果读者过多的话会造成写者的饥饿问题。</p>
<p>采用写者优先方案可以解决这个问题</p>
<h5 id="2、写者优先"><a href="#2、写者优先" class="headerlink" title="2、写者优先"></a>2、写者优先</h5><ul>
<li>只要写者申请访问数据区时，阻止所有读者对共享数据的访问；</li>
<li>全局变量writecount，用于控制对rsem的设置</li>
<li>信号灯y，用于控制对writecount的更新</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readcount, writecount, semphore x = <span class="number">1</span>, y = <span class="number">1</span>, z = <span class="number">1</span>, wsem = <span class="number">1</span>, rsem = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(z);</span><br><span class="line">        	semWait(rsem); <span class="comment">// 写者对rsem进行了设置，一个读者在rsem上等待，其他读者全在z上等待</span></span><br><span class="line">        		semWait(x);</span><br><span class="line">        			readcount++;</span><br><span class="line">        			<span class="keyword">if</span>(readcount == <span class="number">1</span>) <span class="comment">//新的方案只允许一个读者在rsem上等待，后续到达的读者必须在z上等待</span></span><br><span class="line">                 		semWait(wsem); </span><br><span class="line">        		semSignal(x);</span><br><span class="line">        	semSignal(rsem);</span><br><span class="line">        semSignal(z);</span><br><span class="line">        READUNIT();</span><br><span class="line">        semWait(x);</span><br><span class="line">        	readcount--;</span><br><span class="line">        	<span class="keyword">if</span>(readcount == <span class="number">0</span>) semSignal(wsem);</span><br><span class="line">        semSignal(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(y);</span><br><span class="line">        	writecount++;</span><br><span class="line">        	<span class="keyword">if</span>(writecount == <span class="number">1</span>) </span><br><span class="line">                semWait(rsem);</span><br><span class="line">        semSignal(y);</span><br><span class="line">        semWait(wsem); <span class="comment">// 写者全在wsem上排队</span></span><br><span class="line">        WRITEUNIT();</span><br><span class="line">        semSignal(wsem);</span><br><span class="line">        semWait(y);</span><br><span class="line">        	writecount--;</span><br><span class="line">        	<span class="keyword">if</span>(writecount == <span class="number">0</span>)		semSignal (rsem); <span class="comment">//</span></span><br><span class="line">        semSignal(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    readcount = writecount = <span class="number">0</span>;</span><br><span class="line">    parbegin( reader, writer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所示方案中进程队列情况</p>
<table>
<thead>
<tr>
<th align="center">读写者情况</th>
<th align="center">信号灯设置以及排队情况</th>
</tr>
</thead>
<tbody><tr>
<td align="center">系统中只有读者</td>
<td align="center">1、wsem设置  2、无排队</td>
</tr>
<tr>
<td align="center">系统中只有写者</td>
<td align="center">1、wsem和rsem设置  2、写者在wsem上排队</td>
</tr>
<tr>
<td align="center">有读者和写者，读者在前</td>
<td align="center">1、wsem被读者设置  2、rsem被写者设置  3、所有写者在wsem上排队</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">4、一个读者在resm上排队  5、其他读者在z上排队</td>
</tr>
<tr>
<td align="center">有读者和写者，写者在前</td>
<td align="center">1、wsem被写者设置  2、rsem被写者设置  3、写者在wsem上排队</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">4、一个读者在rsem上排队  5、其他读者在z上排队</td>
</tr>
</tbody></table>
<h5 id="3、采用消息通信来解决读者-写者问题-写者优先"><a href="#3、采用消息通信来解决读者-写者问题-写者优先" class="headerlink" title="3、采用消息通信来解决读者/写者问题(写者优先)"></a>3、采用消息通信来解决读者/写者问题(写者优先)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    message rmsg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        send(readrequest, rmsg);</span><br><span class="line">        receive(mbox[i], rmsg);</span><br><span class="line">        READUNIT();</span><br><span class="line">        send(finished, rmsg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">(<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    message rmsg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        send(writerequest, rmsg);</span><br><span class="line">        receive(mbox[j], rmsg);</span><br><span class="line">        WRITEUNIT();</span><br><span class="line">        rmsg = j;</span><br><span class="line">        send(finished, rmsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">controller</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">0</span>) <span class="comment">// count&gt;0，说明没有写者在等待，且有读者在临界区。此时先处理finish消息，然后是写请求，最后是读者请求</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!empty(finshed))</span><br><span class="line">            &#123;</span><br><span class="line">                recevie(finished, msg);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!empty(writerequest))</span><br><span class="line">            &#123;</span><br><span class="line">                receive(writerequest, msg);</span><br><span class="line">                write_id = msg.id;</span><br><span class="line">                count = count - <span class="number">100</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!empty(readrequest))</span><br><span class="line">            &#123;</span><br><span class="line">                receive(readrequest, msg);</span><br><span class="line">                count--;</span><br><span class="line">                send(msg.id, <span class="string">&quot;OK&quot;</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) <span class="comment">//count=0，说明收到了写者的请求，允许写者进入临界区，并且等待“finish”消息</span></span><br><span class="line">        &#123;</span><br><span class="line">            send (write_id, <span class="string">&quot;OK&quot;</span>);</span><br><span class="line">            receive(finished, msg);</span><br><span class="line">            count = <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; <span class="number">0</span>) <span class="comment">//count&lt;0，说明收到了写者的请求，但此时有读者正在临界区中。此时，就只处理“finish”消息</span></span><br><span class="line">        &#123;</span><br><span class="line">            receive(finshed, msg);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; <strong>fine~~</strong></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">WuTai</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2020/10/07/C/%E5%B9%B6%E5%8F%91%EF%BC%9A%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0/">http://example.com/2020/10/07/C/%E5%B9%B6%E5%8F%91%EF%BC%9A%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/myblog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><a class="post-meta__tags" href="/myblog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="https://lwth6g.sn.files.1drv.com/y4pXnYO2S7NHiAUeFmVQHKfem6mCardrridBn_Y2rH8ZdYvdKzzh4ZB5YYgXuK6gtjYJqJaIiwHxZYMZmiiYzvBJdpdRfP6Z1A543oQ5QmsnfZVw4KjFnn3vXPD_1I6eelmx20Y_rA-YQItQXESfdf3YSzFKBpxIV6drkY7FfHkgKMOPpk5pCiY7OijCsXLL49I3gTCP3zcZgieBRE7Qn5LCw/hui-7.png?psid=1" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/myblog/2020/10/13/C/C++%20%E4%B8%AD%20const%20%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A6%81%E7%82%B9/"><img class="prev-cover" src="/myblog/img/hui-3.png" onerror="onerror=null;src='/myblog/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">C++ 中 const 的使用要点</div></div></a></div><div class="next-post pull-right"><a href="/myblog/2020/09/26/C/%E5%88%A9%E7%94%A8%E6%B1%87%E7%BC%96%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0C++/"><img class="next-cover" src="/myblog/img/hui-1.png" onerror="onerror=null;src='/myblog/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">利用汇编深入学习C++</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/myblog/2020/10/13/C/C++ 中 const 的使用要点/" title="C++ 中 const 的使用要点"><img class="cover" src="/myblog/img/hui-3.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-13</div><div class="title">C++ 中 const 的使用要点</div></div></a></div><div><a href="/myblog/2020/09/26/C/利用汇编深入学习C++/" title="利用汇编深入学习C++"><img class="cover" src="/myblog/img/hui-1.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-26</div><div class="title">利用汇编深入学习C++</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div><div class="comment-switch"><span class="first-comment">V</span><label><input id="switch-comments-btn" type="checkbox"/><span class="slider"></span></label><span class="second-comment">a</span></div></div><div class="comment-wrap"><div></div><div></div><div></div><div></div><div></div><div></div></div></div></article></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By WuTai</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/myblog/js/utils.js"></script><script src="/myblog/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  var script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>