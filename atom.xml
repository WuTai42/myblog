<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WuTai&#39;s Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-11-03T23:35:08.913Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>WuTai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统复习</title>
    <link href="http://example.com/2020/11/04/C/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%BB%E8%A6%81%E8%80%83%E5%AF%9F%E7%82%B9/"/>
    <id>http://example.com/2020/11/04/C/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%BB%E8%A6%81%E8%80%83%E5%AF%9F%E7%82%B9/</id>
    <published>2020-11-03T23:19:19.245Z</published>
    <updated>2020-11-03T23:35:08.913Z</updated>
    
    <content type="html"><![CDATA[<h3 id="操作系统主要考察点-期中"><a href="#操作系统主要考察点-期中" class="headerlink" title="操作系统主要考察点(期中)"></a>操作系统主要考察点(期中)</h3><hr><h4 id="1、操作系统主要功能及主要特征"><a href="#1、操作系统主要功能及主要特征" class="headerlink" title="1、操作系统主要功能及主要特征"></a>1、操作系统主要功能及主要特征</h4><p>操作系统是<strong>控制应用程序的执行程序</strong>，同时也是<strong>应用程序和系统硬件之间的接口</strong>。OS 的设计应该努力满足以下3个目标:</p><ul><li>便利性：使计算机便于使用</li><li>有效性：以更有效的方式使用系统资源</li><li>扩展能力：在不影响正常服务的前提下进行有效的开发、测试，并引入新的系统功能</li></ul><h5 id="作为用户与系统交互接口的操作系统"><a href="#作为用户与系统交互接口的操作系统" class="headerlink" title="作为用户与系统交互接口的操作系统"></a>作为用户与系统交互接口的操作系统</h5><p>一般来说 OS 通常从以下几个方面提供服务：</p><ul><li>程序开发</li><li>程序运行</li><li>I/O 设备的访问</li><li>系统的访问</li><li>错误检测和响应</li><li>日志</li></ul><p>典型的计算机系统中有以下3种主要接口：</p><ul><li>指令集架构 ISA：定义了计算机的机器语言指令系统，是<strong>计算机硬件和软件的分割线</strong>。我们通常使用的是其子集（用户级ISA），OS 能使用其他的一些机器语言指令（系统级ISA）。</li><li>应用程序二进制接口 ABI：定义了在程序间进行二进制移植的标准，定义了 OS 的系统调用接口，以及在系统中通过用户级 ISA 能够使用的硬件资源和服务。</li><li>应用程序编程接口 API ：API 允许应用程序访问系统的硬件资源和服务，这些服务由用户级 ISA 和高级语言库（HHL）来提供。</li></ul><h5 id="作为资源管理器的操作系统"><a href="#作为资源管理器的操作系统" class="headerlink" title="作为资源管理器的操作系统"></a>作为资源管理器的操作系统</h5><p>不能简单的说操作系统在控制数据的移动、储存和处理</p><p>OS 作为控制机制和其他的控制机制有以下的区别：</p><ul><li>操作系统和其他的普通软件一样，也是处理器执行的一组程序</li><li>操作系统经常转交控制权（给其他程序），然后需要借助处理器恢复得到控制权</li></ul><p>OS 的内核程序：包含操作系统中最经常使用的功能</p><h5 id="操作系统的易扩展性"><a href="#操作系统的易扩展性" class="headerlink" title="操作系统的易扩展性"></a>操作系统的易扩展性</h5><p>操作系统的发展由以下几个方面推动：</p><ul><li>硬件升级和新型硬件的出现</li><li>新设备的出现</li><li>错误修复</li></ul><h4 id="2、并行与并发的概念与区别"><a href="#2、并行与并发的概念与区别" class="headerlink" title="2、并行与并发的概念与区别"></a>2、并行与并发的概念与区别</h4><p>如果某个系统支持两个或者多个动作（Action）<strong>同时存在</strong>，那么这个系统就是一个<strong>并发系统</strong>。如果某个系统支持两个或者多个动作<strong>同时执行</strong>，那么这个系统就是一个<strong>并行系统</strong>。并发系统与并行系统这两个定义之间的关键差异在于<strong>“存在”</strong>这个词。</p><p>在并发程序中可以同时拥有两个或者多个线程。这意味着，如果程序在单核处理器上运行，那么这两个线程将交替地换入或者换出内存。这些线程是同时“存在”的——每个线程都处于执行过程中的某个状态。如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。</p><p><strong>“并行”概念是“并发”概念的一个子集</strong>。也就是说，你可以编写一个拥有多个线程或者进程的并发程序，但如果没有多核处理器来执行这个程序，那么就不能以并行方式来运行代码。因此，凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为，都属于并发编程的范畴。</p><h4 id="3、进程的概念及组成，进程的三程状态及转移"><a href="#3、进程的概念及组成，进程的三程状态及转移" class="headerlink" title="3、进程的概念及组成，进程的三程状态及转移"></a>3、进程的概念及组成，进程的三程状态及转移</h4><p>现代操作系统的设计。为了能满足系统中多个应用程序的执行的需要，且达到以下的设计目标：</p><ul><li>资源能被多个应用程序使用</li><li>处理器需要在多个多个应用程序的执行过程中切换，以使这些应用程序的执行看上去好像在同时进行</li><li>尽可能的提高处理器和I/O 设备的利用率</li></ul><p>为了能达到这些设计目标，所有的现代操作系统都将应用程序抽象为一个或者多个进程</p><p>对于进程可以有以下几个不同的定义：</p><ul><li>一个正在执行的程序</li><li>一个执行在计算机上的应用程序实例</li><li>一个能够调度到处理器上执行的实体</li><li>一个活动单元，包括一串指令的执行、当前状态，以及一组正在使用的资源</li></ul><p>我们还可以把进程当作一个包含多个元素的独立个体，其中最基本的两个元素—&gt; <strong>程序代码</strong>（可以在同一应用中创建的多个进程间共享） 和 与<strong>程序代码相关的一组数据</strong> </p><p>在其执行过程中的任意一个节点上，所对应的进程拥有唯一标识其存在的元素，包括：</p><ul><li>标识符</li><li>进程状态</li><li>优先级</li><li>进程计数器</li><li>内存指针</li><li>上下文</li><li>I/O 状态</li><li>记账信息</li></ul><p>这些信息被放在一个叫做 <strong>进程控制块</strong> 的数据结构中，往往由 OS 创建</p><p>进程的三状态： 1、就绪态     2、运行态     3、阻塞态</p><ul><li>运行态：进程正在运行</li><li>就绪态：进程已经准备好执行，如果分配了处理器，它可以立即投入执行</li><li>阻塞态：进程在等待某事件的发生</li></ul><p><strong>就绪态 —-&gt; 运行态</strong>：处理器空闲的时候，处理器从就绪的进程中挑选一个进程将其投入运行，其状态也变为运行态</p><p><strong>运行态 —-&gt; 就绪态</strong>：1、用完时间片 2、优先级调度（抢占和自愿）</p><p><strong>运行态 —-&gt; 阻塞态</strong>：进程在执行过程中，因为请求一些暂时得不到而必须等待的服务时，从运行态转移到阻塞态（i.e. 1、进程调用一个操作系统提供的的服务：读写文件，访问共享内存……这些服务OS有可能不能及时提供。2、或者进程在执行过程中发出了I/O请求。 3、由于进程间通信的原因，一个进程的执行过程必须等待另一个进程的信息。）</p><p><strong>阻塞态 —-&gt; 就绪态</strong>：当进程所等待的事件到达后，它的状态将从阻塞态转移到就绪态</p><h4 id="4、进程通信方式"><a href="#4、进程通信方式" class="headerlink" title="4、进程通信方式"></a>4、进程通信方式</h4><p>进程的交互协作需要两个基本元素：同步和通信</p><p>同步用于进程的互斥，通信则用于进程间的协作。消息通信就能提供这两个基本元素。</p><h4 id="5、进程间的制约关系"><a href="#5、进程间的制约关系" class="headerlink" title="5、进程间的制约关系"></a>5、进程间的制约关系</h4><h4 id="6、进程与线程之间的区别"><a href="#6、进程与线程之间的区别" class="headerlink" title="6、进程与线程之间的区别"></a>6、进程与线程之间的区别</h4><p>之前对进程概念的讨论体现了以下两个概念：<strong>资源占用</strong>，<strong>调度/执行</strong></p><p>这两个概念在进程的概念中得到了统一，但是在现代的操作系统设计上，这两个概念是相互独立的。为了区分这两个概念，把进程调度的实体称为：<strong>线程或者轻量级进程（Lightweight Process）</strong>，而在考虑资源的权属上把拥有资源的个体称为<strong>进程</strong>或者<strong>任务(Task)</strong></p><p>在多线程系统中，进程是参与资源分配，以及权限保护的基本单位，它包括：</p><ul><li>容纳进程镜像的虚拟地址空间</li><li>处理器的受保护访问，其他进程信息（用于通信），一组文件和I/O资源(设备和通道)</li></ul><p>进程可以包含一个或者多个线程，每个线程包括：</p><ul><li>线程的状态（运行态、就绪态等）</li><li>线程上下文（未执行时），以及线程在进程中的执行的位置</li><li>私有的执行栈</li><li>静态存储空间和局部变量</li><li>对系统资源的访问权限</li></ul><p>进程的线程共享它们父进程的状态，以及它们拥有的系统资源，并且它们共处于同一地址空间，访问同一组数据。</p><p>线程概念的产生实际上是对计算机系统性能进行优化的结果</p><h4 id="7、进程调度的原因，操作系统的三级调度"><a href="#7、进程调度的原因，操作系统的三级调度" class="headerlink" title="7、进程调度的原因，操作系统的三级调度"></a>7、进程调度的原因，操作系统的三级调度</h4><p>在多道程序系统中，内存中同时存在多个进程。每个进程要么在使用处理器，要么在等待某个事件发生（如I/O操作的完成）发生。如果在处理器或者处理器组执行一个进程的时候，还有其他进在等待执行，那么处理器就可以保持在忙碌状态。</p><p>处理器调度的目的：以符合系统目标的方式将进程分配到处理器或者处理器组上执行，这些系统目标包括，响应时间、吞吐率，以及处理器的利用率等等。</p><p>调度活动被分解为3个相互独立的功能：长期调度，中期调度，短期调度</p><table><thead><tr><th align="center">调度类型</th><th align="center"></th></tr></thead><tbody><tr><td align="center">长期调度</td><td align="center">决定是否将一个新进程加入将待执行的进程池中</td></tr><tr><td align="center">中期调度</td><td align="center">决定哪个就绪进程部分或者全部载入内存</td></tr><tr><td align="center">短期调度</td><td align="center">决定哪个就绪进程将被处理器执行</td></tr></tbody></table><h4 id="8、进程调度算法（FCFS，SPF，RR），周转时间的概念"><a href="#8、进程调度算法（FCFS，SPF，RR），周转时间的概念" class="headerlink" title="8、进程调度算法（FCFS，SPF，RR），周转时间的概念"></a>8、进程调度算法（FCFS，SPF，RR），周转时间的概念</h4><p>各种调度策略的特征</p><table><thead><tr><th align="center"></th><th align="center">FCFS</th><th align="center">RR</th><th align="center">SPN</th></tr></thead><tbody><tr><td align="center">选择函数</td><td align="center">max[w]</td><td align="center">常量</td><td align="center">min[s]</td></tr><tr><td align="center">策略模式</td><td align="center">非抢占</td><td align="center">抢占（用完时间片）</td><td align="center">非抢占</td></tr><tr><td align="center">吞吐量</td><td align="center">不强调</td><td align="center">如果时间片太小，吞吐量会降低</td><td align="center">高</td></tr><tr><td align="center">响应时间</td><td align="center">可能很高，特别是进程时间差别很大的时候</td><td align="center">为短进程提供良好的相应时间</td><td align="center">为短进程提供良好的相应时间</td></tr><tr><td align="center">开销</td><td align="center">最小</td><td align="center">最小</td><td align="center">可能高</td></tr><tr><td align="center">对进程的影响</td><td align="center">对短进程和I/O型进程不利</td><td align="center">公平对待</td><td align="center">对长进程不利</td></tr><tr><td align="center">饥饿现象</td><td align="center">无</td><td align="center">无</td><td align="center">可能</td></tr></tbody></table><p>与非抢占式策略相比，抢占式策略会导致更大的开销，但是可以从整体上为进程提供更好的服务。此外，采用高效的进程切换机制（可能有求于硬件），提供大容量的内存以便将更多的进程放入内存中……通过这些方法可以有效降低抢占式的开销。</p><p>根据排队模型，周转时间(Turnaround Time, TAT)等于驻留时间Tr，或者这一进程在系统中花费的总时间(等待时间 + 服务时间)。另一个更有用的数据称为带权周转时间(Normalized Turnaround Time)，它是周转时间于服务时间的比值。这个值反映了进程的相对延迟。通常来说，进程的执行时间越长，可以容忍的延迟时间也越长。带权周转时间的最小值为1，该值增加，则意味着服务水平的增加。</p><h4 id="9、死锁概念，原因，必要条件，预防及避免算法"><a href="#9、死锁概念，原因，必要条件，预防及避免算法" class="headerlink" title="9、死锁概念，原因，必要条件，预防及避免算法"></a>9、死锁概念，原因，必要条件，预防及避免算法</h4><p>死锁是指<strong>一组进程因为竞争系统资源或相互等待消息</strong>，而无法向前推进的状态。</p><p>死锁一般都涉及两个或更多进程之间的相互冲突的资源请求。死锁的发生不仅取决于进程的动态执行路径，还取决于应用实现的具体细节。</p><p>死锁发生的条件：</p><p>(1) 互斥：资源只能由一个进程占用，如果资源被分配给了一个进程，则其他进程不可使用该进程</p><p>(2) 占用并等待：进程必须占用分配给它的资源，且同时申请和等待其他资源</p><p>(3) 不可剥夺：如果资源被某些进程占用，那么则不可能将其从进程中强行剥夺出来</p><p>注意： 以上3个条件只是 必要条件 并非充分条件死锁的发生还需要第4个条件：</p><p>(4) 环路等待：资源和进程的分配关系在资源分配图上表现为一个封闭的环路，其中，每个进程至少占用一个资源，且该资源同时被环路中的其他进程所申请</p><p>导致死锁的条件</p><table><thead><tr><th align="center">可能导致死锁</th><th align="center">死锁发生</th></tr></thead><tbody><tr><td align="center">1、互斥</td><td align="center">1、互斥</td></tr><tr><td align="center">2、不可抢占</td><td align="center">2、不可抢占</td></tr><tr><td align="center">3、占用并等待</td><td align="center">3、占用并等待</td></tr><tr><td align="center"></td><td align="center">4、环路等待</td></tr></tbody></table><p>解决死锁问题有3个方案：</p><p>一、死锁预防：方案是破除死锁发生的4个条件之一</p><p>二、死锁避免：方案是基于资源分配的当前状况，动态的做出资源分配决策</p><p>三、死锁检测：方案检测系统中已经发生的死锁，并想办法打破进程间的死锁状态</p><h5 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h5><p>简单的说，死锁的预防方案思想是设计一个系统，该系统能够<strong>去除死锁发生的可能</strong>。可以将死锁预防的方案可以归纳为2种：一种是<strong>直接方案</strong>，还有一种是<strong>间接方案</strong>。间接方案是破除死锁发生条件的前3条中的任意一条，而直接方案是预防环路等待条件的发生。</p><p>1、互斥条件：</p><p>一般来说，互斥条件与具体的资源属性有关，是很难破除的。如果对某些资源的访问需要互斥，则<strong>操作系统必须提供某种互斥机制</strong>。如文件的读写限制。但是当有多个进程在对该文件并发的写的时候</p><p>2、占有并等待条件：</p><p>可以采用以下的方法来破除：</p><p>要求进程在执行前，一次性申请完它在执行过程种所有可能用到的资源。如果系统暂时无法满足它的资源申请要求，则进程必须等待直到系统拥有足够多的资源，并将资源一次性全部分配给它才能开始运行。</p><p>注意：该方案可能导致系统的效率降低：</p><ul><li>进程可能在获得它运行所需的全部资源前需要等待很长时间。然而实际上，如果给它一部分资源，它便可以开始运行了</li><li>分配给进程的资源可能长时间得不到使用，但别的进程也无法利用这些资源，然而，这些资源可能在它实际的执行路径中根被没有被使用</li></ul><p>3、不可抢占条件：</p><p>破除该条件的方法有：</p><ul><li>如果进程占用了一些资源，且在后续资源请求下得不到满足的情况下，它就必须释放它已经占用的资源，并在后续的执行中一次性申请全部的资源(包括之前释放的和申请不到的资源)</li><li>如果一个(高优先级)进程申请已经被一个(低优先级)进程把资源占用了。那么OS将从后者抢占资源将其分配给前者，该方法仅仅适用于任意两个进程都拥有不同优先级的情况，而且只能用在资源状态很容易保存和恢复的情况。(i.e. 处理器中的资源)</li></ul><p>4、环路等待条件：</p><p>可以用有序资源分配的方法破除环路等待条件：先将资源进行线性编序，如果进程获得资源R，那么后续请求的资源序号都只能大于或者都小于R。</p><p>然而破除环路等待条件还是可能会导致系统效率的降低，或者进程的执行速度降低，亦或不必要的资源分配请求拒绝等问题。</p><h5 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h5><p>死锁预防的方法实际上是在满足资源请求的方式上做出某种限制，使其破除死锁发生的某一个条件，从而使得死锁不可能发生。破除死锁条件的方法上面已经讨论过了，正如讨论的那样，这些方法都会导致资源利用率的下降，或者进程执行速度的降低。死锁避免的方法与之有细微的差别，该方案允许死锁发生的前三个必要条件的存在，但是在资源分配的时候做出谨慎的决策，以避免死锁的发生。</p><p>在死锁避免方案中，资源分配决策的制订，是基于(假如将资源分配出去)在未来是否会发生死锁来判断的。所以，死锁避免方案需要知道进程未来的资源请求。这种方案有很多种解法，这里主要介绍两种：</p><ul><li>(如果会导致死锁)拒绝创建进程</li></ul><p>$$<br>考虑一个有n个处理器，m种不同类型资源的系统：R = (R_1, R_2,……, R_m)系统种的全部资源<br>$$</p><p>$$<br>资源申请矩阵：<br>\begin{pmatrix}<br>      C_{11} &amp; C_{22} &amp; … &amp; C_{1m} \<br>      C_{21} &amp; C_{22} &amp; … &amp; C_{2m} \<br>      … &amp; … &amp; … &amp; … \<br>      C_{n1} &amp; C_{n2} &amp; … &amp; C_{nm}<br>\end{pmatrix}<br>$$</p><p>$$<br>C_{ij} = 进程i申请资源j的总数量,死锁避免方案可以要求在创建一个新进程的P(n + 1)时有：<br>$$</p><p>$$<br>R \geq C_{(n+1)j} + \sum_{i=1}^{n}C_{ij}<br>$$</p><p>也就是说，仅当所创建的进程对各类资源的最大资源需求量加上系统中已有进程对各类资源的申请量的总和，小于系统中各类资源的总量时，该进程才被允许创建。</p><p>很显然，这个策略并不是最有效的，因为它假设的是最坏情况：所有进程同时申请最大数量的资源。</p><ul><li>(如果会导致死锁)拒绝分配资源 —-&gt; 又称为银行家算法</li></ul><h4 id="10、信号量机制，PV操作基本概念"><a href="#10、信号量机制，PV操作基本概念" class="headerlink" title="10、信号量机制，PV操作基本概念"></a>10、信号量机制，PV操作基本概念</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;操作系统主要考察点-期中&quot;&gt;&lt;a href=&quot;#操作系统主要考察点-期中&quot; class=&quot;headerlink&quot; title=&quot;操作系统主要考察点(期中)&quot;&gt;&lt;/a&gt;操作系统主要考察点(期中)&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;1、操作系统主要功能及主要特征&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Virtual Memory Series I</title>
    <link href="http://example.com/2020/10/25/C/Virtual%20Memory%EF%BC%9A%20Issues%20of%20Implementation/"/>
    <id>http://example.com/2020/10/25/C/Virtual%20Memory%EF%BC%9A%20Issues%20of%20Implementation/</id>
    <published>2020-10-25T14:10:07.267Z</published>
    <updated>2020-10-30T01:53:24.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Virtual-Memory：-Issues-of-Implementation"><a href="#Virtual-Memory：-Issues-of-Implementation" class="headerlink" title="Virtual Memory： Issues of Implementation"></a>Virtual Memory： Issues of Implementation</h1><font size = 4.5>---<p>In 1998,  there has not been much agreement on the form that what kind of support should modern processors take for “Virtual Memory”.</p><p>Thus in that time they have two ways for system-level software but seems somewhat unattractive:</p><ol><li>Writing software to fit many different architectures, which can compromise performance and reliabilities.</li><li>Inserting layers of software to emulate a particular hardware interface, which essentially forces one hardware design to look like another. Inserting this <strong>hardware abstraction layer</strong> hides hardware particulars from the higher levels of software but also compromise performance and compatibility.</li></ol><p>Today’s  OSs and microprocessor are geared toward demand-paged virtual memory.</p><h3 id="一、BASIC-CONCEPTS"><a href="#一、BASIC-CONCEPTS" class="headerlink" title="一、BASIC CONCEPTS"></a>一、BASIC CONCEPTS</h3><hr><p>A well-designed virtual-memory system system:</p><ul><li>The main memory holds only the most often used portions of a process’s address space.</li><li>Other portions are stored on disk and retrieved as needed.</li></ul><p>The mapping is a function, a given virtual page can have only one physical location.  However, the inverse mapping is not necessarily a function. This allows several virtual pages mapped to the same page frame. This is called <code>virtual-address aliasing</code>, which lets processes or threads share memory and supports different ‘views’ of data with different protections or behaviors.</p><p>If an item can be paged, it implies that the item resides in virtual space. The OS allocates physical memory for the item itself only when the item is paged in.</p><h3 id="1、Page-table-entries"><a href="#1、Page-table-entries" class="headerlink" title="1、Page table entries"></a>1、Page table entries</h3><p>At the minimum, a PTE indicates whether its virtual page is in memory, on disk, or unallocated.</p><p>Form a PTE, the OS must be able to determine:</p><ul><li>the ID of the page’s owner </li><li>the virtual page number</li><li>the page’s location in memory (page frame number) or location on disk (an offset into a swap file)</li><li>a valid bit contains a valid translation or not</li><li>a reference bit, whether the page was recently accessed</li><li>a modify bit, whether the page was recently written</li><li>page-protection bits, read-write、read-only and so on</li></ul><p>However, for efficiency reasons, all of the information an OS needs <strong>is rarely stored explicitly in each PTE.</strong></p><h3 id="2、Translation-lookaside-buffers"><a href="#2、Translation-lookaside-buffers" class="headerlink" title="2、Translation lookaside buffers"></a>2、Translation lookaside buffers</h3><p>To speed translation, most hardware systems provide a cache for PTEs, called a translation lookaside buffer(TLB).</p><p>In some implementations the OS searches the page table after a TLB miss; in others, a hardware state machine conducts the search.</p><p>If a page fault interrupts the OS, which must then do one of three things:</p><ol><li>Retrieve the page from disk and place it into memory.</li><li>Create a new page if the page does not exist (as when a process allocates a new stack frame in virgin territory).</li><li>If the access is to illegal space——send the process an error signal.</li></ol><p>Faulting address: The virtual address causing a TLB miss. This is not meant to imply that all TLB misses result in page faults.</p><p>The inclusion between the TLB and main memory: If a page is in memory, its mapping <strong>may or may not be in the TLB</strong>, but if a page’s mapping is in the TLB, the page <strong>must be in physical memory.</strong> </p><h3 id="二、PAGE-TABLE-ORGANIZATION"><a href="#二、PAGE-TABLE-ORGANIZATION" class="headerlink" title="二、PAGE TABLE ORGANIZATION"></a>二、PAGE TABLE ORGANIZATION</h3><hr><p>Few generations ago, we use signal-level table, <strong>direct table</strong>.</p><p>Table walking: the search of the page table.</p><p>There are two primary types of page table organization: <code>forward-mapped or hierarchical page table</code> index by the virtual page number; and the <code>inverse mapped or inverted page table</code> index by the page frame number.</p><h3 id="1、-Hierarchical-page-tables"><a href="#1、-Hierarchical-page-tables" class="headerlink" title="1、 Hierarchical page tables"></a>1、 Hierarchical page tables</h3><p>Based on the idea: <strong>A large data array can be mapped by a smaller array, which can in turn be mapped be an even smaller array.</strong></p><p>Most OSs wire down root-level table in memory while the process is running.</p><p>There are two access methods for the hierarchical page table: <code>top-down</code> or <code>bottom-up</code>.</p><p>Top-down: uses physical address to reference the PTEs in the table.</p><p>Bottom-up: uses virtual address.</p><h3 id="2、Top-down-traversal"><a href="#2、Top-down-traversal" class="headerlink" title="2、Top-down traversal"></a>2、Top-down traversal</h3><p>Often used in hardware table-walking schemes(Inter’s IA-32 architecture).</p><h3 id="3、Bottom-up-traversal"><a href="#3、Bottom-up-traversal" class="headerlink" title="3、Bottom-up traversal"></a>3、Bottom-up traversal</h3><p>The top-down access method requires as many memory references as there are table levels.</p><p>On a TLB miss, the virtual address for this user PTE is used to load the PTE from the user page table.</p><p>The following pseudo-code briefly illustrates these steps:</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">load user data /* load misses TLB */</span><br><span class="line">    /* invokes TLB-miss handler */</span><br><span class="line">    construct virtual address for user PTE</span><br><span class="line">    load user PTE /* load misses TLB */</span><br><span class="line">    /* invoke root TLB-miss handler: */</span><br><span class="line">    construct physcial address for root PTE</span><br><span class="line">    load root PTE /* can not cause TLB miss, because it uses a </span><br><span class="line">            physical address*/</span><br><span class="line">             put root PTE into TLB</span><br><span class="line">             jump to faulting instruction</span><br><span class="line">        /* return to user TLB-miss handler: */</span><br><span class="line">        load user PTE /* this time load succeeds */</span><br><span class="line">        put user PTE into TLB</span><br><span class="line">        jump to faulting instruction</span><br><span class="line">/* return to user mode */</span><br><span class="line">load user data /* this time load succeeds */</span><br></pre></td></tr></table></figure><h3 id="4、Inverted-page-tables"><a href="#4、Inverted-page-tables" class="headerlink" title="4、Inverted page tables"></a>4、Inverted page tables</h3><p>Instead of one entry for every virtual page belonging to a process, the inverted page table has <strong>one entry for every page frame in main memory.</strong></p><p>The index of the PTE in the inverted table is equal to the page frame number of the page it maps. Thus, rather than scaling with the size of the virtual space, it <strong>scales with the size of physical memory.</strong> It compact in size, making it a good candidate for the hardware-managed mechanism that need the table to be wired down in memory.</p><p>Since different virtual page numbers might produce identical hash values, a <code>collision-chain</code> mechanism is used to let these mapping exist int the table simultaneously.</p><p>Noting that in classical inverted-table implementations, the PTE is too large compare to hierarchical table. As a trade-off to keep the table small, the designers of early systems increased the number of memory accesses per lookup. They added a level of indirection, the <strong>hash anchor table(HAT).</strong></p><p>Since the entries in the hash anchor table are smaller than the entries in the inverted table, it is more memory efficient <strong>to increase the size of the hash anchor table to reduce the average collision-chain length.</strong></p><p>the following steps briefly illustrate this mechanism:</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Step 1:</span><br><span class="line">faulting virtual page number is hashed, indexing the hash anchor table index.</span><br><span class="line">Corresponding anchor-table entry is loaded and points to the chain head for that hash value.</span><br><span class="line">step 2:</span><br><span class="line">The indecated PTE loaded.</span><br><span class="line">Comparing its virtual page number to the faulting virtual page number.</span><br><span class="line">if (marched) </span><br><span class="line">step 3a:</span><br><span class="line">Algorithm terminates, the mapping, composed of the virtual page number and the page frame numbers(PTE&#x27;s index), is placed into the TLB.</span><br><span class="line">else</span><br><span class="line">step 3b</span><br><span class="line">The PTE referrences the next entry in the chain, or indicates that it is the last chain in the chain.</span><br><span class="line">If there is a next entry, it is loaded and compared.</span><br><span class="line">If the last entry fails to match, algorithm terminates and cases a page fault.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="三、DETAILS-AND-THEIR-DEVILS"><a href="#三、DETAILS-AND-THEIR-DEVILS" class="headerlink" title="三、DETAILS (AND THEIR DEVILS)"></a>三、DETAILS (AND THEIR DEVILS)</h3><hr><p>The choice between hierarchical and inverted page tables is not an obvious one: There are many trade-offs between performance and memory usage. Implementations of shared memory width vary widely in performance, <strong>especially with different hardware support</strong>. (i.e. virtual caches requires more consistency management than physical caches).</p><p>The address-space protection scheme is also heavily dependent on hardware support and has great impact on the shared-memory implementation.</p><p>Also, the TLB can be managed by the OS or managed in hardware, presenting a trade-off between flexibility and performance. </p><p>It is not surprising that <strong>the interactions are often subtle and  nonintuitive.</strong></p><h3 id="1、Share-memory"><a href="#1、Share-memory" class="headerlink" title="1、Share memory"></a>1、Share memory</h3><p>There are several implementation possibilities for shared memory. One of the most common is <code>virtual address aliasing</code>, or simply <code>aliasing</code>. In this scheme, each mapping to the same physical page requires its own logical PTE.</p><p>Maintaining multiple PTEs makes it possible for different processes:</p><ul><li>Using different virtual address for the same physical data.</li><li>Mapping the same physical data with different protections.</li><li>For different virtual references to the same physical data to cause different behaviors. </li></ul><p>primary disadvantage of aliasing: Increasing overhead of managing multiple mappings to the same physical page.</p><p>A variation on aliasing is to <strong>share portions of page tables whenever data is shared.</strong></p><p>Compared to the normal aliasing mechanism, this variation reduces the overhead of mapping PTEs and reduces the impact of multiple PTEs on the TLB.</p><p>Disadvantage: It can require sharing at large granularities (It can be overcome if the hardware translation mechanism is segmented and supports protection at the segment level).</p><p>Another alternative to aliasing is to have all processes share a global virtual address space. This space is often called a “flat” address space because <strong>it is not divided into disjunct per-process spaces by address-space identifiers.</strong></p><p>Typically, these signal address-space OSs map the entire space of all processes with a single page table, which considerably reduces the management overhead. (Unix-based OSs and PA-RISC system use a global address space)</p><h3 id="2、Address-space-identifier-versus-segmentation"><a href="#2、Address-space-identifier-versus-segmentation" class="headerlink" title="2、Address-space identifier versus segmentation"></a>2、Address-space identifier versus segmentation</h3><p> Two common hardware assists for providing address-space protection are <code>address-space identifiers</code> and <code>page segmentation</code>.</p><p><strong>Address-space identifiers</strong> found in: <code>MIPS</code>, <code>Alpha</code>, and <code>sparc</code> architectures, extend virtual addresses and distinguish them form those generate by different processes. multiple processes can coexist, each thinking it owns the full extend of a 32-bit address space. Each process is unable to produce addresses that mimic those of other processes, because to do so it must control the contents of the protected register holding the address-space identifier.</p><p>The OS place a process’s address-space identifier in a protected register, and every virtual address the process generates is concatenated with the address-space identifier.</p><p><strong>In page segmentation</strong>, (as implemented in the <code>PowerPC</code>, <code>PA-RISC</code> , and <code>X86</code> architectures), virtual-physical translation occurs in two steps: </p><ol><li>User addresses are mapped onto a global address at the granularity of segments.</li><li>Virtual addresses from the global space are mapped onto physical memory at the granularity of pages.</li></ol><p>A process address space is usually composed of many segments, so the OS maintains a set of segment identifiers for each process. It can also provide address-space protection.</p><p>Segment translation from the process address space to the global address is like the hardware scheme for address-space identifiers.</p><p>Segmentation is therefore analogous to having multiple address-space identifiers per process—one for each segment in the user address space.</p><p>Address-space identifiers and segmentation interact with shared memory differently. Conceptually, shared memory acts in opposition to address-space protection schemes. </p><p>With address-space identifiers, this is often done by explicitly duplicating mapping information across page tables. Or by marking a shared page as visible to all processes—explicitly turning off protection for that page.</p><p>Segments, in contrast, allow both protection and fine-grained sharing. Two processes can safely share a segment, and can do so without making segment visible to other processes.</p><h3 id="3、TLBs-revisited"><a href="#3、TLBs-revisited" class="headerlink" title="3、TLBs  revisited"></a>3、TLBs  revisited</h3><p>(tips: flush–&gt;means to clean all.)</p><p>Either the OS or the hardware can refill the TLB when a TLB miss occurs.</p><p><strong>Hardware-managed TLB</strong>: a hardware state machine walks the page table, there is no interrupt or interaction with the instruction cache.</p><p><strong>Software-managed TLB</strong>: the general interrupt mechanism invokes a software TLB-miss handler — a primitive in the OS that is usually 10-100 instructions long. The use of the interrupt mechanism adds to the cost by flushing the pipeline, possibly removing many instructions from the reorder buffer. This can result in hundreds of cycles.</p><p>However, the software-managed TLB design allows the OS to choose any page table organization, whereas the hardware-managed scheme defines a page table organization for the OS. This flexibility in the software-managed scheme can outweigh its potentially higher per-miss cost .</p><p>The PA-7200 uses a hybrid approach,  implementing the initial probe of its hashed page table in hardware, and — if this initial probe fails — walking the rest of the page table in software.</p><p>TLB does not need to be flushed on process context switch unless there are globally shared pages. </p><p><strong>Flushing</strong> is typically required only whenever the OS reassigns an address-space identifier or segment identifier to a new process (such as at process creation), or when there are fewer address-space identifiers than currently active processes, which necessitates a temporary ID remapping. If the protection mechanism goes unused flushing is also required. </p><p>In most case, only those entries tagged with that address-space identifier need to be flushed.</p><p>OS must often <strong>invalidate the entire TLB contents</strong> or <strong>individually invalidate each entry that matches the address-space identifier.</strong> Typically, it is cheaper to invalidate all TLB contents than to maintain a list of entries to be flushed on context switch as this list will typically be large and expensive to maintain. </p><h3 id="四、Foresight"><a href="#四、Foresight" class="headerlink" title="四、Foresight"></a>四、Foresight</h3><p>There is wide diversity in how today’s commercial processors support memory management. However, the specific details of one processor’s memory-management architecture do not seem to confer a clear performance advantage over another’s. Why? <strong>incompatible</strong> from inadequate hardware support.</p><p>Virtual caches requires no address translation when the data is found in the caches are large enough, there is rarely a need to go to memory. Address translation would be performed only on the rare cache miss and could therefore afford to be expensive.</p><p>Instead of using hardware, the OS itself could perform virtual-memory functions — including address translation and protection checks — resulting in increased flexibility and simplifying the job of porting system software.</p><h3 id="五、Typical-architecture"><a href="#五、Typical-architecture" class="headerlink" title="五、Typical architecture"></a>五、Typical architecture</h3><h3 id="1、MIPS-Architecture"><a href="#1、MIPS-Architecture" class="headerlink" title="1、MIPS Architecture"></a>1、MIPS Architecture</h3><p>OS handles TLB misses entirely in software. The OS walks the page table, fills the TLB, and can implement virtually any TLB replacement policy.</p><p>The hardware supports a bottom-up hierarchical page table through the TLB context register, which holds a virtual address partitioned into a software-loaded segment and a hardware-loaded segment.</p></font>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Virtual-Memory：-Issues-of-Implementation&quot;&gt;&lt;a href=&quot;#Virtual-Memory：-Issues-of-Implementation&quot; class=&quot;headerlink&quot; title=&quot;Virtual Memo</summary>
      
    
    
    
    <category term="Operating Systems" scheme="http://example.com/categories/Operating-Systems/"/>
    
    
    <category term="Operation Systems" scheme="http://example.com/tags/Operation-Systems/"/>
    
    <category term="Memory Management" scheme="http://example.com/tags/Memory-Management/"/>
    
    <category term="Virtual Memory" scheme="http://example.com/tags/Virtual-Memory/"/>
    
  </entry>
  
  <entry>
    <title>Linkers and loaders (1)</title>
    <link href="http://example.com/2020/10/24/C/Linkers%20and%20Loads/"/>
    <id>http://example.com/2020/10/24/C/Linkers%20and%20Loads/</id>
    <published>2020-10-24T13:09:26.099Z</published>
    <updated>2020-10-24T15:16:55.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linkers-and-Loads"><a href="#Linkers-and-Loads" class="headerlink" title="Linkers and Loads"></a>Linkers and Loads</h1><font size = 4.5><h3 id="一、INTRODUCTION"><a href="#一、INTRODUCTION" class="headerlink" title="一、INTRODUCTION"></a>一、INTRODUCTION</h3><hr><p>Translating high-level language into a properly formatted binary string before it can be executed is necessary. In most basic form this transformation process occurs in two stages:</p><ol><li>A user’s (source) program is translated into machine language.</li><li>The translated program is stored for immediate or future execution</li></ol><p><strong>loading</strong>: storing into main memory</p><p><strong>linking</strong>: combine subprograms into a composite program</p><h3 id="二、LOADERS"><a href="#二、LOADERS" class="headerlink" title="二、LOADERS"></a>二、LOADERS</h3><hr><p>Loading a translated program into memory is logically distinct from the translation of that program, separate software modules, called loaders, have been developed to accomplish the loading operation. </p><p>There are two types:</p><ol><li>Binary loaders</li><li>Relocating loaders</li></ol><p>The relocating loader is responsible for loading into main memory a program in relocatable binary form and updating (relocation) all relative addresses.</p><h3 id="三、LINKERS"><a href="#三、LINKERS" class="headerlink" title="三、LINKERS"></a>三、LINKERS</h3><hr><p>Linking could be carried out at 7 different times:</p><ul><li>source program coding time</li><li>after coding but before translation time</li><li>at translation time</li><li>after translation but before loading time</li><li>at loading time</li><li>after loading but before execute time</li><li>at execute time</li></ul><p><strong>Address binding</strong>: translation  or mapping of a logical into a physical address.</p><p><strong>Linking process</strong>: binding (combining) independent logical spaces into one composite logical space.</p><h3 id="四、THE-LINKAGE-EDITOR"><a href="#四、THE-LINKAGE-EDITOR" class="headerlink" title="四、THE LINKAGE EDITOR"></a>四、THE LINKAGE EDITOR</h3><hr><p>On the IBM System/360, there exist a sophisticated linker, called the <code>Linkage Eeditor</code> , and a simple relocating loader referred to as <code>Program Fetch</code> .</p><p>Linkage Editor is responsible for the following functions:</p><ul><li><p>Primary function: (1) Linking together independently translated modules.</p></li><li><p>Secondary function: (1) Overlaying processing.</p><p>​                                 (2) Program modification.</p><p>​                                 (3) Library access.</p></li></ul><p>The inputs accepted  can be divided into two groups: <code>input modules</code> &amp; <code>Linkage Editor control statements</code>. </p><p>Input modules are further classified as being either <code>Object Modules</code> or <code>Load modules</code>. These two are similar in structure.</p><p>Object module: The output  produced by the language translators(IBM System/360). This output consists of the machine language code for the translated program, relocation information, and a table indicating the definition and use of external symbols.</p><p>Linking Together a Set of Modules:</p><p>​        In linking together a set of modules, the Linkage Editor is primarily responsible for:</p><p>​            (1) assigning address.</p><p>​            (2) relocating Address Constants.</p><p>​            (3) create an output module (Load Module).</p><h3 id="四、SUMMARY"><a href="#四、SUMMARY" class="headerlink" title="四、SUMMARY"></a>四、SUMMARY</h3><hr><p>The linking together of independently translated programs is the responsibility of the <strong>Linkage Editor</strong> , and a major part of the language processing burden is on the language translators whose responsibility is not only to translate source programs into a form which is very close to machine language, but also to format addresses in a base plus displacement form and to create the Object Module.</p><p>If the various stages of the language transformation process are viewed as a function of time, it is generally true that <strong>early binding allows more efficient implementations</strong> while <strong>late binding facilitates program debugging and modification.</strong></p><p>Features as elaborate editing capabilities and overlay processing, which produce a powerful and sophisticated linker, are at a high cost. So flexibility provided by simple linkers and relocating loaders has a definite place in modern OS.</p></font><div align = "right">Computing Surveys Vol 4, No 3, Sep 1972</div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linkers-and-Loads&quot;&gt;&lt;a href=&quot;#Linkers-and-Loads&quot; class=&quot;headerlink&quot; title=&quot;Linkers and Loads&quot;&gt;&lt;/a&gt;Linkers and Loads&lt;/h1&gt;&lt;font size = </summary>
      
    
    
    
    <category term="Operating Systems" scheme="http://example.com/categories/Operating-Systems/"/>
    
    
    <category term="Linkers and loaders" scheme="http://example.com/tags/Linkers-and-loaders/"/>
    
    <category term="Operation Systems" scheme="http://example.com/tags/Operation-Systems/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中 const 的使用要点</title>
    <link href="http://example.com/2020/10/13/C/C++%20%E4%B8%AD%20const%20%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A6%81%E7%82%B9/"/>
    <id>http://example.com/2020/10/13/C/C++%20%E4%B8%AD%20const%20%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A6%81%E7%82%B9/</id>
    <published>2020-10-13T06:51:24.719Z</published>
    <updated>2020-10-21T14:35:03.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-中-const-的使用要点"><a href="#C-中-const-的使用要点" class="headerlink" title="C++ 中 const 的使用要点"></a>C++ 中 const 的使用要点</h1><hr><p>const语法变化多端，但是却并非高深莫测</p><p>1、注意以下的几个 <code>const</code> 用法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *p = greeting; <span class="comment">//non-const pointer, non-const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * p = greeting;   <span class="comment">//non-const pointer, const data</span></span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> p = greeting; <span class="comment">//const pointer, non-const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> p = greeting; <span class="comment">//const pointer, const data;</span></span><br></pre></td></tr></table></figure><p><strong>const 在星号左边表示被指物是常量，const 在星号右边表示指针自身是常量</strong></p><p>2、如果被指物是常量，const 在类型名的前后意义都相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">const</span> Widget* pw)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(Widget <span class="keyword">const</span>* pw)</span></span>;</span><br><span class="line"><span class="comment">// 两者没有区别</span></span><br></pre></td></tr></table></figure><p>3、STL迭代器是以指针为根据塑膜出来的</p><p>声明迭代器为 const 和 声明 指针为 const 的大致方法相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.begin();</span><br><span class="line"><span class="comment">//iter 的作用和 T* const 类似</span></span><br><span class="line">*iter = <span class="number">10</span>; <span class="comment">// 可以改变指向物</span></span><br><span class="line">++iter; <span class="comment">// 错误！ 不可以改变 iter, 它是一个常量</span></span><br><span class="line"></span><br><span class="line">str::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator cIter = vec.begin();</span><br><span class="line"><span class="comment">//cIter 的作用和 const T* 类似</span></span><br><span class="line">*cIter = <span class="number">10</span>; <span class="comment">// 错误！不可以改变 *cIter, 它是一个常量</span></span><br><span class="line">++cIter; <span class="comment">// 可以改变 cIter 的指向</span></span><br></pre></td></tr></table></figure><h3 id="一、const-成员函数"><a href="#一、const-成员函数" class="headerlink" title="一、const 成员函数"></a>一、const 成员函数</h3><p>将 const 实施于成员函数的目的是为了能将其用于 const 对象身上</p><p>const 成员函数的重要性体现在下面两个方向：</p><ul><li>使 class 接口更加便于理解(可以清楚的看到哪个函数能够改变对象内容而哪一个不行)</li><li>使”操作 const 对象”变为可能</li></ul><p><em>两个成员函数如果常量性(constness)不同，那么可以被重载</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">class <span class="title">TextBlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">const</span> chat&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对其做一下处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tb[<span class="number">0</span>]; <span class="comment">//读一个 non-const TextBlock</span></span><br><span class="line">tb[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;    <span class="comment">//写一个 non-const TextBlock</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ctb[<span class="number">0</span>];<span class="comment">//读一个 const TextBlock</span></span><br><span class="line">ctb[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;       <span class="comment">//错误， 不能写一个 const TextBlock</span></span><br></pre></td></tr></table></figure><p>错误的原因是企图对一个”const operator[]”返回的 const char&amp; 实施赋值操作</p><p>现在对于成员函数的理解有两个主流理解：</p><ul><li><p>bitwise constness(Physcial constness)</p><p>成员函数只有在不改变对象的任何的任何成员变量(static 除外)时才能说是const。</p></li><li><p>logical constness</p><p>一个 const 成员函数可以修改它所处理的对象内的某些 bits，但是只有在客户端检测不出来的情况下才能这样处理</p></li></ul><h5 id="1、bitwise-constness"><a href="#1、bitwise-constness" class="headerlink" title="1、bitwise constness"></a>1、bitwise constness</h5><p>这种理解的好处是非常容易去检测是否遵守了 bitwise constness 准则：只需要寻找成员变量的赋值动作。</p><p>但是缺点也很明显，许多不具备 const 性质的成员函数也能通过 bitwise 测试</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个需要于 C API 沟通的 TextBlock-like class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">    &#123;<span class="keyword">return</span> pText[position];&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面所示的 class 不恰当的将其 operator[] 声明为 const 成员函数，而该函数返回一个 referrence 指向对象内部值。</p><p>当编译器认为它是 bitwise constness 时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> CTextBlock <span class="title">cctb</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span>* pc = &amp;cctb[<span class="number">0</span>]; <span class="comment">// 调用 const operator[] 取得一个指针，指向cctb[0]</span></span><br><span class="line">*pc = <span class="string">&#x27;J&#x27;</span>; <span class="comment">// 修改了 cctb[0]</span></span><br></pre></td></tr></table></figure><h5 id="2、logical-constness"><a href="#2、logical-constness" class="headerlink" title="2、logical constness"></a>2、logical constness</h5><p>有时候 TextBlock class 要 cache 文本区块的长度，以便后面使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> textLength;</span><br><span class="line">    <span class="keyword">bool</span> lengthIsValid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">CTextBlock::length</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lengthIsVailid)</span><br><span class="line">    &#123;</span><br><span class="line">        textLength = <span class="built_in">std</span>::<span class="built_in">strlen</span>(pText);</span><br><span class="line">        lengthIsValid = <span class="literal">true</span>; <span class="comment">// 这种改动很重要，但是不被编译器接受。编译器坚持 bitwise constness</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法：使用 <code>mutable</code> 关键字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> textLength;</span><br><span class="line"><span class="keyword">mutable</span> <span class="keyword">bool</span> lengthIsValid;</span><br></pre></td></tr></table></figure><h3 id="二、在-const-和-non-const-成员函数中避免重复"><a href="#二、在-const-和-non-const-成员函数中避免重复" class="headerlink" title="二、在 const 和 non-const 成员函数中避免重复"></a>二、在 const 和 non-const 成员函数中避免重复</h3><p>对于在 上一节提到的用 mutable 解决 bitwise-const 错误理解的问题，是一个不错的解法，但是不能适用于所有的 const 相关难题。</p><p>当 operator[] 操作过于复杂的时候，代码的重复量会造成很大的困扰</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...; <span class="comment">// bounding checking</span></span><br><span class="line">        ...; <span class="comment">// log access data</span></span><br><span class="line">        ...; <span class="comment">// verify data integrity</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> position) </span><br><span class="line">    &#123;</span><br><span class="line">        ...; <span class="comment">// bounding checking</span></span><br><span class="line">        ...; <span class="comment">// log access data</span></span><br><span class="line">        ...; <span class="comment">// verify data integrity</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上的代码重复发，编译时间，维护，代码膨胀……问题会让人头大</p><p>这时需要做的是： <strong>实现 operator[] 机制一次， 并两次使用</strong></p><p>需要使用的方法是: **casting away constness **      Tips: 除非是有特殊需求，一般不会推荐使用 casting 操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...; <span class="comment">// bounding checking</span></span><br><span class="line">        ...; <span class="comment">// log access data</span></span><br><span class="line">        ...; <span class="comment">// verify data integrity</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> position) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;( <span class="comment">// 第二次casting将 op[] 的 const 性质消除</span></span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>) <span class="comment">// 第一次casting，将*this的原始类型从TextBlock&amp; 转型为 const TextBlock&amp; </span></span><br><span class="line">            [position]</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上代码长尝试用 <code>non-cost operator[]</code> 调用它的 <code>const</code> 兄弟</p><p>还有一点要注意：<strong>不要用 const 版本调用 non-const 版本来避免重复</strong> </p><p>否则你之前的承诺： <strong>const 成员函数承诺不改变其对象的逻辑状态</strong> 便没有任何价值！！！💔💔💔</p><p>const 在编程的时候是一个强有力的帮手，但是要小心其使用 💖 💖 💖</p><p>总结：</p><ul><li>将某些东西声明为 const 可以帮助编译器检测错误用法。const 可以施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体</li><li>编译器会强制实施 bitwise constness，但是自己在编写程序的时候要使用 “概念上的常量” conceptual constness</li><li>当const 和 non-const 成员函数有相同的实现的时候，要用 non-const  版本来调用 const 版本</li></ul><p>​<center><font face="宋体" size=20 color=#8B008B>FINE</font></center></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-中-const-的使用要点&quot;&gt;&lt;a href=&quot;#C-中-const-的使用要点&quot; class=&quot;headerlink&quot; title=&quot;C++ 中 const 的使用要点&quot;&gt;&lt;/a&gt;C++ 中 const 的使用要点&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;const语法变化</summary>
      
    
    
    
    <category term="C/C++" scheme="http://example.com/categories/C-C/"/>
    
    
    <category term="C/C++" scheme="http://example.com/tags/C-C/"/>
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>并发：互斥与同步的各种实现</title>
    <link href="http://example.com/2020/10/07/C/%E5%B9%B6%E5%8F%91%EF%BC%9A%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2020/10/07/C/%E5%B9%B6%E5%8F%91%EF%BC%9A%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-10-07T15:21:44.913Z</published>
    <updated>2020-10-29T07:14:03.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发：互斥与同步的各种实现"><a href="#并发：互斥与同步的各种实现" class="headerlink" title="并发：互斥与同步的各种实现"></a>并发：互斥与同步的各种实现</h1><hr><p>在操作系统中，核心的设计问题在与进程和线程的管理。而在对于在<code>多道程序处理</code>, <code>多处理器环境</code>，<code>分布式系统</code>等相关领域的应用，以及操作系统设计的本身，最基础的问题就是并发(Concurrency)。</p><p><em>由于篇幅问题，在这里只讨论各种实现，不对其各种方案的优劣进行过多讨论，感兴趣的可以参考 《操作系统 精髓与设计原理》</em></p><h3 id="一、互斥的硬件支持方案"><a href="#一、互斥的硬件支持方案" class="headerlink" title="一、互斥的硬件支持方案"></a>一、互斥的硬件支持方案</h3><hr><h5 id="1、关中断"><a href="#1、关中断" class="headerlink" title="1、关中断"></a>1、关中断</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* disable interrupts */</span></span><br><span class="line">    <span class="comment">/* critical section */</span>  临界区执行</span><br><span class="line">    <span class="comment">/* enable interrupts */</span></span><br><span class="line">    <span class="comment">/* remainder */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过采用操作系统提供的原语的方式可以使临界区的执行不可以被打断，达到了互斥的效果。</p><p>但是该方案有两个明显缺陷：</p><ul><li>由于临界区的执行，导致处理器不能随意穿插执行进程，导致处理器效率明显降低</li><li>该方案不能直接用于多处理器系统中，因为在同一时间里，可能会有多个进程在同时进行，只对一个进程进行关中段不一定能保证互斥</li></ul><h5 id="2、特殊机器指令"><a href="#2、特殊机器指令" class="headerlink" title="2、特殊机器指令"></a>2、特殊机器指令</h5><p>当处理器访问某一内存地址的时候，为了通过硬件手段避免其他处理器对该内存地址的访问，设计了几条机器指令来实现两个或两个以上动作的原子性。</p><p>1&gt; 比较替换指令</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span><span class="params">(<span class="keyword">int</span> *word, <span class="keyword">int</span> testVal, <span class="keyword">int</span> newVal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldVal;</span><br><span class="line">    oldVal = *word;</span><br><span class="line">    <span class="keyword">if</span>(oldVal == testVal)</span><br><span class="line">    &#123;</span><br><span class="line">        *word = testVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125; <span class="comment">// 这个函数的操作不可被干扰或者打断，具有原子性。</span></span><br></pre></td></tr></table></figure><p>案例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* program mutualexclusion */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="comment">/* number of process */</span> 进程的数量</span><br><span class="line"><span class="keyword">int</span> bolt; 共享变量初值为 <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(compare_and_swap(bolt, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>) 只有当发现bolt为<span class="number">0</span>的进程才能进入临界区，而其他的进程不停的比较替换申请进入临界区</span><br><span class="line">              会造成忙等现象</span><br><span class="line">            <span class="comment">/* do nothing */</span>;</span><br><span class="line">        <span class="comment">/* critical section */</span>;</span><br><span class="line">        bolt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* remainder */</span>; bolt被置零后其他进程才有一个机会将bolt置<span class="number">1</span>进入临界区</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bolt = <span class="number">0</span>;</span><br><span class="line">    parbeging( p(<span class="number">1</span>), p(<span class="number">2</span>), p(<span class="number">3</span>) ......);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2&gt; 交换指令</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> *<span class="keyword">register</span>, <span class="keyword">int</span> *memory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = *memory;</span><br><span class="line">    *memory = *<span class="keyword">register</span>;</span><br><span class="line">    *<span class="keyword">register</span> = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* program mutualexclusin */</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> n = <span class="comment">/* number of process */</span>;</span><br><span class="line"><span class="keyword">int</span> bolt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> keyi = <span class="number">1</span>;</span><br><span class="line">        do exchange(&amp;key1, &amp;bolt) 如果交换后key = 1, 那么就进入临界区，否则在临界区外忙等</span><br><span class="line">        <span class="keyword">while</span>(keyi != <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* critical section */</span></span><br><span class="line">        bolt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* remainder */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bolt = <span class="number">0</span>;</span><br><span class="line">    parbegin( p(<span class="number">1</span>), p(<span class="number">2</span>), p(<span class="number">3</span>) ......);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于共享变量和局部变量的交换方式，以下的表达式始终成立<br>$$<br>bolt + \sum_ikey_{i} = 1<br>$$<br>bolt = 0 没有进程进入临界区，blot = 1 有且只有一个进程在临界区</p><h3 id="二、信号灯-Semaphore"><a href="#二、信号灯-Semaphore" class="headerlink" title="二、信号灯(Semaphore)"></a>二、信号灯(Semaphore)</h3><hr><p>信号灯是一个特殊的整型变量。向信号灯 <code>s</code> 发送信号，进程可以调用 <code>semSignal(s)</code> 原语。从信号灯处接收信号，进程可以调用<code>semWait(s)</code> 原语。如果进程打算接受消息的时候，消息尚未到达，则该进程必须在信号灯上等待。因此对信号灯做以下定义：</p><ol><li><strong>信号灯初值为非负整数。</strong></li><li><strong>semWait 操作将信号灯的值减1。如果其值为负数，调用semWait的进程执行将被阻塞。否则进程将继续执行。</strong></li><li><strong>semSignal操作将信号灯的值加1。如果之后其值小于等于0，则进程唤醒在该信号灯上等待的一个进程，并继续自己的执行。</strong></li></ol><p>（除了以上的3种操作以外不允许对信号灯做其他的操作）</p><p>信号灯的定义和操作的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    queueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semWait</span><span class="params">(semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="keyword">if</span>(count &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/* place this process in s.queue */</span>;</span><br><span class="line">        <span class="comment">/* block this process */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semSignal</span><span class="params">(semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.count++;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/* remove a process P from s.queue */</span>;</span><br><span class="line">        <span class="comment">/* palce process P on ready list */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>01信号灯，01信号灯只有两个取值：0和1，其操作原语定义如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_semaphore</span>&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;zero, oen&#125; value; 初值可以取<span class="number">0</span>或<span class="number">1</span></span><br><span class="line">    queueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semWaitB</span><span class="params">(binary_semaphore s)</span> <span class="comment">//检测信号灯的取值，如果值为0，执行semWaitB操作的进程将被阻塞。如果值为1，信号灯的值将被置0，并且进程继续执行</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.value == one)</span><br><span class="line">        s.value = zero;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">/* place this process in s.queue */</span></span><br><span class="line">        <span class="comment">/* block this process */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> semSignalB(semaphore s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">queue</span> is empty()) <span class="comment">//检测是否有进程被阻塞在信号灯上，如果有将唤醒一个被阻塞的进程。如果没有则将信号灯的值置1。</span></span><br><span class="line">        s.value = one;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">/* remove a process P from s.queue */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1、互斥的实现"><a href="#1、互斥的实现" class="headerlink" title="1、互斥的实现"></a>1、互斥的实现</h5><p>采用信号灯实现互斥的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* program mutualexclusion */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="comment">/* number of processes */</span>;</span><br><span class="line">semaphore s = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(s); <span class="comment">//进程在进入critical section前调用semWait(s)原语，如果s&lt;0,进程阻塞。如果s=1, s-1后，进程进入临界区访问公共资源</span></span><br><span class="line">        <span class="comment">/* critical section */</span>;</span><br><span class="line">        semSignal(s); <span class="comment">//最开始进入的进程执行完临界区后将信号灯的值加1，并将信号灯等待队列上的一个等待进程唤醒，并置为就绪态</span></span><br><span class="line">        <span class="comment">/* remainder */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parbegin( p(<span class="number">1</span>), p(<span class="number">2</span>), p(<span class="number">3</span>)...... );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于以上的实现，信号灯的取值 <code>s.count</code> 可以这样理解：</p><ul><li>s.count &gt;= 0：能够通过调用semWait(s)原语，而无需阻塞就能进入临界区的进程个数。信号灯的这一特性，还能用于实现进程协作。</li><li>s.count &lt; 0：其绝对值就是在s.queue上等待信号灯的进程的个数。</li></ul><h5 id="2、生产者-消费者问题"><a href="#2、生产者-消费者问题" class="headerlink" title="2、生产者/消费者问题"></a>2、生产者/消费者问题</h5><p>生产者生产数据放入缓冲区，消费者将数据从缓冲区取出，一次取一个，不允许两者对缓冲区同时操作。</p><p>假设缓冲区的结构是一个线性表。</p><p>采用01信号灯和无线缓冲来解决生产者/消费者问题的（<strong>错误</strong>）方案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* program producer&amp;consumer */</span></span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">//记录缓冲区中“产品”的个数 n = in - out</span></span><br><span class="line">binary_semaphore s = <span class="number">1</span>, delay = <span class="number">0</span>; <span class="comment">//采用delay用于在缓冲区为0的时候迫使消费者等待</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWaitB(s); <span class="comment">//生产者可以在任何时候向缓冲区放入生产的数据</span></span><br><span class="line">       append();</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) semSignalB(delay); <span class="comment">//n = 1, 之前缓冲区为0，唤醒消费者</span></span><br><span class="line">        semSignalB(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    semWaitB(delay); <span class="comment">//等待第一个可以“消费”的数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(B); </span><br><span class="line">        take();</span><br><span class="line">        n--;</span><br><span class="line">        semSignalB(B);</span><br><span class="line">        consume();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) semWaitB(delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    parbegin(producer, consumer);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">semWait(B); <span class="comment">//消费者消费完所有的数据后，需要重置delay信号，在生产者未产生出新的数据前等待</span></span><br><span class="line">   <span class="comment">//就是 if(n == 0) semWaitB(delay); 语句的作用，但是实际上并没有执行该语句，导致消费者消费了不存在的数据</span></span><br><span class="line">take();</span><br><span class="line">n--;</span><br><span class="line">semSignalB(B);</span><br></pre></td></tr></table></figure><p>原因是生产者在消费者对n再次判断之前对n进行了加1操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n++;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) semSignalB(delay); <span class="comment">//误以为是放入的第一个数据，其实是剩余的最后一个数据 </span></span><br></pre></td></tr></table></figure><p>再次调用了semSignal(delay)向delay信号灯发送了信号，而在这之前没有与之配对的semWait(delay)调用。</p><p>以下是正确方案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* program producer&amp;consumer */</span></span><br><span class="line"><span class="keyword">int</span> n; </span><br><span class="line">binary_semaphore s = <span class="number">1</span>, delay = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWaitB(s); </span><br><span class="line">       append(); </span><br><span class="line">        n++; </span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) semSignalB(delay); </span><br><span class="line">        semSignalB(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m; <span class="comment">/* a local variable */</span></span><br><span class="line">    semWaitB(delay); </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(B); </span><br><span class="line">        take(); </span><br><span class="line">        n--; </span><br><span class="line">        m = n;</span><br><span class="line">        semSignalB(B);</span><br><span class="line">        consume();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) semWaitB(delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    parbegin(producer, consumer);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用<code>信号灯和无线缓冲</code>来解决生产者/消费者问题的方案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* program producer&amp;consumer */</span></span><br><span class="line">semphore n = <span class="number">0</span>, s = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWait(s);</span><br><span class="line">        append();</span><br><span class="line">        semSignal(s); <span class="comment">//生产者的semSignal(s)和semSignal(n)对换，将导致生产者在临界区内对n信号灯进行semSignal操作，不会有不好的影响</span></span><br><span class="line">        semSignal(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            semWait(n);</span><br><span class="line">            semWait(s); <span class="comment">//如果将semWait(s)与semWait(n)对换的话，如果n为0，缓冲区为空那么会阻塞在信号灯n上，同时生产者的执行也被阻塞，导致死锁。</span></span><br><span class="line">            take();</span><br><span class="line">            semSignal(s);</span><br><span class="line">            consume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parbegin (producer, consumer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后考虑实际情况，当缓冲区有限的时候，将缓冲区设置为一个环形的结构，指针的值为对缓冲区大小取模的值，并且考虑以下的阻塞唤醒关系</p><table><thead><tr><th align="center">阻塞时机</th><th align="center">唤醒时机</th></tr></thead><tbody><tr><td align="center">生产者：往满的缓冲区中放数据</td><td align="center">消费者：数据被放入</td></tr><tr><td align="center">消费者：从空的缓冲区中区数据</td><td align="center">生产者：数据被取出</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* program boundedBuffer */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sizeofbuffer = <span class="comment">/* buffer size */</span>;</span><br><span class="line">semaphore s = <span class="number">1</span>, n = <span class="number">0</span>, e = sizeofbuffer; <span class="comment">//用信号灯e来代表缓冲区的大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWait(e);</span><br><span class="line">        semWait(s);</span><br><span class="line">        append();</span><br><span class="line">        semSignal(s);</span><br><span class="line">        semSignal(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(n);</span><br><span class="line">        semWait(s);</span><br><span class="line">        take();</span><br><span class="line">        semSignal(s);</span><br><span class="line">        semSignal(e);</span><br><span class="line">        consume();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parbegin( producer, consumer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、信号灯的实现"><a href="#3、信号灯的实现" class="headerlink" title="3、信号灯的实现"></a>3、信号灯的实现</h5><p>比较和替换指令实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">semWait(s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(compare_and_swap(s.flag, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    <span class="comment">/* do nothing */</span>;</span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* place this process in s.queue */</span>;</span><br><span class="line">        <span class="comment">/* block this process(must also set s.flag to 0) */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">semSignal(s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(compare_and_swap(s.flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        <span class="comment">/* do nothing */</span>;</span><br><span class="line">    s.count++;</span><br><span class="line">   <span class="keyword">if</span>(s.count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* remove a process in form s.queue */</span>;</span><br><span class="line">        <span class="comment">/* place a process P on ready list */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中断实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">semWait(s)</span><br><span class="line">&#123;</span><br><span class="line">    inhibit interrupts;</span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* place this process in s.queue */</span>;</span><br><span class="line">        <span class="comment">/* block this process and allow interrupts */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        allow interrupts;</span><br><span class="line">&#125;</span><br><span class="line">semSignal(s)</span><br><span class="line">&#123;</span><br><span class="line">    inhibit interrupts;</span><br><span class="line">    s.count++;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* remove a process P from s.queue */</span>;</span><br><span class="line">        <span class="comment">/* place process P on ready list */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    allow interrupts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、管程-Monitor"><a href="#三、管程-Monitor" class="headerlink" title="三、管程(Monitor)"></a>三、管程(Monitor)</h3><hr><p>采用信号灯的方式实现正确的程序并不容易，因为semWait和semSignal操作分布于操作系统的各个地方，从而很难看到这些信号灯操作的整体效果所导致的。</p><p><code>管程</code> 的提出就是希望设计一种程序设计语言，它能够提供和信号灯相同的功能且易于控制。</p><h5 id="1、管程和信号"><a href="#1、管程和信号" class="headerlink" title="1、管程和信号"></a>1、管程和信号</h5><p>管程可以看作是包含了一个或者多个函数，一个初始化过程，以及本地数据的软件模块。主要特征如下</p><ul><li>本地数据只能够被管程的内部函数所访问，外部函数无法 访问其本地</li><li>进程只能通过调用管程自己定义的函数来进入管程</li><li>在管程内执行的进程一次只能有一个；当管程被占用，其他试图进入的进程将被阻塞，等待管程重新可用后才能进入。</li></ul><p>管程定义了一个同步工具用来更好地支持并发处理。当某一个进入管程的进程因为不满足某个执行条件而必须被阻塞的时候，那么便需要某种机制(同步工具)使得该进程在被阻塞后释放管程，之后在其满足运行条件后，该进程能够重新回到管程中继续执行。</p><p>管程采用了 <code>条件变量(Condition Variables)</code> 方法来实现这种同步工具，并且只能用以下两个函数来访问。</p><ul><li>cwait(c)：将调用该函数访问条件变量c的进程阻塞，并且释放管程给其他的进程使用。</li><li>csignal(c)：继续执行之前因为调用cwait函数访问条件变量c而阻塞的进程。如果这类进程有多个，那么选择其中之一；如果没有，则不做任何操作。</li></ul><p>采用管程来解决有限缓冲区生产者/消费者问题的方案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* program production&amp;consumer */</span></span><br><span class="line">monitor bunderbuffer;</span><br><span class="line"><span class="keyword">char</span> buffer [N];</span><br><span class="line"><span class="keyword">int</span> nextin, next out;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">cond notfull, notempty;</span><br><span class="line"><span class="comment">//notfull: 缓冲区有剩余空间时为真 notempty：缓冲区中有有效计算结果时为真</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count == N) cwait(notfull); <span class="comment">// buffer满了，要避免overflow</span></span><br><span class="line">    buffer[nextin] = x;</span><br><span class="line">    nextin = (nextin + <span class="number">1</span>) % N;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">/* one more item in buffer */</span></span><br><span class="line">    csignal(notempty); <span class="comment">// resume any waiting consumer</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>) cwait(notempty); <span class="comment">//buffer空，避免underflow</span></span><br><span class="line">    x = buffer[nextout];</span><br><span class="line">    nextout = (nextout + <span class="number">1</span>) % N;</span><br><span class="line">    count--;</span><br><span class="line">    csignal(notfull); <span class="comment">//resume any waiting producer</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    nextin = <span class="number">0</span>; nextout = <span class="number">0</span>; count = <span class="number">0</span>; <span class="comment">//buffer 初始化为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        produce(x);</span><br><span class="line">        append(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        take(x);</span><br><span class="line">        consume(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parbegin( producer, consumer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>管程的真正优势就在于它所有的操作都被限制在管程内部，这样就更容易检查设计是否正确。</p><h5 id="2、采用通知和广播的管程模型"><a href="#2、采用通知和广播的管程模型" class="headerlink" title="2、采用通知和广播的管程模型"></a>2、采用通知和广播的管程模型</h5><p>在 <code>Mesa</code> 语言中，csignal原语被cnotify原语替代，当管程调用了cnotify(x)原语后，它将导致条件变量x的等待队列收到通知，且调用cnotify(x)原语的进程将继续执行。</p><p>用while语句替换if语句，这样就保证了条件变量的重新检测。同时避免了进程的额外切换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(count == N) cwait(notfull); <span class="comment">/* buffer is full avoid overflow */</span></span><br><span class="line">    buffer[nextin] = x;</span><br><span class="line">    nextin = &#123;nextin + <span class="number">1</span>&#125; % N;</span><br><span class="line">    count++;</span><br><span class="line">    cnotify(notempty); <span class="comment">/* notify any waiting consumer */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(count == <span class="number">0</span>) cwait(notempty); <span class="comment">/* buffer is empty; avoid underflow */</span></span><br><span class="line">    x = buffer[nextout];</span><br><span class="line">    nextout = (nextout + <span class="number">1</span>) % N; <span class="comment">/* one fewer item in buffer */</span></span><br><span class="line">    cnotify[notfull]; <span class="comment">/* notify ant waiting producer */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、消息通信"><a href="#四、消息通信" class="headerlink" title="四、消息通信"></a>四、消息通信</h3><hr><p>一般来说，进程的交互和协作需要两个基本元素：同步和通信。同步用于进程的互斥，通信则用于进程间的协作。 <code> 消息通信</code> 就能提供这两个基本元素，而且应用范围很广。不同的操作系统对消息通信的实现的细节上有所出入。以下内容讨论其实现的共性的部分。</p><p>消息通信的基本形式为以下两个原语：</p><ul><li>send(destination, message)</li><li>receive(source, message)</li></ul><p>采用send原语，一个进程可以将消息发送给另一个进程(destination)；采用receive原语，一个进程可以接收来自消息源的消息。</p><h5 id="1、同步"><a href="#1、同步" class="headerlink" title="1、同步"></a>1、同步</h5><p>无论消息发送还是消息接受都有阻塞和非阻塞两种可能。在具体的系统设计中有以下3中组合。</p><ul><li><p>发送端阻塞，接收端阻塞</p><p>两端都阻塞，消息被接收后再将两端唤醒。这一组合又被称为交汇点(rendzvous)方案，常被用于要求进程强行同步通信的场合</p></li><li><p>发送端不阻塞，接收端阻塞</p><p>发送端在发送完消息后继续执行，而接收端必须阻塞，直到接收到消息后才被唤醒。这一方案是是被最广泛应用的，能够最快的将消息发送给多个目的进程，而接收端必须等待消息到达后才能做有用的工作。</p></li><li><p>发送端不阻塞，接收端阻塞</p></li></ul><h5 id="2、互斥的实现"><a href="#2、互斥的实现" class="headerlink" title="2、互斥的实现"></a>2、互斥的实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* program mutualexclusion */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="comment">/* number of process */</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    message msg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        receive(box, msg); <span class="comment">// 任何希望进入临界区的进程都必须先获得一个消息，如果邮箱为空</span></span><br><span class="line">        <span class="comment">/* critical section */</span>;</span><br><span class="line">        send(box, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">create <span class="title">mailbox</span><span class="params">(box)</span></span>; <span class="comment">//初始化阶段，邮箱中只存放了一个内容为null的消息</span></span><br><span class="line">    send(box, null);</span><br><span class="line">    parbegin( p(<span class="number">1</span>), p(<span class="number">2</span>), p(<span class="number">3</span>)...... );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果并发地调用消息接收原语，那么就会有：</p><ul><li>如果邮箱中有一个消息，该消息将被一个进程接收，而其他的进程都将阻塞</li><li>如果邮箱中没有消息，所有的进程都将被阻塞。而当之后有一个消息传入邮箱后，只有一个等待态的进程被唤醒，并获得该消息</li></ul><p>采用消息通信来解决有限缓冲的生产者/消费者问题的方案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span></span><br><span class="line">    capacity = <span class="comment">/* buffering capacity */</span>;</span><br><span class="line">null = <span class="comment">/* empty message */</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    message pmsg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        receive(mayproduce, pmsg); <span class="comment">//生产者接收到生产的消息</span></span><br><span class="line">        pmsg = produce(); <span class="comment">//pmsg 表示生产完成,等同于完成临界区</span></span><br><span class="line">        send(mayconsume, pmsg);  <span class="comment">//向消费者发送发消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    message cmsg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        receive(mayproduce, cmsg); <span class="comment">//从mayproduce接收到有数据的消息cmsg</span></span><br><span class="line">        consume(cmsg); <span class="comment">//进入消费的临界区</span></span><br><span class="line">        send(mayproduce, null); <span class="comment">//消费完成，向mayproduce发送空消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    create_mailbox(mayproduce); <span class="comment">//该方案设计了两个邮箱</span></span><br><span class="line">    create_mailbox(mayconsume);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; capacity; i++)send(mayproduce, null);</span><br><span class="line">    parbegin( producer, consumer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案非常灵活，可以容纳多个生产者以及多个消费者同时工作。另外，该方案也可以在分布式系统中实现有限缓冲的生产者消费者问题，其中生产者、消费者以及两个邮箱都可以放置在不同的机器上面。</p><h3 id="五、读者-写者问题"><a href="#五、读者-写者问题" class="headerlink" title="五、读者/写者问题"></a>五、读者/写者问题</h3><hr><p>读者/写者问题是另一个经典的同步和并发问题，描述如下：</p><p>有一块共享的数据区域(该区域可以是一个文件，一块内存或处理器中的一组寄存器)，有一组进程(读者)，它们对该共享数据区的访问都是只读的，另外还有一组进程(写者)，它们对该共享数据的访问只是只写。访问规则如下：</p><ol><li>可以有任意多个读者同时读取数据区的内容；</li><li>一次只有一个写者允许向数据区中写；</li><li>写者在向数据区中写时，不允许读者同时读取；</li></ol><p>读者对共享数据区的访问不是独占的，但写者对共享数据区的访问是独占的，无论读者或者写者都不允许同时访问该共享数据区。</p><h5 id="1、读者优先"><a href="#1、读者优先" class="headerlink" title="1、读者优先"></a>1、读者优先</h5><p>采用信号灯解决读者/写者问题的方案：读者优先</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* program readers&amp;writers */</span></span><br><span class="line"><span class="keyword">int</span> readcount;</span><br><span class="line">semaphore x = <span class="number">1</span>, wsem = <span class="number">1</span>; <span class="comment">//信号灯wsem用于互斥访问。当有写者在访问共享数据时，不允许读者或者写者同时访问共享数据。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(x);</span><br><span class="line">        readcount++;</span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">1</span>) <span class="comment">//为了使多个读者能够同时访问共享数据而且不会于写者冲突，该方案要求第一个读者必须等待wsem</span></span><br><span class="line">       semWait(wsem); <span class="comment">//信号灯，但是后续到达的读者可以不用等待到达的信号灯就直接进入临界区</span></span><br><span class="line">        semSignal(x);</span><br><span class="line">        READUNIT();</span><br><span class="line">        semWait(x);</span><br><span class="line">        readcount--;</span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">0</span>)</span><br><span class="line">            semSignal(wsem);</span><br><span class="line">        semSignal(x); <span class="comment">// 信号灯x用于保证对readcount的更新操作的正确执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(wsem);</span><br><span class="line">        WRITEUNIT();</span><br><span class="line">        semSignal(wsem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    readcount = <span class="number">0</span>;</span><br><span class="line">    parbegin( reader, writer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案的最大问题是如果读者过多的话会造成写者的饥饿问题。</p><p>采用写者优先方案可以解决这个问题</p><h5 id="2、写者优先"><a href="#2、写者优先" class="headerlink" title="2、写者优先"></a>2、写者优先</h5><ul><li>只要写者申请访问数据区时，阻止所有读者对共享数据的访问；</li><li>全局变量writecount，用于控制对rsem的设置</li><li>信号灯y，用于控制对writecount的更新</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readcount, writecount, semphore x = <span class="number">1</span>, y = <span class="number">1</span>, z = <span class="number">1</span>, wsem = <span class="number">1</span>, rsem = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(z);</span><br><span class="line">        semWait(rsem); <span class="comment">// 写者对rsem进行了设置，一个读者在rsem上等待，其他读者全在z上等待</span></span><br><span class="line">        semWait(x);</span><br><span class="line">        readcount++;</span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">1</span>) <span class="comment">//新的方案只允许一个读者在rsem上等待，后续到达的读者必须在z上等待</span></span><br><span class="line">                 semWait(wsem); </span><br><span class="line">        semSignal(x);</span><br><span class="line">        semSignal(rsem);</span><br><span class="line">        semSignal(z);</span><br><span class="line">        READUNIT();</span><br><span class="line">        semWait(x);</span><br><span class="line">        readcount--;</span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">0</span>) semSignal(wsem);</span><br><span class="line">        semSignal(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semWait(y);</span><br><span class="line">        writecount++;</span><br><span class="line">        <span class="keyword">if</span>(writecount == <span class="number">1</span>) </span><br><span class="line">                semWait(rsem);</span><br><span class="line">        semSignal(y);</span><br><span class="line">        semWait(wsem); <span class="comment">// 写者全在wsem上排队</span></span><br><span class="line">        WRITEUNIT();</span><br><span class="line">        semSignal(wsem);</span><br><span class="line">        semWait(y);</span><br><span class="line">        writecount--;</span><br><span class="line">        <span class="keyword">if</span>(writecount == <span class="number">0</span>)semSignal (rsem); <span class="comment">//</span></span><br><span class="line">        semSignal(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    readcount = writecount = <span class="number">0</span>;</span><br><span class="line">    parbegin( reader, writer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所示方案中进程队列情况</p><table><thead><tr><th align="center">读写者情况</th><th align="center">信号灯设置以及排队情况</th></tr></thead><tbody><tr><td align="center">系统中只有读者</td><td align="center">1、wsem设置  2、无排队</td></tr><tr><td align="center">系统中只有写者</td><td align="center">1、wsem和rsem设置  2、写者在wsem上排队</td></tr><tr><td align="center">有读者和写者，读者在前</td><td align="center">1、wsem被读者设置  2、rsem被写者设置  3、所有写者在wsem上排队</td></tr><tr><td align="center"></td><td align="center">4、一个读者在resm上排队  5、其他读者在z上排队</td></tr><tr><td align="center">有读者和写者，写者在前</td><td align="center">1、wsem被写者设置  2、rsem被写者设置  3、写者在wsem上排队</td></tr><tr><td align="center"></td><td align="center">4、一个读者在rsem上排队  5、其他读者在z上排队</td></tr></tbody></table><h5 id="3、采用消息通信来解决读者-写者问题-写者优先"><a href="#3、采用消息通信来解决读者-写者问题-写者优先" class="headerlink" title="3、采用消息通信来解决读者/写者问题(写者优先)"></a>3、采用消息通信来解决读者/写者问题(写者优先)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    message rmsg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        send(readrequest, rmsg);</span><br><span class="line">        receive(mbox[i], rmsg);</span><br><span class="line">        READUNIT();</span><br><span class="line">        send(finished, rmsg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">(<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    message rmsg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        send(writerequest, rmsg);</span><br><span class="line">        receive(mbox[j], rmsg);</span><br><span class="line">        WRITEUNIT();</span><br><span class="line">        rmsg = j;</span><br><span class="line">        send(finished, rmsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">controller</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">0</span>) <span class="comment">// count&gt;0，说明没有写者在等待，且有读者在临界区。此时先处理finish消息，然后是写请求，最后是读者请求</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!empty(finshed))</span><br><span class="line">            &#123;</span><br><span class="line">                recevie(finished, msg);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!empty(writerequest))</span><br><span class="line">            &#123;</span><br><span class="line">                receive(writerequest, msg);</span><br><span class="line">                write_id = msg.id;</span><br><span class="line">                count = count - <span class="number">100</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!empty(readrequest))</span><br><span class="line">            &#123;</span><br><span class="line">                receive(readrequest, msg);</span><br><span class="line">                count--;</span><br><span class="line">                send(msg.id, <span class="string">&quot;OK&quot;</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) <span class="comment">//count=0，说明收到了写者的请求，允许写者进入临界区，并且等待“finish”消息</span></span><br><span class="line">        &#123;</span><br><span class="line">            send (write_id, <span class="string">&quot;OK&quot;</span>);</span><br><span class="line">            receive(finished, msg);</span><br><span class="line">            count = <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; <span class="number">0</span>) <span class="comment">//count&lt;0，说明收到了写者的请求，但此时有读者正在临界区中。此时，就只处理“finish”消息</span></span><br><span class="line">        &#123;</span><br><span class="line">            receive(finshed, msg);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; <strong>fine~~</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;并发：互斥与同步的各种实现&quot;&gt;&lt;a href=&quot;#并发：互斥与同步的各种实现&quot; class=&quot;headerlink&quot; title=&quot;并发：互斥与同步的各种实现&quot;&gt;&lt;/a&gt;并发：互斥与同步的各种实现&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;在操作系统中，核心的设计问题在与进程和线程</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>利用汇编深入学习C++</title>
    <link href="http://example.com/2020/09/26/C/%E5%88%A9%E7%94%A8%E6%B1%87%E7%BC%96%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0C++/"/>
    <id>http://example.com/2020/09/26/C/%E5%88%A9%E7%94%A8%E6%B1%87%E7%BC%96%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0C++/</id>
    <published>2020-09-26T04:31:42.676Z</published>
    <updated>2020-10-05T03:21:56.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、基础内容"><a href="#一、基础内容" class="headerlink" title="一、基础内容"></a>一、基础内容</h1><h3 id="1、杂项"><a href="#1、杂项" class="headerlink" title="1、杂项"></a>1、杂项</h3><hr><h5 id="（1）汇编语言，机器语言，高级语言"><a href="#（1）汇编语言，机器语言，高级语言" class="headerlink" title="（1）汇编语言，机器语言，高级语言"></a>（1）汇编语言，机器语言，高级语言</h5><p><code>汇编语言</code>与<code>机器语言</code>一一对应，每一条机器指令都有与之相对的汇编指令</p><p><code>汇编语言</code>可以通过编译得到<code>机器语言</code>，<code>机器语言</code>可以通过反汇编得到<code>汇编语言</code></p><p><code>高级语言</code>可以通过编译得到<code>汇编语言\机器语言</code>，但是<code>汇编语言\机器语言</code>几乎不可能还原成<code>高级语言</code></p><p>​&emsp;&emsp;&emsp;&emsp;&emsp;编译        </p><p>​&emsp;汇编语言 ——&gt; 机器语言</p><p>​            mov ax, bx&lt;—— 0010101011</p><p>​&emsp;&emsp;&emsp;&emsp;反编译</p><p>eg：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line">Date d = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">C7 <span class="number">45</span> F0 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> movdword ptr [ebp<span class="number">-10</span>h],<span class="number">1</span></span><br><span class="line">C7 <span class="number">45</span> F4 <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> movdword ptr [ebp<span class="number">-0</span>Ch],<span class="number">2</span></span><br><span class="line">C7 <span class="number">45</span> F8 <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> movdword ptr [ebp<span class="number">-8</span>],<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">C7 <span class="number">45</span> F0 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> movdword ptr [ebp<span class="number">-10</span>h],<span class="number">1</span></span><br><span class="line">C7 <span class="number">45</span> F4 <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> movdword ptr [ebp<span class="number">-0</span>Ch],<span class="number">2</span></span><br><span class="line">C7 <span class="number">45</span> F8 <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> movdword ptr [ebp<span class="number">-8</span>],<span class="number">3</span></span><br><span class="line"><span class="comment">/*注意到两者的机器码和汇编码完全一样，所以只确定汇编\机器语言不能还原为唯一确定的高级语言，如果一定需要</span></span><br><span class="line"><span class="comment">相关高级语言，那么可以将其还原为伪代码，在人为还原为高级语言。*/</span></span><br></pre></td></tr></table></figure><p>​    <strong>在不同架构的CPU下，生成的汇编码不一样</strong></p><h5 id="（2）一些编程语言的本质区别"><a href="#（2）一些编程语言的本质区别" class="headerlink" title="（2）一些编程语言的本质区别"></a>（2）一些编程语言的本质区别</h5><ul><li><p>C++</p><blockquote><p>轻易反汇编</p></blockquote><p>编译器编译为汇编代码，可以和机器码进行转换</p></li><li><p>JavaScript</p><blockquote><p>脚本语言，由浏览器进行解析</p></blockquote></li><li><p>PHP</p><blockquote><p>脚本语言，由Zend Engine(ZE)进行解析</p></blockquote><p>JS 和 PHP 在通过引擎解析后变为中间代码，然后转为<code>机器码(不同语言的机器码不同)</code>，所以不好接触到底层</p></li><li><p>Java</p><blockquote><p>由JVM进行装载字节码</p></blockquote><p>编译器编译为class（字节码），然后通过JVM虚拟机形转为器码</p></li></ul><p>无论用什么语言编写代码，最终会形成几乎相同的机器码。</p><h3 id="2、函数重载（Overload）"><a href="#2、函数重载（Overload）" class="headerlink" title="2、函数重载（Overload）"></a>2、函数重载（Overload）</h3><hr><ul><li><p>规则</p><blockquote><p>函数名相同</p><p>参数个数不同、参数类型不同、参数顺序不同</p></blockquote></li><li><p>注意</p><blockquote><p>返回值类型与函数重载无关</p><p>调用函数时，实参的隐式类型转换可能会产生二义性</p></blockquote></li></ul><ul><li><p>本质</p><blockquote><p>采用了name mangling或者叫name decoration的技术，C++编译器默认会对符号名（比如函数名）进行改变，修饰。</p><p>重载时产生的函数名字和编译器有关，不同编译器不同，产生的名字不同。</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;         <span class="function">call<span class="title">display</span><span class="params">(<span class="number">0</span>CA1429h)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//...</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;<span class="function">call<span class="title">display</span><span class="params">(<span class="number">0</span>CA13F7h)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//...</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">long</span> a)</span></span>&#123;<span class="function">call<span class="title">display</span><span class="params">(<span class="number">0</span>CA1230h)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//...</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(doble a)</span></span>&#123;<span class="function">call<span class="title">display</span><span class="params">(<span class="number">0</span>CA10B4h)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//...</span></span></span><br><span class="line">&#125;</span><br><span class="line">VS简化了函数名，使其看上去一样，但函数后面括号里的不同数值表示调用的函数地址并不相同。</span><br></pre></td></tr></table></figure><p>使用IDA进行逆向工程，在main文件里查看汇编码：</p><blockquote><p>记得将程序以release版本生成，去除调试信息，使文件精简。但是相对的release会对程序进行相应的优化，比如上面4个打印函数，编译器会直接将4个函数改为4个直接输出，不再进行函数调用。所以要将编译器的优化选项关闭。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">calldisplay</span><br><span class="line">calldisplay_1</span><br><span class="line">calldisplay_2</span><br><span class="line">calldisplay_3可见的确进行了name mangling使函数重载得以实现</span><br></pre></td></tr></table></figure><h3 id="3、默认参数"><a href="#3、默认参数" class="headerlink" title="3、默认参数"></a>3、默认参数</h3><hr><p>C++允许函数设置默认参数，在调用时可以根据情况省略实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> v1 = <span class="number">5</span>, <span class="keyword">int</span> v2 = <span class="number">6</span>)</span></span>&#123; <span class="comment">// 默认参数值必须从右边开始 int v1 = 10, int v2 ---&gt; 编译不通过</span></span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum(<span class="number">10</span>) &lt;&lt;<span class="built_in">endl</span>;<span class="comment">// 16</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 30</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//同时有声明和实现的时候，只能在声明处填默认参数</span></span><br></pre></td></tr></table></figure><p>默认参数的值可以是常量、全局符号（全局变量、函数名）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> v1 = <span class="number">5</span>, <span class="keyword">int</span> v2 = <span class="number">6</span>)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;test(int) - &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">void</span>(*p)(<span class="keyword">int</span>) = test)</span></span>&#123; <span class="comment">//函数指针</span></span><br><span class="line">    p(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>(*p)(<span class="keyword">int</span>) = test;</span><br><span class="line">    p(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum(<span class="number">10</span>) &lt;&lt;<span class="built_in">endl</span>;<span class="comment">// 16</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 30</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>如果函数的参数经常使用同一个值，推荐使用默认参数</strong></p><p>函数重载和默认参数共同使用的时候会产生冲突、二义性。在这种情况下建议优先选择默认参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    display(<span class="number">10</span>); <span class="comment">//报错，编译不通过</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认参数的本质：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">push<span class="number">2</span></span><br><span class="line">push<span class="number">1</span>    <span class="comment">//传参</span></span><br><span class="line"><span class="function">call<span class="title">sum</span><span class="params">(<span class="number">0F</span>E1424h)</span></span></span><br><span class="line">addesp,8</span><br><span class="line"></span><br><span class="line">sum(<span class="number">2</span>, <span class="number">4</span>); </span><br><span class="line">push<span class="number">4</span></span><br><span class="line">push<span class="number">2</span></span><br><span class="line"><span class="function">call<span class="title">sum</span><span class="params">(<span class="number">0F</span>E1424h)</span> <span class="comment">//调用相同的函数地址</span></span></span><br><span class="line">addesp,8</span><br></pre></td></tr></table></figure><p>添加默认参数</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2 = <span class="number">4</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>);</span><br><span class="line">push<span class="number">4</span></span><br><span class="line">push<span class="number">1</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//也就是说 sum(1); 和 sum(1, 4); 是完全一样的功能，经验证机器码也是几乎一样。</span></span><br><span class="line"><span class="function">E8 A3 F2 FF FFcall<span class="title">sum</span><span class="params">(<span class="number">01271424</span>h)</span></span></span><br><span class="line">E8 97 F2 FF FFcallsum(01271424h)  仅有E8 后面计算出的地址值有细微区别 (详见Intel机器码白皮书)</span><br></pre></td></tr></table></figure><h3 id="4、extern-“C”"><a href="#4、extern-“C”" class="headerlink" title="4、extern “C”"></a>4、extern “C”</h3><hr><p>被<code>extern &quot;C&quot;</code>修饰的代码会按照C语言的规范去编译</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line">exterm <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123; <span class="comment">//报错，因为C不支持重载</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果函数同时有声明与实现，要在声明处使用<code>extern &quot;C&quot;</code>，在实现处可以不用添加。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> v)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">为方便使用直接在头文件使用</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;****.h&quot;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用场景：</p><ul><li>使用用C语言开发的第三方框架\库</li></ul><p>在C\C++混合开发的时候会出现大量问题，推荐按一下方式使用<code>extern &quot;C&quot;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus <span class="comment">//使用宏</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>为了避免重复引用，用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ***</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ***</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>但是一定要保证每一个文件里的宏都不相同，推荐将宏和文件名字相同。<code>#pragma once</code> 可以保证整个文件内容只被编译一次，避免重复包含，但是 <code>#pragma once</code>不被某些编译器支持。</p><h3 id="5、内联函数"><a href="#5、内联函数" class="headerlink" title="5、内联函数"></a>5、内联函数</h3><hr><p>使用<code>inline</code>关键字将其变为内联函数。编译器直接将函数调用展开为函数体代码。</p><p>在函数开始的时候会开辟栈空间，函数结束的时候回收栈空间。内联函数在代码体积不大和使用次数过多的时候推荐使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">int</span> c = sum(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    不内联</span><br><span class="line">    push<span class="number">14</span>h</span><br><span class="line">    push<span class="number">0</span>Ah</span><br><span class="line">    <span class="function">call<span class="title">sum</span><span class="params">(<span class="number">08110</span>A0h)</span></span></span><br><span class="line">    在release模式下，编译器会直接将sum函数优化，直接给出返回值，不再调用函数。</span><br><span class="line">    把优化关闭，进行相关调整后</span><br><span class="line">    moveax,<span class="number">0</span>Ah</span><br><span class="line">   add eax,<span class="number">14</span>h</span><br><span class="line">    movdword ptr [c],eax  <span class="comment">//等同于直接实现 10 + 20 </span></span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内联函数与宏对比：</p><ul><li>两者都能减少函数调用</li><li>相比于宏内联函数具有函数特性，拥有语法检测和代码提示功能</li></ul><h3 id="6、表达式"><a href="#6、表达式" class="headerlink" title="6、表达式"></a>6、表达式</h3><hr><ul><li><p>C++有些表达式能被赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">(a = b) = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// a = 4; b = 2;</span></span><br><span class="line">(a &gt; b ? a : b) = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// b = 4</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="7、const"><a href="#7、const" class="headerlink" title="7、const"></a>7、const</h3><hr><ul><li><p>const是常量的意思，被修饰的变量不可修改</p><p>如果修饰的是类、结构体(的指针)，成员函数不可以更改</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p0 = &amp;age;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p1 = &amp;age; <span class="comment">// p0 p1 等价，都被const修饰</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p2 = &amp;age;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p3 = &amp;age;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p4 = &amp;age; <span class="comment">// p3 p4 等价</span></span><br></pre></td></tr></table></figure><p>对于const有以下结论：</p><ul><li><p>const修饰的是其右边的内容 </p><blockquote><p>const int * <code>const p3</code> = &age;  意味着p3为常量但是*p3不是常量，可以对 *p3进行修改</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span> <span class="keyword">int</span> age; &#125;;</span><br><span class="line">Student stu1 = &#123;<span class="number">20</span>&#125;;</span><br><span class="line">Student stu2 = &#123;<span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Student *pStu1 = &amp;stu1;</span><br><span class="line">*pStu1 = stu2; <span class="comment">// 报错，const修饰*pStu1不能被赋值</span></span><br><span class="line">(*pStu1).age = <span class="number">30</span>; </span><br><span class="line">pStu1-&gt;age = <span class="number">30</span>; <span class="comment">// 报错，为了保证const的严谨性，不允许通过指针访问成员属性</span></span><br><span class="line">pStu1 = &amp;stu2;</span><br><span class="line"></span><br><span class="line">Student * <span class="keyword">const</span> pStu2 = &amp;stu2;</span><br><span class="line">*pStu2 = stu1;</span><br><span class="line">(*pStu2).age = <span class="number">30</span>;</span><br><span class="line">pStu2-&gt;age = <span class="number">30</span>;</span><br><span class="line">pStu2 = &amp;stu1; <span class="comment">// 报错，不能修改pStu2的内容</span></span><br></pre></td></tr></table></figure><h3 id="8、引用-Reference"><a href="#8、引用-Reference" class="headerlink" title="8、引用(Reference)"></a>8、引用(Reference)</h3><hr><p>在C语言中，使用<code>指针(Pointer)</code>可以间接获取、修改某个变量的值</p><p>在C++中，使用<code>引用(Reference)</code>可以起到更指针类似的功能</p><p>引用的注意点：</p><ul><li>引用相当于变量的别名</li><li>对引用做计算等于对其指向的变量做运算</li><li>必须在定义的时候初始化，而且一旦指向某个变量就不可以再改变</li><li>可以利用一个引用初始化另一个引用，相当于一个变量有多个别名</li><li>不存在<code>引用的引用</code>、<code>指向引用的指针</code>、<code>引用数组</code></li></ul><p>引用的价值：比指针更安全、函数返回值可以被赋值</p><h5 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h5><ul><li>引用的本质就是指针，只是编译器削弱了它的功能，引用就是弱化了的指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> &amp;age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(student) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8 X64环境 也就是从侧面证明了引用的大小为8bit</span></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编码(关闭显示符号):</p><ul><li>指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;age;</span><br><span class="line">leaeax,[ebp<span class="number">-18</span>h],eax</span><br><span class="line">movdword ptr [ebp<span class="number">-18</span>h],eax</span><br><span class="line">*p = <span class="number">30</span>;</span><br><span class="line">mov eax,dword ptr [ebp<span class="number">-18</span>h]</span><br><span class="line">mov dword ptr [eax],<span class="number">1</span>Eh</span><br></pre></td></tr></table></figure><ul><li>引用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;ref = age;</span><br><span class="line">leaeax,[ebp<span class="number">-18</span>h],eax</span><br><span class="line">movdword ptr [ebp<span class="number">-18</span>h],eax</span><br><span class="line">ref = <span class="number">30</span>;</span><br><span class="line">mov eax,dword ptr [ebp<span class="number">-18</span>h]</span><br><span class="line">mov dword ptr [eax],<span class="number">1</span>Eh</span><br></pre></td></tr></table></figure><p>通过对比发现两者的汇编码完全一样，所以一个引用也就占用一个指针的大小</p><h1 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a>二、基础语法</h1><h3 id="1、x86，x64汇编"><a href="#1、x86，x64汇编" class="headerlink" title="1、x86，x64汇编"></a>1、x86，x64汇编</h3><hr><p>汇编语言的种类</p><ul><li>8086汇编</li><li>x86汇编</li><li>x64汇编</li><li>ＡＲＭ汇编</li><li>．．．．．．</li></ul><p>根据编译器不同，有两种书写格式</p><ul><li>Intel(Visual Studio)</li><li>AT&amp;T(Mac)</li></ul><h5 id="x64汇编-寄存器"><a href="#x64汇编-寄存器" class="headerlink" title="x64汇编- 寄存器"></a>x64汇编- 寄存器</h5><p>不同汇编的寄存器不同</p><p>常用寄存器：</p><table><thead><tr><th align="left">标识符</th><th align="left"></th></tr></thead><tbody><tr><td align="left"><strong>RAX\RBX\RCX\RDX</strong></td><td align="left"><strong>(64bit下常见)通用寄存器</strong></td></tr><tr><td align="left"><strong>EAX\EBXECX\EDX</strong></td><td align="left"><strong>(32bit下常见))通用寄存器</strong></td></tr><tr><td align="left"><strong>AX\BX\CX\DX</strong></td><td align="left"><strong>(16bit下常见)通用寄存器</strong></td></tr></tbody></table><p>tips：</p><blockquote><ul><li><p>一个寄存器能存8个字节(x64)</p></li><li><p>为了使新的寄存器兼容老旧的寄存器将新寄存器分成更小的区块来存储旧的寄存器</p></li></ul><table><thead><tr><th>63…32</th><th>31…16</th><th>15…8</th><th>7…0</th></tr></thead><tbody><tr><td></td><td></td><td><strong>AH…</strong></td><td><strong>AL…</strong></td></tr><tr><td></td><td></td><td><strong>AX…</strong></td><td><strong>…</strong></td></tr><tr><td></td><td><strong>EAX…</strong></td><td><strong>…</strong></td><td><strong>…</strong></td></tr><tr><td><strong>RAX…</strong></td><td><strong>…</strong></td><td><strong>…</strong></td><td><strong>…</strong></td></tr></tbody></table><p>AH H high</p><p>AL  L low</p></blockquote><h3 id="2、内联汇编"><a href="#2、内联汇编" class="headerlink" title="2、内联汇编"></a>2、内联汇编</h3><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    __asm&#123; <span class="comment">//x86</span></span><br><span class="line">        mov eax, a  <span class="comment">//真实的汇编不会存在a这个符号  实际的汇编码为 eax,dword ptr[ebp-oCh]</span></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、常见指令"><a href="#3、常见指令" class="headerlink" title="3、常见指令"></a>3、常见指令</h3><hr><ul><li><p>mov              dest, src</p><blockquote><p>将src内容赋值给dest，类似于dest = src</p></blockquote></li><li><p>[地址值]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = a + <span class="number">1</span>；</span><br><span class="line">    </span><br><span class="line">mov           dword ptr [ebp<span class="number">-8</span>], <span class="number">3</span></span><br><span class="line"><span class="comment">//mov [1122h], 3 意味着将3放入[1122h]所在的地址空间</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p><strong>mov                 [1128h], 3</strong></p><p><strong><code>word</code>是2个字节，<code>dword</code>是4个字节，<code>qword</code>是8个字节</strong></p><p><strong>mov                 dword ptr [1128h], 3</strong>  //将3放到地址以1128h开始的内存中，并占用dword个内存地址**(向高地址合并)**</p><p>4个字节存储3：</p><blockquote><p>16进制: 00 00 00 03H </p><p>2进制: 00000000 00000000 00000000 00000011</p></blockquote><table><thead><tr><th align="center">内存地址</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">1122h</td><td align="center"></td></tr><tr><td align="center">1123h</td><td align="center"></td></tr><tr><td align="center">1124h</td><td align="center"></td></tr><tr><td align="center">1125h</td><td align="center"></td></tr><tr><td align="center">1126h</td><td align="center"></td></tr><tr><td align="center">1127h</td><td align="center"></td></tr><tr><td align="center">1128h</td><td align="center">3     (00 00 00 11) 小端模式</td></tr><tr><td align="center">1129h</td><td align="center">|      (00 00 00 00)</td></tr><tr><td align="center">112Ah</td><td align="center">|      (00 00 00 00)</td></tr><tr><td align="center">112Bh</td><td align="center">|      (00 00 00 00)</td></tr></tbody></table><p>大部分时候是小端模式(高字节放高地址，低字节放低地址)，注意在读地址的时候不论大小端模式，都是从低地址开始读，读取设定的字节后，如何排列顺序再考虑大小端模式问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="number">0x007DF968</span><span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> cc cc cc cc <span class="comment">//8个字节， a占用了4个字节</span></span><br><span class="line"><span class="number">0x007DF970</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>一个变量的地址值，是他所有字节地址中的最小值</p></li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">mov dword ptr [ebp<span class="number">-8</span>], <span class="number">3</span></span><br><span class="line"><span class="comment">//[ebp-8] 即为变量a的地址</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;　&amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//a的地址为 010FFE4C</span></span><br><span class="line">汇编码为:</span><br><span class="line">movdword ptr [ebp<span class="number">-0</span>Ch], <span class="number">3</span> <span class="comment">//这里的值不能写死，因为每次调用函数时开辟栈空间</span></span><br><span class="line">     <span class="comment">//而且每一次分配的地址不同，里面的局部变量的地址会一直改变</span></span><br><span class="line">     <span class="comment">//每次调用都不同， -0ch 则涉及到函数栈的问题。</span></span><br><span class="line"><span class="comment">//ebp的值为 010FFE58</span></span><br><span class="line">a - ebp = c (<span class="number">16</span>进制)</span><br><span class="line">    </span><br><span class="line">如果是全局变量的地址值,该变量的地址值是写死的</span><br><span class="line">age = <span class="number">3</span>;</span><br><span class="line">movdword ptr ds:[<span class="number">00F</span>DA008h] <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">常量的话地址值也会变动</span><br></pre></td></tr></table></figure><ul><li>call 函数地址</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> test();   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">首先:</span><br><span class="line">call<span class="number">003713</span>A2 <span class="comment">//并非真正函数地址 按F11</span></span><br><span class="line"></span><br><span class="line">jmp<span class="number">00371780</span> <span class="comment">//跳转到真正的函数地址 进入这个地址</span></span><br><span class="line">    </span><br><span class="line"><span class="number">00371780</span> <span class="number">55</span>pushebp</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><ul><li>lea               eax, [1122h]     //load effect address 装载一个有效的地址值</li></ul><blockquote><p>等同于 mov             eax, 1122h</p></blockquote><ul><li>ret</li></ul><blockquote><p>函数返回</p></blockquote><ul><li>xor</li></ul><blockquote><p>异或 xor            op1, op2将op1和op2异或的结果赋值给op1</p></blockquote><ul><li>add，sub</li></ul><blockquote><p>加法，减法</p></blockquote><ul><li>inc，dec</li></ul><blockquote><p>自增，自减</p></blockquote><ul><li>jmp</li></ul><blockquote><p>jmp             内存地址      跳转到指定的内存地址开始执行(无条件跳转)</p><p>以 j 开头的汇编指令一般都是跳转，一般跟test、cmp等指令配合使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a == b)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="number">007118F</span>8  mov         dword ptr [ebp<span class="number">-8</span>],<span class="number">0</span>Ah  </span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="number">007118F</span>F  mov         dword ptr [ebp<span class="number">-14</span>h],<span class="number">14</span>h  </span><br><span class="line"><span class="keyword">if</span> (a == b) &#123;</span><br><span class="line"><span class="number">00711906</span>  mov         eax,dword ptr [ebp<span class="number">-8</span>]  </span><br><span class="line"><span class="number">00711909</span>  cmp         eax,dword ptr [ebp<span class="number">-14</span>h]  </span><br><span class="line"><span class="number">0071190</span>C  jne         <span class="number">0071191</span>D  </span><br><span class="line"><span class="comment">// jump not equal</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="number">0071190</span>E  push        <span class="number">717B</span>30h  </span><br><span class="line"><span class="number">00711913</span>  call        <span class="number">00711046</span>  </span><br><span class="line"><span class="number">00711918</span>  add         esp,<span class="number">4</span>  </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0071191B</span>  jmp         <span class="number">0071192</span>A  </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="number">0071191</span>D  push        <span class="number">717B</span>34h  <span class="comment">// jne 跳转的地址</span></span><br><span class="line"><span class="number">00711922</span>  call        <span class="number">00711046</span>  </span><br><span class="line"><span class="number">00711927</span>  add         esp,<span class="number">4</span>  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0071192</span>A  <span class="keyword">xor</span>         eax,eax <span class="comment">// jmp 跳转的地址</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>汇编权威参考： Intel 白皮书</strong></p><h3 id="4、引用"><a href="#4、引用" class="headerlink" title="4、引用"></a>4、引用</h3><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> age = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;age;</span><br><span class="line">*p = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">007</span>D17F2  mov         dword ptr [ebp<span class="number">-0</span>C h],<span class="number">3</span>  </span><br><span class="line"><span class="number">007</span>D17F9  lea         eax,[ebp<span class="number">-0</span>Ch]  <span class="comment">// eax 存放age的地址值</span></span><br><span class="line"><span class="number">007</span>D17FC  mov         dword ptr [ebp<span class="number">-18</span>h],eax  </span><br><span class="line"><span class="comment">//将age的地址值存放到指针变量p所在的存储空间</span></span><br><span class="line"><span class="number">007</span>D17FF  mov         eax,dword ptr [ebp<span class="number">-18</span>h]  </span><br><span class="line"><span class="comment">//将age的地址值存放到 eax</span></span><br><span class="line"><span class="number">007</span>D1802  mov         dword ptr [eax],<span class="number">5</span>  </span><br><span class="line"><span class="comment">//将5放到age的地址值</span></span><br><span class="line"><span class="number">007</span>D1808  mov         esi,esp  </span><br><span class="line">    </span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以如果代码牵扯到指针，那么一定会牵扯到汇编的 <code>lea</code> 指令</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lea eax,[ebp<span class="number">-0</span>Ch] <span class="comment">// [ebp-0Ch]数据地址值</span></span><br><span class="line">mov dword ptr [ebp<span class="number">-18</span>h],eax <span class="comment">//[ebp-18h]指针变量自己的地址值</span></span><br></pre></td></tr></table></figure><p>如果是引用的话：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">3</span></span><br><span class="line"><span class="keyword">int</span> &amp;ref = age;</span><br><span class="line">ref = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">00B</span>817F2  mov         dword ptr [ebp<span class="number">-0</span>Ch],<span class="number">3</span>  </span><br><span class="line"><span class="number">00B</span>817F9  lea         eax,[ebp<span class="number">-0</span>Ch]  </span><br><span class="line"><span class="number">00B</span>817FC  mov         dword ptr [ebp<span class="number">-18</span>h],eax  </span><br><span class="line"><span class="number">00B</span>817FF  mov         eax,dword ptr [ebp<span class="number">-18</span>h]  </span><br><span class="line"><span class="number">00B</span>81802  mov         dword ptr [eax],<span class="number">5</span></span><br><span class="line"><span class="comment">// 和指针的汇编码完全一样</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指针引用</span></span><br><span class="line">*<span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;age;</span><br><span class="line"><span class="keyword">int</span> *&amp;ref = p;</span><br><span class="line">*ref = <span class="number">30</span>; <span class="comment">// ref == f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> height = <span class="number">30</span>;</span><br><span class="line">ref = &amp;height; <span class="comment">// p = 30;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组引用</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (&amp;ref)[<span class="number">3</span>] = <span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *arr[<span class="number">3</span>]; <span class="comment">//指针数组，数组内部能放3个int*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*arr)[<span class="number">3</span>]; <span class="comment">//数组指针，用于指向数组的指针  ----&gt;  推出数组指针的一种写法 int (&amp;arr)[3] = array;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h5><p>const必须写在&amp;符号的左边才是常饮用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref = age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp; <span class="keyword">const</span> ref = age;</span><br><span class="line">ref = <span class="number">30</span>;</span><br><span class="line"><span class="comment">//ref 不能修改指向，但是可以通过ref间接修改所指向的变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对比指针</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p1 = &amp;age; <span class="comment">// p1 = &amp;height</span></span><br><span class="line">*p1 = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p2可以修改指向，不可以利用p2间接修改所指向的变量</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p2 = &amp;age;</span><br></pre></td></tr></table></figure><h5 id="const-引用的特点"><a href="#const-引用的特点" class="headerlink" title="const 引用的特点"></a>const 引用的特点</h5><ul><li>const引用可以指向临时数据(常量、表达式、函数返回值等等)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref = <span class="number">30</span>; <span class="comment">//常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref = a + b; <span class="comment">// 表达式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;ref = func(); <span class="comment">// 函数返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>作为函数参数时(同时适用于const指针)</li></ul><blockquote><p>可以接受const和非const实参(非const引用，只能接受非const实参)</p><p>可以跟非const引用构成重载</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;v1, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> &amp;v1, <span class="keyword">int</span> &amp;v2)</span></span>&#123; <span class="comment">// 构成重载</span></span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 非const实参</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//const实参</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> d = <span class="number">20</span></span><br><span class="line">    sum(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    sum(c, d);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当常引用指向了不同的数据时，会产生<code>临时变量</code>，即引用指向的并不是初始化时的那个变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> &amp;rAge = age;</span><br><span class="line">age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; age; <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; rAge; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="number">00</span>CB17F2  mov         dword ptr [ebp<span class="number">-0</span>Ch],<span class="number">0</span>Ah  <span class="comment">// </span></span><br><span class="line"><span class="number">00</span>CB17F9  mov         eax,dword ptr [ebp<span class="number">-0</span>Ch]  <span class="comment">// 10 放到 eax</span></span><br><span class="line"><span class="number">00</span>CB17FC  mov         dword ptr [ebp<span class="number">-24</span>h],eax  <span class="comment">// 10 放到另外一个存储空间</span></span><br><span class="line">相当于 <span class="keyword">const</span> <span class="keyword">long</span> &amp;rAge = temp;</span><br><span class="line"><span class="number">00</span>CB17FF  lea         ecx,[ebp<span class="number">-24</span>h]  </span><br><span class="line"><span class="number">00</span>CB1802  mov         dword ptr [ebp<span class="number">-18</span>h],ecx  </span><br><span class="line"><span class="number">00</span>CB1805  mov         dword ptr [ebp<span class="number">-0</span>Ch],<span class="number">1</span>Eh  </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (&amp;ref)[<span class="number">3</span>]arr = arr;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> &amp;ref = arr;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、基础内容&quot;&gt;&lt;a href=&quot;#一、基础内容&quot; class=&quot;headerlink&quot; title=&quot;一、基础内容&quot;&gt;&lt;/a&gt;一、基础内容&lt;/h1&gt;&lt;h3 id=&quot;1、杂项&quot;&gt;&lt;a href=&quot;#1、杂项&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="C/C++" scheme="http://example.com/categories/C-C/"/>
    
    
    <category term="C/C++" scheme="http://example.com/tags/C-C/"/>
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="汇编" scheme="http://example.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>C/C++ 内存布局</title>
    <link href="http://example.com/2020/09/22/C/C++%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
    <id>http://example.com/2020/09/22/C/C++%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</id>
    <published>2020-09-22T13:21:22.329Z</published>
    <updated>2020-10-05T03:21:10.586Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="C-C-内存布局"><a href="#C-C-内存布局" class="headerlink" title="C/C++ 内存布局"></a>C/C++ 内存布局</h2><h4 id="一、可执行映像"><a href="#一、可执行映像" class="headerlink" title="一、可执行映像"></a>一、可执行映像</h4><p>&emsp;&emsp;当生成C/C++程序的时候，链接器生成可执行文件。在UNIX和大多数游戏主机上面使用一种 <strong><em>可执行与可链接格式(executable and linkable format, ELF)</em></strong> 。在这些平台上的可执行文件使用后缀 <strong><em>.elf</em></strong> 。在Windows中的可执行文件同意类似与ELF，使用 <strong><em>.exe</em></strong> 作为扩展名。</p><p>映像文件一般最少由一下几个部分构成：</p><ul><li><p>代码段(text/code segement)</p><blockquote><p>程序中定义的函数的全部机械码</p></blockquote></li><li><p>数据段(data segment)</p><blockquote><p>已经初始化的全部静态变量<br>将由连接器为其分配内存，并且填如适当的初始值</p></blockquote></li><li><p>BBS 段(BBS segement)</p><blockquote><p>BBS是一种老旧的叫法，意为 <strong><em>“由符号开始的块(block started by symbol)”</em></strong>。包含程序定义中所有的未初始化的全局变量和静态变量，在C/C++中未初始化的全局变量和静态变量全为零。</p></blockquote></li><li><p>只读数据段(read only data segement)</p><blockquote><p> 又称为 <strong><em>rodata</em></strong> 段,包含程序中定义的只读(常量)全局变量。<br> 比如：浮点常量，用const关键字声名的全局对象实例……</p><blockquote><p>tips: 编译器通常会把整数常量视为<strong>明示常量</strong>(manifast constant)，并且直接把明示常量插入机器码中，直接占用代码段的存储空间而不存储于只读数据段。</p></blockquote></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;C-C-内存布局&quot;&gt;&lt;a href=&quot;#C-C-内存布局&quot; class=&quot;headerlink&quot; title=&quot;C/C++ 内存布局&quot;&gt;&lt;/a&gt;C/C++ 内存布局&lt;/h2&gt;&lt;h4 id=&quot;一、可执行映像&quot;&gt;&lt;a href=&quot;#一、可执行映像&quot; clas</summary>
      
    
    
    
    <category term="C/C++" scheme="http://example.com/categories/C-C/"/>
    
    
    <category term="Memory Management" scheme="http://example.com/tags/Memory-Management/"/>
    
    <category term="GameDev" scheme="http://example.com/tags/GameDev/"/>
    
  </entry>
  
</feed>
