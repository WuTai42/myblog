<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>STL 源码学习 序列式容器 Sequence Containers (1) | WuTai's Blog</title><meta name="keywords" content="学习笔记"><meta name="author" content="WuTai"><meta name="copyright" content="WuTai"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="序列式容器 Sequence Containers (1) 一、vectorvector 维护者一个连续的动态空间。使用迭代器 start 表示空间的头，finish 表示空间的尾，end_of_storage 表示目前可用的空间的尾。 为了降低 vector 空间配置时的速度成本，vector 的实际配置的大小会比客户端要求的更大一些，以备可能的扩充。 调用 vector 的 push_back">
<meta property="og:type" content="article">
<meta property="og:title" content="STL 源码学习 序列式容器 Sequence Containers (1)">
<meta property="og:url" content="http://example.com/2021/06/08/STL/index.html">
<meta property="og:site_name" content="WuTai&#39;s Blog">
<meta property="og:description" content="序列式容器 Sequence Containers (1) 一、vectorvector 维护者一个连续的动态空间。使用迭代器 start 表示空间的头，finish 表示空间的尾，end_of_storage 表示目前可用的空间的尾。 为了降低 vector 空间配置时的速度成本，vector 的实际配置的大小会比客户端要求的更大一些，以备可能的扩充。 调用 vector 的 push_back">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://nargdg.sn.files.1drv.com/y4phk6WBcrJsxkBiGeqOm2CY8TqFueGBG1T_TZ3aDjQ5N609AJ20ykgesGg72o6uGjGpXa_MCs56NVGzJlSDdlR30u0Hc-sBOkREEcCqtGeE1FdUwdGsmP6dQdT4bEOYCgaNEuM8xJveIkylZ5N7HK5fibuo6ruAu7P6wZZDY1ZEqB5V3WVIAubzqpAhbAbGlQzvmQA7JiX5VexX2fM-wCrp9F8AdLdVRSuYfhqzp1HrvQ/hui-6.png?psid=1">
<meta property="article:published_time" content="2021-06-08T13:43:00.994Z">
<meta property="article:modified_time" content="2021-06-08T14:33:45.868Z">
<meta property="article:author" content="WuTai">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nargdg.sn.files.1drv.com/y4phk6WBcrJsxkBiGeqOm2CY8TqFueGBG1T_TZ3aDjQ5N609AJ20ykgesGg72o6uGjGpXa_MCs56NVGzJlSDdlR30u0Hc-sBOkREEcCqtGeE1FdUwdGsmP6dQdT4bEOYCgaNEuM8xJveIkylZ5N7HK5fibuo6ruAu7P6wZZDY1ZEqB5V3WVIAubzqpAhbAbGlQzvmQA7JiX5VexX2fM-wCrp9F8AdLdVRSuYfhqzp1HrvQ/hui-6.png?psid=1"><link rel="shortcut icon" href="/myblog/img/favicon.png"><link rel="canonical" href="http://example.com/2021/06/08/STL/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/myblog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/myblog/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-06-08 22:33:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {
  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }

  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }
})()</script><meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/myblog/atom.xml" title="WuTai's Blog" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/myblog/img/richang-1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/myblog/archives/"><div class="headline">Articles</div><div class="length_num">12</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/myblog/tags/"><div class="headline">Tags</div><div class="length_num">9</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/myblog/categories/"><div class="headline">Categories</div><div class="length_num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/myblog/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/myblog/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/myblog/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/myblog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/myblog/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/myblog/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/myblog/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/myblog/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8-Sequence-Containers-1"><span class="toc-text">序列式容器 Sequence Containers (1)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81vector"><span class="toc-text">一、vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81list"><span class="toc-text">二、list</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#list-%E8%8A%82%E7%82%B9"><span class="toc-text">list 节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">list 迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list-%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-construct-push-back-insert"><span class="toc-text">list 的构造与内存管理 (construct, push_back, insert)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list-%E7%9A%84%E5%85%B6%E4%BB%96%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="toc-text">list 的其他元素操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#merge"><span class="toc-text">merge()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reverse"><span class="toc-text">reverse()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sort"><span class="toc-text">sort()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81deque"><span class="toc-text">三、deque</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#deque-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">deque 的数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque-%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">deque 的构造与内存管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#push-back"><span class="toc-text">push_back()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#push-back-aux"><span class="toc-text">push_back_aux()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#push-front"><span class="toc-text">push_front()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#push-front-aux"><span class="toc-text">push_front_aux()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reserver-map-%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-text">reserver map 相关操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque-%E7%9A%84%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="toc-text">deque 的元素操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clear"><span class="toc-text">clear()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#erase"><span class="toc-text">erase()</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://nargdg.sn.files.1drv.com/y4phk6WBcrJsxkBiGeqOm2CY8TqFueGBG1T_TZ3aDjQ5N609AJ20ykgesGg72o6uGjGpXa_MCs56NVGzJlSDdlR30u0Hc-sBOkREEcCqtGeE1FdUwdGsmP6dQdT4bEOYCgaNEuM8xJveIkylZ5N7HK5fibuo6ruAu7P6wZZDY1ZEqB5V3WVIAubzqpAhbAbGlQzvmQA7JiX5VexX2fM-wCrp9F8AdLdVRSuYfhqzp1HrvQ/hui-6.png?psid=1)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/myblog/">WuTai's Blog</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/myblog/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/myblog/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/myblog/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/myblog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/myblog/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/myblog/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/myblog/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/myblog/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">STL 源码学习 序列式容器 Sequence Containers (1)</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-06-08T13:43:00.994Z" title="Created 2021-06-08 21:43:00">2021-06-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-06-08T14:33:45.868Z" title="Updated 2021-06-08 22:33:45">2021-06-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/myblog/categories/C/">C++</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/myblog/categories/C/STL/">STL</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="序列式容器-Sequence-Containers-1"><a href="#序列式容器-Sequence-Containers-1" class="headerlink" title="序列式容器 Sequence Containers (1)"></a>序列式容器 Sequence Containers (1)</h2><hr>
<h3 id="一、vector"><a href="#一、vector" class="headerlink" title="一、vector"></a>一、vector</h3><p>vector 维护者一个连续的动态空间。使用迭代器 start 表示空间的头，finish 表示空间的尾，end_of_storage 表示目前可用的空间的尾。</p>
<p>为了降低 vector 空间配置时的速度成本，vector 的实际配置的大小会比客户端要求的更大一些，以备可能的扩充。</p>
<p>调用 vector 的 push_back() 将新元素插入 vector 的尾端的时候，首先检查是否还有备用的空间。如果有就直接构造如果不足就扩充空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">		construct(finish, x);</span><br><span class="line">		++finish;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		insert_aux(end(), x); <span class="comment">// vector 的 member function</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">		construct(finish, x);</span><br><span class="line">		++finish;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		insert_aux(end(), x); <span class="comment">// vector 的 member function</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">vector</span>&lt;T, Alloc&gt;::insert_aux(iterator position, <span class="keyword">const</span> T&amp; x) &#123;</span><br><span class="line">	<span class="comment">// 如果还有备用空间</span></span><br><span class="line">	<span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">		<span class="comment">// 在备用起始空间构造一个元素，并且以 vector 的最后一个元素为初值</span></span><br><span class="line">		construct(finish, *(finish - <span class="number">1</span>));</span><br><span class="line">		++finish;</span><br><span class="line">		T x_copy = x;</span><br><span class="line">		copy_backward(position, finish - <span class="number">2</span>, finish - <span class="number">1</span>);</span><br><span class="line">		*position = x_copy;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// 无备用空间</span></span><br><span class="line">		<span class="keyword">const</span> size_type old_size = size();</span><br><span class="line">		<span class="keyword">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="number">1</span></span><br><span class="line">		<span class="comment">// 如果原大小为 0 则配置一个元素大小</span></span><br><span class="line">		<span class="comment">// 原大小不为 0 则配置原大小的两倍</span></span><br><span class="line">		<span class="comment">// 前半段放置原数据，后半段留以备用</span></span><br><span class="line"></span><br><span class="line">		iterator new_start = data_allocator::allocate(len); <span class="comment">// 实际配置</span></span><br><span class="line">		iterator new_finish = new_start;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 将原vector的内容拷贝到新vector中去</span></span><br><span class="line">			new_finish = uninitialized_copy(start, position, new_start);</span><br><span class="line">			<span class="comment">// 为新元素设定初值</span></span><br><span class="line">			construct(new_finish, x);</span><br><span class="line">			<span class="comment">// 调整水位</span></span><br><span class="line">			++new_finish;</span><br><span class="line">			<span class="comment">// 将安插点原来的内容也拷贝过来 (因为本函数有可能被 insert(p, x) 调用)</span></span><br><span class="line">			new_finish = uninitialized_copy(position, finish, new_finish);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (...) &#123;</span><br><span class="line">			<span class="comment">// commit or roolback</span></span><br><span class="line">			destroy(new_start, new_finish);</span><br><span class="line">			data_allocator::deallocate(new_start, len);</span><br><span class="line">			<span class="keyword">throw</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 析构并释放原 vector</span></span><br><span class="line">		destroy(begin(), end());</span><br><span class="line">		deallocate();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 调整迭代器指向新的 vector</span></span><br><span class="line">		start = new_start;</span><br><span class="line">		finish = new_finish;</span><br><span class="line">		end_of_storage = new_start + len;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vector 的其他元素操作：</p>
<p><code> pop_back()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	--finish;</span><br><span class="line">    destroy(finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code> erase()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除 [first, last) 中的所有元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span> </span>&#123;</span><br><span class="line">	iterator i = copy(last, finish,</span><br><span class="line">					first);</span><br><span class="line">	destroy(i, finish);</span><br><span class="line">	finish = finish - (last - first);</span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// erase 是清除元素并向前覆盖，并返回最后一个未被覆盖的元素的位置</span></span><br><span class="line"><span class="comment">// 这个性质的原因是应为其内部使用 copy() 算法来清除元素</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (position + <span class="number">1</span> != end())</span><br><span class="line">		copy(position + <span class="number">1</span>, finish,</span><br><span class="line">		     position);</span><br><span class="line">	--finish;</span><br><span class="line">	destroy(finish); <span class="comment">// 这里要destroy，因为erase()是真的要移除 vector 的空间</span></span><br><span class="line">	<span class="keyword">return</span> position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>insert()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector::insert() 的实现内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 position 开始，插入 n 个元素，元素初值为 x</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">vector</span>&lt;T, Alloc&gt;::insert(iterator position, size_type n, <span class="keyword">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 只有 n 不等于 0 的时候才有以下操作</span></span><br><span class="line">		<span class="keyword">if</span> (size_type(end_of_storage - finish) &gt;= n) &#123; <span class="comment">// 备用空间足够</span></span><br><span class="line">			T x_copy = x;</span><br><span class="line">			<span class="comment">// 计算插入点之后现有元素的个数</span></span><br><span class="line">			<span class="keyword">const</span> size_type elems_after = finish - position;</span><br><span class="line">			iterator old_finish = finish;</span><br><span class="line">			<span class="keyword">if</span> (elems_after &gt; n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 插入点之后的元素个数大于新增元素</span></span><br><span class="line">				uninitialized_copy(finish - n, finish,</span><br><span class="line">								   finish);</span><br><span class="line">				finish += n; <span class="comment">// 移动 vector 的尾标</span></span><br><span class="line">				copy_backward(position, old_finish - n,</span><br><span class="line">							  finish);</span><br><span class="line">				<span class="comment">// 从插入点开始插入新值</span></span><br><span class="line">				fill(position, position + n,</span><br><span class="line">					 x_copy);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">// 插入点之后现有元素个数小于等于新插入的个数</span></span><br><span class="line">				uninitialized_fill_n(finish - n, n - elems_after,</span><br><span class="line">									 x_copy);</span><br><span class="line">				finish += n - elems_after;</span><br><span class="line">				uninitialized_copy(position, old_finish, finish);</span><br><span class="line">				finish += elems_after;</span><br><span class="line">				fill(position, old_finish, x_copy);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 备用空间小于新增元素个数</span></span><br><span class="line">			<span class="comment">// 要配置额外的内存</span></span><br><span class="line">			<span class="comment">// 要决定新长度： 1.扩为 2 倍 2.直接旧长度 + 新元素个数</span></span><br><span class="line">			<span class="keyword">const</span> size_type old_size = size();</span><br><span class="line">			<span class="keyword">const</span> size_type len = old_size + max(old_size, n); <span class="comment">// 防止扩为 2 被还不够</span></span><br><span class="line">			<span class="comment">// 配置新的 vector 空间</span></span><br><span class="line">			iterator new_start = data_allocator::allocate(len);</span><br><span class="line">			iterator new_finish = new_start;</span><br><span class="line">			__STL_try &#123;</span><br><span class="line">				<span class="comment">// 先将旧插入点之前的元素复制到新空间去</span></span><br><span class="line">				new_finish = uninitialized_copy(start, position,</span><br><span class="line">												new_start);</span><br><span class="line">				<span class="comment">// 再将新增元素填入</span></span><br><span class="line">				new_finish = uninitialized_fill_n(new_finish, n,</span><br><span class="line">												  x);</span><br><span class="line">				<span class="comment">// 最后将插入点之后的元素复制到新空间。要小心这里的end是finish，不是 old_finish</span></span><br><span class="line">				new_finish = uninitialized_copy(position, finish, </span><br><span class="line">												new_finish);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">ifdef</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line">			<span class="keyword">catch</span>(...) &#123;</span><br><span class="line">				<span class="comment">// commit or rollback</span></span><br><span class="line">				destroy(new_start, new_finish);</span><br><span class="line">				data_allocator::deallocate(new_start, len); <span class="comment">//</span></span><br><span class="line">				<span class="keyword">throw</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_USE_EXCEPTION */</span></span></span><br><span class="line">			<span class="comment">// 清除并释放旧的 vector</span></span><br><span class="line">			destroy(start, finish);</span><br><span class="line">			deallocate();</span><br><span class="line">			<span class="comment">// 调整标记</span></span><br><span class="line">			start = new_start;</span><br><span class="line">			finish = new_finish;</span><br><span class="line">			end_of_storage = new_finish + len;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二、list"><a href="#二、list" class="headerlink" title="二、list"></a>二、list</h3><p>相比较于 vector 的连续线性空间，list 就显得复杂许多。好处是每次插入或删除一个元素就配置或释放一个元素空间。对于任何位置的元素的插入和删除都是常数时间。</p>
<h4 id="list-节点"><a href="#list-节点" class="headerlink" title="list 节点"></a>list 节点</h4><p>list 的本身和 list 的节点是不同的结构，需要分开设计，下面是 STL 的 list 的 node 结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_node</span> &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">	void_pointer prev;</span><br><span class="line">	void_pointer next;   <span class="comment">// 型别为 void*, 其实可以设计为 __list_node&lt;T&gt;*</span></span><br><span class="line">	T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显的是一个双向链表</p>
<h4 id="list-迭代器"><a href="#list-迭代器" class="headerlink" title="list 迭代器"></a>list 迭代器</h4><p>list 的迭代器需要更复杂的功能的支持，不能像 vector 那样使用简单的指针。并且迭代器必须具备前移和后移的操作，所以要提供一个 <code> Bidirectional Iterator</code></p>
<p>list 有一个非常重要的性质： <strong>insert 和 splice 操作都不会造成原有的迭代器失效</strong></p>
<p>下面是 list 迭代器的设计</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list 的迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Ref, <span class="keyword">typename</span> Ptr&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt; iterator; <span class="comment">// 偏特化版本</span></span><br><span class="line">	<span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self;   <span class="comment">// 标识自己</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T 						   value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr 					   pointer;</span><br><span class="line">	<span class="keyword">typedef</span> Ref 					   reference;</span><br><span class="line">	<span class="keyword">typedef</span> __list_node&lt;T&gt;*  		   linked_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span>					   size_type;</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="keyword">ptrdiff_t</span>				   difference_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 内部的普通指针，指向 list 的节点</span></span><br><span class="line">	linked_type node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// constructer</span></span><br><span class="line">	__list_iterator(linked_type x) : node(x) &#123;&#125;</span><br><span class="line">	__list_iterator() &#123;&#125;</span><br><span class="line">	__list_iterator(<span class="keyword">const</span> iterator&amp; x) : node(x.node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node == x.node; &#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node != x.node; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 取值</span></span><br><span class="line">	reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 迭代器的成员存取</span></span><br><span class="line">	pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 迭代器累加 1，前进一个节点</span></span><br><span class="line">	self&amp; <span class="keyword">operator</span>++() &#123; <span class="comment">// prev</span></span><br><span class="line">		node = (linked_type)((*node).next);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; <span class="comment">// post</span></span><br><span class="line">		self tmp = *<span class="keyword">this</span>;</span><br><span class="line">		++*<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 迭代器累减 1，后退一个节点</span></span><br><span class="line">	self&amp; <span class="keyword">operator</span>--() &#123; <span class="comment">// prev</span></span><br><span class="line">		node = (linked_type)((*node).prev);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123; <span class="comment">// post</span></span><br><span class="line">		linked_type tmp = *<span class="keyword">this</span>;</span><br><span class="line">		--*<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code> SGI list</code> 不仅仅是一个双向链表，而且还是一个环状的双向链表。只需要一个指针便能完成整个节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list 数据结构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = alloc&gt;</span><br><span class="line">class <span class="built_in">list</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __list_node&lt;T&gt;* linked_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	linked_type node; <span class="comment">// 只需要一个指针便能表示双向循环链表</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要刻意的用 node 指针指向刻意置于尾端的一个空白节点，便可以满足 STL 对区间 <strong>前闭后开</strong> 的要求，成为 last 迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (linked_type)((*node).next); &#125;</span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> node; &#125; <span class="comment">// 指向一个 null 节点作为开区间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> node-&gt;next == node; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">	size_type result = <span class="number">0</span>;</span><br><span class="line">	distance(begin, end, result); <span class="comment">// 全局函数</span></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取节点的内容</span></span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *begin(); &#125;</span><br><span class="line"><span class="function">reference <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(--end()); &#125; <span class="comment">// 因为是循环链表 --end 就指向“最后一个节点”</span></span><br></pre></td></tr></table></figure>

<h4 id="list-的构造与内存管理-construct-push-back-insert"><a href="#list-的构造与内存管理-construct-push-back-insert" class="headerlink" title="list 的构造与内存管理 (construct, push_back, insert)"></a>list 的构造与内存管理 (construct, push_back, insert)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = alloc&gt;</span><br><span class="line">class <span class="built_in">list</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class="line">	<span class="comment">// 使用专属的空间配置器，每次配置一个节点</span></span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;list_node, alloc&gt; list_node_allocator;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面分别是list的配置、释放、构造、销毁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// 配置一个节点</span></span><br><span class="line">	<span class="function">linked_type <span class="title">get_node</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> list_node_allocator::allocate(); &#125;</span><br><span class="line">	<span class="comment">// 释放一个节点</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">put_node</span><span class="params">(linked_type p)</span> </span>&#123; list_node_allocator::deallocate(p); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置并构造一个节点，带有元素值</span></span><br><span class="line">	<span class="function">linked_type <span class="title">create_node</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">		linked_type p = get_node();</span><br><span class="line">		construct(&amp;p-&gt;data, x);</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 销毁，释放并悉析构一个节点</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">destroy_node</span><span class="params">(linked_type p)</span> </span>&#123;</span><br><span class="line">		destroy(&amp;p-&gt;data);</span><br><span class="line">		put_node(p);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>list 提供许多的 construct， 其中一个是 default construct, 不用指定任何参数做出来一个空的 list</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// default construct</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">list</span>() &#123; empty_initialized(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">empty_initialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		node = get_node(); <span class="comment">// 配置一个节点用 node 指向它</span></span><br><span class="line">		node-&gt;next = node;</span><br><span class="line">		node-&gt;prev = node; <span class="comment">// 让 node 的头尾指向它，并且不设置元素值</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>list 在调用 push_back 的时候内部调用 insert()。（所谓插入指的是插在…的前面）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123; insert(end(), x); &#125;</span><br><span class="line"><span class="comment">// insert 有许多种的重载，这一种是符合上面p	 ush_back操作的一种</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    linked_type tmp = get_node(x);</span><br><span class="line">    <span class="comment">// 重新配置指针，插入 tmp</span></span><br><span class="line">    tmp-&gt;next = position.node;</span><br><span class="line">    tmp-&gt;prev = position.node-&gt;prev;</span><br><span class="line">    <span class="comment">// 这里注意以下类型转换</span></span><br><span class="line">    (linked_type(position.node-&gt;prev))-&gt;next = tmp;</span><br><span class="line">    position.node-&gt;prev = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="list-的其他元素操作"><a href="#list-的其他元素操作" class="headerlink" title="list 的其他元素操作"></a>list 的其他元素操作</h4><p>插入节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123; insert(begin(), x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123; insert(end(), x); &#125;</span><br></pre></td></tr></table></figure>

<p>移除迭代器所指的节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123;</span><br><span class="line">    linked_type next_node = linked_type(position.node-&gt;next);</span><br><span class="line">    linked_type prev_node = linked_type(position.node-&gt;prev);</span><br><span class="line">    prev_node-&gt;next = next_node;</span><br><span class="line">    next_node-&gt;prev = prev_node;</span><br><span class="line">    destroy_node(position.node);</span><br><span class="line">    <span class="keyword">return</span> iterator(next_node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除头节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> erase(begin()); &#125;</span><br><span class="line"><span class="comment">// 移除尾节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    iterator tmp = end();</span><br><span class="line">    erase(--tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清除所有节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除整个链表</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">list</span>&lt;T, Alloc&gt;::clear() &#123;</span><br><span class="line">    linked_type cur = (linked_type) node-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (cur != node) &#123; <span class="comment">// 遍历每一个节点</span></span><br><span class="line">        linked_type tmp = cur;</span><br><span class="line">      	cur = (linked_type) node-&gt;next;</span><br><span class="line">        destroy_node(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;next = next;</span><br><span class="line">    node-&gt;prev = prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移除所有值为 value 的节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">list</span>&lt;T, Alloc&gt;::remove(<span class="keyword">const</span> T&amp; value) &#123;</span><br><span class="line">    iterator first = begin();</span><br><span class="line">    iterator last = end();</span><br><span class="line">    <span class="comment">// 遍历所有节点</span></span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        iterator next = first;</span><br><span class="line">        ++next;</span><br><span class="line">        <span class="keyword">if</span> (*first == value) erase(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移除数值相同并且连续的元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">list</span>&lt;T, Alloc&gt;::unique() &#123;</span><br><span class="line">    iterator first = begin();</span><br><span class="line">    iterator last = end();</span><br><span class="line">    <span class="keyword">if</span> (first == last) <span class="keyword">return</span>; <span class="comment">// 空链，直接退出</span></span><br><span class="line">    iterator next = first; <span class="comment">// 工具人 next</span></span><br><span class="line">    <span class="keyword">while</span> (++next != last) &#123; <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">if</span> (*first == *next) </span><br><span class="line">            erase(next);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            first = next;</span><br><span class="line">        <span class="comment">// 修正 erase 之后的区间范围</span></span><br><span class="line">        next = first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>list 内部提供一个所谓的迁移操作<strong>transfer: 将某连续范围内的元素迁移到特定位置之前</strong>。该操作就是移动指针，没有什么特别的操作，但是该操作是后续复杂操作splice, sort, merge 等操作的基础</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(iterator first, iterator last, <span class="comment">// [ first, last ) ---&gt; position</span></span></span></span><br><span class="line"><span class="function"><span class="params">                   iterator position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first != last)</span><br><span class="line">            (*(linked_type((*last.node).prev))).next = position.node;</span><br><span class="line">        	(*(linked_type((*first.node).prev))).next = last.node;</span><br><span class="line">        	(*(linked_type((*position.node).prev)).next = first.node;</span><br><span class="line">            linked_type tmp = linked_type((*position.node).prev);</span><br><span class="line">            (*position.node).prev = (*last.node).prev;</span><br><span class="line">            (*last.node).prev = (*first.node).prev;</span><br><span class="line">            (*first.node).prev = tmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>transfer 的 [ first, last ) 区间可以在同一个 list 中</strong></p>
<p>上述的 <code> transfer</code> 并非公开接口，list 公开提供的是 <code>splice</code> : 将某段连续的 list 移动到另一段（或者同一个）list 的某一个定点。</p>
<p>为了提供各种接口弹性， <code> list&lt;T&gt;::splice</code> 有许多版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 将 x 接合于 position 所指的位置之前， x 必须不同于 *this</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator position, <span class="built_in">list</span>&amp; x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!x.empty())</span><br><span class="line">			transfer(position,</span><br><span class="line">					 x.begin(), x.end());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将 i 所指元素接合于 position 所指的位置之前，position 和 i 可以指向同一个 list</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator position, <span class="built_in">list</span>&amp;, iterator i)</span> </span>&#123;</span><br><span class="line">		iterator j = i;</span><br><span class="line">		++j;</span><br><span class="line">		<span class="keyword">if</span> (position == i || position == j) <span class="keyword">return</span>;</span><br><span class="line">		transfer(position, i, j);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将 [ first, last ) 内的所有元素接合于 position 所指位置前</span></span><br><span class="line">	<span class="comment">// 可以指向同一个 list, 但是 position 不能位于 [ first, last ) 之内</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator position,</span></span></span><br><span class="line"><span class="function"><span class="params">			 	<span class="built_in">list</span>&amp;,</span></span></span><br><span class="line"><span class="function"><span class="params">			 	iterator first, iterator last)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (first != last) &#123;</span><br><span class="line">			transfer(position, first, last);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>同时在有了 <code> transfer</code> 之后，便可以较为轻松的写出 <code> merge</code>, <code> reverse</code>, <code> sort</code> 等方法了。</p>
<h4 id="merge"><a href="#merge" class="headerlink" title="merge()"></a>merge()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">list</span>&lt;T, alloc&gt;::merge(<span class="built_in">list</span>&lt;T, Alloc&gt;&amp; x) &#123;</span><br><span class="line">    iterator first1 = begin();</span><br><span class="line">    iterator last1 = end();</span><br><span class="line">    iterator first2 = x.begin();</span><br><span class="line">    iterator last2 = end();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (*first1 != *last1 &amp;&amp; *first2 != *last2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*first2 &lt; *first2) &#123;</span><br><span class="line">            iterator next = first2;</span><br><span class="line">            transfer(first1,</span><br><span class="line">                     first2, ++next);</span><br><span class="line">            first2 = next;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ++first1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 x 太大太长了的话</span></span><br><span class="line">    <span class="keyword">if</span> (first2 != last2)</span><br><span class="line">        transfer(last1,</span><br><span class="line">                 first2, last2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">list</span>&lt;T, Alloc&gt;::reverse() &#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next == node || linked_type(node-&gt;next)-&gt;next) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    iterator first = begin();</span><br><span class="line">    ++first;</span><br><span class="line">    <span class="keyword">while</span> (first != end()) &#123;  <span class="comment">// 始终要铭记list的区间是左开右闭的</span></span><br><span class="line">        iterator old = first;</span><br><span class="line">        ++first;</span><br><span class="line">        transfer(begin(),</span><br><span class="line">                 old, first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p>list 不能使用 STL 的算法 sort()，必须使用自己的 sort() member function，因为 STL 的 sort() 只接受 RandomAccessIterator。该函数采用 quick sort</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">list</span>&lt;T, Alloc&gt;::sort() &#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next == node || linked_type(node-&gt;next)-&gt;next == node) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">list</span>&lt;T, Alloc&gt; carry;</span><br><span class="line">    <span class="built_in">list</span>&lt;T, Alloc&gt; counter[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> fill = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!empty()) &#123;</span><br><span class="line">        carry.splice(carry.begin(), *<span class="keyword">this</span>, begin());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; fill &amp;&amp; !counter[i].empty()) &#123;</span><br><span class="line">            counter[i].merge(carry);</span><br><span class="line">            carry.swap(counter[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        carry.swap(counter[i]);</span><br><span class="line">        <span class="keyword">if</span> (i == fill) ++fill;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fill; ++i)</span><br><span class="line">        counter[i].merge(counter[i - <span class="number">1</span>]);</span><br><span class="line">    swap(counter[fill - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 sort 并没有想象中的那么简单，搞了好久才弄明白，下面我详细的讲一下，也算巩固一下自己的知识。</p>
<p><strong><em>首先说明，我并没有确切的看出来快排思想是在哪里体现出来的（难道说是merge体现出来的？）</em></strong></p>
<p>首先是声明了一个辅助 list <code> carry</code></p>
<p>让后声明了 <strong>64</strong> 个辅助list区块<code> list&lt;T, Alloc&gt; counter[64]</code> ,(对是64个你没看错，因为我看错了。。。)</p>
<p>这个counter的作用是用来存放已经完成排序的元素的，为什么需要64个呢？</p>
<p>首先因为我们看到 STL 的 list 的 sort 的比较的核心是 merge 函数，前面提到了 merge必须是在两个 list 是已升序排序的情下才能完成 merge。我们怎么保证每次都是我们比对的元素是sorted呢？很简单，我们每次只对两个元素做merge。完成了第一次merge之后我们将其暂时存放在 counter[1]，第3个元素进入carry后，因为没有可比较的我们直接将其放在 counter[0]，然后读取下一个元素到 carry 中去，此时carry和 counter[0] 便能完成一次 merge 放入counter[0]，然后我们 swap carry 和 counter[0]，然后将counter的计数器++，此时carry 和 counter[1] 是已经完成排序的list，可以进行 merge 操作了。</p>
<p>为了让后续的操作能够持续的进行，我们将counter[0] 和 counter[1] 中的值放到 counter[2] 中去 。这样也就能解释为什么需要多个 counter list了，因为我们要用多个 list 来存放 sorted 的元素。counter[0] = 2 counter[1] = 4 … counter[i] = 2^i （counter的大小是完全够用的，除非数据量超过了 2^64，应该是不大可能的）</p>
<p>我们通过 <code>fill</code> 标记来控制 counter 的向下 merge，以便腾出上面的空间来不停的进行排序。同时 fill 的值也记录着有多少个counter已经被使用，在最后整合的时候是关键值。</p>
<p>也就说当循环进行到最后的时候，每个counter中的值都是完成了排序的。我们最后要完成最后的排序只需要将每一个counter merge 即可。</p>
<h3 id="三、deque"><a href="#三、deque" class="headerlink" title="三、deque"></a>三、deque</h3><p>deque 是双向开口的连续线性空间。分别可以在头尾进行插入删除操作。vector 是单向开口的连续线性空间。</p>
<p>deque 和 vector 最大的差异</p>
<blockquote>
<p>1、deque 允许常数时间对起头端进行元素的插入或者移除操作</p>
<p>2、deque 没有容量(capacity)的观念，它是动态的以分段的连续空间组合而成的，可以随时增加一段新的空间并连接起来。</p>
</blockquote>
<p>因此 deque 并不会提供所谓的空间保留(reverse)功能。</p>
<p>deque 也提供 Random Access Iterator 但是其复杂度不是 vector 能比的，这也影响了运算的各个层面。因此，除非必要，我们尽可能选择使用 vector 而非 deque。对deque排序的时候，为了提高效率我们一般将deque完整的复制到vector身上，将vector排序后再复制回deque。</p>
<p>deque 迭代器的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Ref, <span class="keyword">typename</span> Ptr, <span class="keyword">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">deque_iterator</span> &#123;</span> <span class="comment">// 未继承 std::iterator </span></span><br><span class="line">	<span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*, BufSiz&gt; const_iterator;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">buffer_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> __deque_buf_size(<span class="keyword">size_t</span>, <span class="keyword">sizeof</span>(T)); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为未继承 std::iterator 必须自己写5个必要的迭代器相对应的类型</span></span><br><span class="line">	<span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T 						   value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr						   pointer;</span><br><span class="line">	<span class="keyword">typedef</span> Ref 					   reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span> 	 	 			   size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>				   difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> T** <span class="keyword">typedef</span>				   map_pointer;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> __deque_iterator 		   self;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保持于容器的连接</span></span><br><span class="line">	T* cur;  <span class="comment">// 指向缓冲区的current元素</span></span><br><span class="line">	T* first; <span class="comment">// 指向缓冲区的头</span></span><br><span class="line">	T* second; <span class="comment">// 指向缓冲区的尾(含备用空间)</span></span><br><span class="line">	map_pointer node; <span class="comment">// 指向管控空间 </span></span><br><span class="line">	<span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>__deque_buf_size() 是一个全局函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">	<span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="keyword">size_t</span>(<span class="number">512</span> / sz) : <span class="keyword">size_t</span>(<span class="number">1</span>));</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>每个迭代器的结构大致如下： [ cur | first | last | node ]</p>
<p>下面是 deque 迭代器的几个关键行为。</p>
<p>其中最需要注意的是一旦遇到了缓冲区的边缘，要特别的小心，视前进和后退而定，可能需要调用 set_node() 跳到下一个缓冲区:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span> </span>&#123;</span><br><span class="line">	node = new_node;</span><br><span class="line">	first = *new_node;</span><br><span class="line">	last = first + difference_type(buffer_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的各种重载便是实现 deque 迭代器的关键</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *cur; &#125;</span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"></span><br><span class="line">difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="comment">// 两个iterator 之间的距离</span></span><br><span class="line">	<span class="keyword">return</span> difference_type(buffer_size()) * (node - x.node - <span class="number">1</span>) +</span><br><span class="line">			(cur - first) + (x.last - x.cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自增自减运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">	++cur; 				<span class="comment">// 切换到下一个元素</span></span><br><span class="line">	<span class="keyword">if</span> (cur == last) &#123;	<span class="comment">// 到达缓冲区尾部</span></span><br><span class="line">		set_node(n + <span class="number">1</span>);<span class="comment">// 切换到下一个节点（缓冲区）的第一个元素</span></span><br><span class="line">		cur = first;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; <span class="comment">// 后置的标准写法</span></span><br><span class="line">	self tmp = *<span class="keyword">this</span>;</span><br><span class="line">	++*<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">	<span class="keyword">if</span> (cur == first) &#123; <span class="comment">// 如果已经到达缓冲区的头端</span></span><br><span class="line">		set_node(node - <span class="number">1</span>);</span><br><span class="line">		cur = last;</span><br><span class="line">	&#125;</span><br><span class="line">	--cur;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">	self tmp = *<span class="keyword">this</span>;</span><br><span class="line">	--*<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面实现随机存取。迭代器可以直接跳跃 n 个距离</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向前跳 n </span></span><br><span class="line"><span class="comment">// 偏移量和实际的跳数是有偏差的 (注意左开右闭)</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>+=(difference_type n) &#123;</span><br><span class="line">	difference_type offset = n + (cur - first); <span class="comment">// 获取指针的偏移量</span></span><br><span class="line">	<span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; difference_type(buffer_size())) <span class="comment">// 目标位置在同一缓冲区内部</span></span><br><span class="line">		cur += n;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 不在同一缓冲区内</span></span><br><span class="line">		<span class="comment">// 先确定是正向还是反向</span></span><br><span class="line">		difference_type node_offset = </span><br><span class="line">			offset &gt; <span class="number">0</span> ? offset / difference_type(buffer_size()) <span class="comment">// n &gt; 0 可以直接算出前跳的数目</span></span><br><span class="line">				       : -difference_type((-offset - <span class="number">1</span>) / buffer_size()) - <span class="number">1</span>; </span><br><span class="line">				       <span class="comment">// 负数的除法算出来会少跳一格，要补一个 -1</span></span><br><span class="line">				       <span class="comment">// 将offset转为正的原因是 size_t 是无±号的类型</span></span><br><span class="line">				       <span class="comment">// 因为 cur 指的是当前元素的下一个位置，</span></span><br><span class="line">		<span class="comment">// 切换到正确的节点（缓冲区）</span></span><br><span class="line">		set_node(node + node_offset);</span><br><span class="line">		<span class="comment">// 切换到正确的元素</span></span><br><span class="line">		cur  = first + (offset - node_offset * difference_type(buffer_size()));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他相关操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向前跳 n </span></span><br><span class="line"><span class="comment">// 偏移量和实际的跳数是有偏差的 (注意左开右闭)</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>+=(difference_type n) &#123;</span><br><span class="line">	difference_type offset = n + (cur - first); <span class="comment">// 获取指针的偏移量</span></span><br><span class="line">	<span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; difference_type(buffer_size())) <span class="comment">// 目标位置在同一缓冲区内部</span></span><br><span class="line">		cur += n;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 不在同一缓冲区内</span></span><br><span class="line">		<span class="comment">// 先确定是正向还是反向</span></span><br><span class="line">		difference_type node_offset = </span><br><span class="line">			offset &gt; <span class="number">0</span> ? offset / difference_type(buffer_size()) <span class="comment">// n &gt; 0 可以直接算出前跳的数目</span></span><br><span class="line">				       : -difference_type((-offset - <span class="number">1</span>) / buffer_size()) - <span class="number">1</span>; </span><br><span class="line">				       <span class="comment">// 负数的除法算出来会少跳一格，要补一个 -1</span></span><br><span class="line">				       <span class="comment">// 将offset转为正的原因是 size_t 是无±号的类型</span></span><br><span class="line">				       <span class="comment">// 因为 cur 指的是当前元素的下一个位置，</span></span><br><span class="line">		<span class="comment">// 切换到正确的节点（缓冲区）</span></span><br><span class="line">		set_node(node + node_offset);</span><br><span class="line">		<span class="comment">// 切换到正确的元素</span></span><br><span class="line">		cur  = first + (offset - node_offset * difference_type(buffer_size()));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">self <span class="keyword">operator</span>+(difference_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">	self tmp = *<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> tmp += n; <span class="comment">// 调用 operator+= </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>-=(difference_type n) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span> += -n; <span class="comment">// 调用 operator +=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>-(difference_type n) &#123;</span><br><span class="line">	self tmp = *<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> tmp -= n; <span class="comment">// 调用 -= operator</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下实现随机存取。迭代器可以直接跳跃 n 个距离</span></span><br><span class="line">reference <span class="keyword">operator</span>[](difference_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + n); &#125;</span><br><span class="line"><span class="comment">// 调用 operator* 和 operator + </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur = x.cur; &#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == x); &#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (node == x.node) ? (cur &lt; x.cur) : (node &lt; x.node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="deque-的数据结构"><a href="#deque-的数据结构" class="headerlink" title="deque 的数据结构"></a>deque 的数据结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt;</span><br><span class="line">class <span class="built_in">deque</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// 元素指针的指针</span></span><br><span class="line">	<span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	iterator first;   <span class="comment">// 表现第一个节点</span></span><br><span class="line">	iterator finish;  <span class="comment">// 表现最后一个节点</span></span><br><span class="line"></span><br><span class="line">	map_pointer <span class="built_in">map</span>;  <span class="comment">// 指向map，map的每一个元素都是指针，指向缓冲区</span></span><br><span class="line"></span><br><span class="line">	size_type map_size; <span class="comment">// map 的指针的个数</span></span><br><span class="line">	<span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了上述的结构便能够轻易完成下面的机能</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line"></span><br><span class="line">	reference <span class="keyword">operator</span>[](size_type n) &#123;</span><br><span class="line">		<span class="keyword">return</span> start[difference_type(n)]; <span class="comment">// 调用 __deque_iterator&lt;&gt;::operator[]</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *start; &#125;</span><br><span class="line">	<span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		iterator tmp = finish;</span><br><span class="line">		--tmp;</span><br><span class="line">		<span class="keyword">return</span> *tmp;</span><br><span class="line">		<span class="comment">// 不用 return *(finish - 1); 因为 deque 没有定义 finish - 1 相关的操作？？</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (finish - start); &#125;</span><br><span class="line">	<span class="comment">// 调用 iterator::operator-</span></span><br><span class="line">	<span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(<span class="number">-1</span>); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish == start; &#125;</span><br></pre></td></tr></table></figure>



<h4 id="deque-的构造与内存管理"><a href="#deque-的构造与内存管理" class="headerlink" title="deque 的构造与内存管理"></a>deque 的构造与内存管理</h4><p>deque 自行定义了两个专属的空间配置器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// deque 的空间配置器</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// 每次配置一个元素大小</span></span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line">	<span class="comment">// 每次配置一个指针大小</span></span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;pointer, Alloc&gt; pointer_allocator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并且提供一个 constructor 如下</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="keyword">int</span> n, <span class="keyword">const</span> value_type&amp; value)</span><br><span class="line">	: start(), finish(), <span class="built_in">map</span>(<span class="number">0</span>), map_size(<span class="number">0</span>) &#123;	</span><br><span class="line">	fill_initialize(n, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的 <code> fill_initialize()</code> 负责安排好 deque 的结构并将元素的初值设定妥当</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fill_initialize 安排好结构与初值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::fill_initialize(size_type n,</span><br><span class="line">											   <span class="keyword">const</span> value_type&amp; value) &#123;</span><br><span class="line">	create_map_and_nodes(n); <span class="comment">// 安排 deque 的结构</span></span><br><span class="line">	map_pointer cur;</span><br><span class="line"></span><br><span class="line">	__STL_TRY &#123;</span><br><span class="line">		<span class="comment">// 为每个节点设置初值</span></span><br><span class="line">		<span class="keyword">for</span> (cur = start.node; cur &lt; finish.node; ++cur)</span><br><span class="line">			uninitialize_fill(finish.first, finish.cur, value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span>(...) &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code> create_map_and_nodes()</code> 负责产生并安排好 deque 的结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;T, Alloc, Bufsize&gt;::create_map_and_nodes(n) &#123;</span><br><span class="line">	<span class="comment">// 需要的节点数 = (元素个数/缓冲区能容纳的大小) - 1</span></span><br><span class="line">	<span class="comment">// 如果刚好整除会多陪一个</span></span><br><span class="line">	size_type num_nodes = num_elements/ buffer_size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一个 map 要管理多少个节点 8 or nodes + 2</span></span><br><span class="line">	map_size = max(initial_map_size(), num_nodes() + <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">map</span> = map_allocate::allocate(map_size); <span class="comment">// 配置 map</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面使 nstart 和 nfinish 指向 map 所拥有的全部节点的最中央的区段</span></span><br><span class="line">	<span class="comment">// 保持在中间可以使头尾的扩充能量一样大。每一个节点可以对应一个缓冲区</span></span><br><span class="line">	map_pointer nstart = <span class="built_in">map</span> + (map_size - num_nodes) / <span class="number">2</span>;</span><br><span class="line">	map_pointer nfinish = nstart + num_nodes - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	map_pointer cur;</span><br><span class="line">	__STL_TRY &#123;</span><br><span class="line">		<span class="comment">// 为 map 中的每一个节点配置缓冲区。所有的缓冲区加起来就是 deque 的可用空间</span></span><br><span class="line">		<span class="comment">// (最后一个缓冲区可能留有一些余裕)；</span></span><br><span class="line">		<span class="keyword">for</span> (cur = nstart; cur &lt;= nfinish; ++cur) &#123;</span><br><span class="line">			*cur = allocate_node();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">catch</span>(...) &#123;</span><br><span class="line">		<span class="comment">//  &quot;commit or rollback&quot;</span></span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为 deque 的两个迭代器 start end 设定正确的内容</span></span><br><span class="line">	start.set_node(nstart);</span><br><span class="line">	finish.set_node(nfinish);</span><br><span class="line">	start.cur = start.finish;</span><br><span class="line">	finish.cur = first.finish + num_elements % buffer_size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是 deque 的各个操作函数的内容</p>
<h4 id="push-back"><a href="#push-back" class="headerlink" title="push_back()"></a>push_back()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (finish.cur != finish.last - <span class="number">1</span>) &#123; <span class="comment">// 最后一个缓冲区尚有2个及以上的元素备用空间</span></span><br><span class="line">		construct(finish.cur, t); <span class="comment">// 直接在备用空间上构造元素</span></span><br><span class="line">		++finish.cur; <span class="comment">// 调整缓冲区状态</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;  <span class="comment">// 缓冲空间不足</span></span><br><span class="line">		push_back_aux(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="push-back-aux"><a href="#push-back-aux" class="headerlink" title="push_back_aux()"></a>push_back_aux()</h4><p>当缓冲区空间不足的时候，也就是说当 finish.cur = finish.last - 1; 的时候调用，也就是最后一个缓冲区只剩下最后一个备用元素空间的时候才会调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::push_back_aux(<span class="keyword">const</span> value_type&amp; t) &#123;</span><br><span class="line">	value_type t_copy t;</span><br><span class="line">	reserver_map_at_back(); <span class="comment">// 若符合某种条件则必须换一个 map</span></span><br><span class="line">	*(finish.node + <span class="number">1</span>) = allocate_node(); <span class="comment">// 配置一个新节点（缓冲区）</span></span><br><span class="line">	__STL_TRY &#123;</span><br><span class="line">		construct(finish.cur, t_copy);</span><br><span class="line">		finish.set_node(finish.node + <span class="number">1</span>); <span class="comment">// 改变finish指向新节点</span></span><br><span class="line">		finish.cur = finish.first;</span><br><span class="line">	&#125;</span><br><span class="line">	__STL_UNWIND(deallocate_node((*finish.node + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="push-front"><a href="#push-front" class="headerlink" title="push_front()"></a>push_front()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (start.cur != start.first) &#123;</span><br><span class="line">		construct(start.cur - <span class="number">1</span>, t); <span class="comment">// 直接构造</span></span><br><span class="line">		--cur;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">// 无备用空间</span></span><br><span class="line">		push_front_aux(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="push-front-aux"><a href="#push-front-aux" class="headerlink" title="push_front_aux()"></a>push_front_aux()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::push_front_aux(<span class="keyword">const</span> value_type&amp; t) &#123;</span><br><span class="line">	value_type t_copy = t;</span><br><span class="line">	reserver_map_at_front();</span><br><span class="line">	*(start.node - <span class="number">1</span>) = allocate_node();</span><br><span class="line">	__STL_TRY &#123;</span><br><span class="line">		start.set_node(start.node - <span class="number">1</span>); <span class="comment">// 改变start指向新节点</span></span><br><span class="line">		start.cur = start.last - <span class="number">1</span>;		<span class="comment">// 设定 start 的状态</span></span><br><span class="line">		construct(start.cur, t_copy);	<span class="comment">// 设定元素的值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span>(...) &#123;</span><br><span class="line">		<span class="comment">// commit or rollback</span></span><br><span class="line">		start.set_node(start.node + <span class="number">1</span>);</span><br><span class="line">		start.cur = start.finish;</span><br><span class="line">		deallocate_node(*(start - <span class="number">1</span>).node);</span><br><span class="line">		<span class="keyword">throw</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里我们以及充分展示了 deque 容器的空间运用策略。这时候便需要解决其中一个重要的问题了，<strong>什么时候map需要重新整治</strong>。</p>
<h4 id="reserver-map-相关操作"><a href="#reserver-map-相关操作" class="headerlink" title="reserver map 相关操作"></a>reserver map 相关操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整治 map</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserver_map_at_back</span><span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nodes_to_add + <span class="number">1</span> &gt; map_size - (finish.node - <span class="built_in">map</span>)) &#123; <span class="comment">// map 尾端的空间不足</span></span><br><span class="line">		<span class="comment">// 这时只有重新换一个 map，配置更大的，拷贝原来的，释放原来的</span></span><br><span class="line">		reallocate_map(nodes_to_add, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// front 的情况和上面差不多意思</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserver_map_at_front</span><span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nodes_to_add &gt; start.node - <span class="built_in">map</span>) &#123;</span><br><span class="line">		<span class="comment">// 前端 map 的空间不足</span></span><br><span class="line">		reallocate_map(nodes_to_add, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前后空间不足都使用的是同一个 reallocate_map() 函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若符合某种条件才会进行更换</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="keyword">typename</span> BufSize&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::reallocate_map(size_type nodes_to_add,</span><br><span class="line">											<span class="keyword">bool</span> add_at_front) &#123;</span><br><span class="line">	<span class="comment">// 旧节点总个数</span></span><br><span class="line">	size_type old_num_nodes = finish.node - start.node + <span class="number">1</span>; <span class="comment">// 指针的偏移值比实际node个数少1</span></span><br><span class="line">	<span class="comment">// 新节点总个数</span></span><br><span class="line">	size_type new_num_nodes = old_num_nodes + nodes_to_add;</span><br><span class="line"></span><br><span class="line">	map_pointer new_nstart;</span><br><span class="line">	<span class="keyword">if</span> (map_size &gt; <span class="number">2</span> * new_num_nodes) &#123; <span class="comment">// map 的空间还充足的时候，还不需要添加新的节点</span></span><br><span class="line">		new_nstart = <span class="built_in">map</span> + (map_size - new_num_nodes) / <span class="number">2</span></span><br><span class="line">						 + (add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (new_nstart &lt; start.node) <span class="comment">// 后面的空间占完了，但是还能向前移动</span></span><br><span class="line">			copy(start.node, finish.node + <span class="number">1</span>, new_nstart);</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">// 前面的空间占完了，向后面移动</span></span><br><span class="line">			copy_backward(start.node, finish.node + <span class="number">1</span>, new_nstart + old_num_nodes);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">// map 的空间不足，需要配置新的空间</span></span><br><span class="line">		size_type new_map_size = map_size + max(map_size, nodes_to_add) + <span class="number">2</span>;</span><br><span class="line">		map_pointer new_map = map_allocate::allocate(new_map_size);</span><br><span class="line">		new_nstart = new_map + (new_map_size - new_num_nodes) / <span class="number">2</span></span><br><span class="line">							 + (add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line">		<span class="comment">// 将原 map 拷贝过来</span></span><br><span class="line">		copy(start.node, finish.node + <span class="number">1</span>,</span><br><span class="line">			 new_nstart);</span><br><span class="line">		<span class="comment">// 释放原 map</span></span><br><span class="line">		map_allocate::deallocate(<span class="built_in">map</span>, map_size);</span><br><span class="line">		<span class="comment">// 设定新的 map </span></span><br><span class="line">		<span class="built_in">map</span> = new_map;</span><br><span class="line">		map_size = new_map_size; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 重置迭代器 start 和 finish</span></span><br><span class="line">	start.set_node(new_nstart);</span><br><span class="line">	<span class="comment">// 万分小心这里重置的时候加的是old_num_nodes 因为这里还并没有真正的添加新的节点进来，只是调整的map中节点的位置</span></span><br><span class="line">	<span class="comment">// 然后才会在后续的操作中加入新的节点来，然后会发生再次的调整</span></span><br><span class="line">	finish.set_node(new_nstart + old_num_nodes - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="deque-的元素操作"><a href="#deque-的元素操作" class="headerlink" title="deque 的元素操作"></a>deque 的元素操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (finish.cur != finish.first) &#123;</span><br><span class="line">		<span class="comment">// 最后的缓冲区有一个或者更多的元素</span></span><br><span class="line">		--finish.cur; <span class="comment">// 调整指针，排除了最后元素</span></span><br><span class="line">		destroy(finish.cur); <span class="comment">// 将最后的元素析构</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 最后缓冲区没有任何元素</span></span><br><span class="line">		pop_back_aux();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 finish.cur == finish.first 的时候才会调用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::pop_back_aux() &#123;</span><br><span class="line">	<span class="comment">// 释放最后一个缓冲区</span></span><br><span class="line">	deallocate_node(finish.first); </span><br><span class="line">	finish.set_node(first.node - <span class="number">1</span>);</span><br><span class="line">	finish.cur = finish.last - <span class="number">1</span>;</span><br><span class="line">	destroy(finish.cur); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// front</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (start.cur != start.last - <span class="number">1</span>) &#123;</span><br><span class="line">		destroy(start.cur);</span><br><span class="line">		++start.cur; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		pop_front_aux();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;T, Alloc, Bufsize&gt;::pop_front_aux() &#123;</span><br><span class="line">	<span class="comment">// 将第一缓冲区的第一个，也是最后一个元素析构</span></span><br><span class="line">	destroy(start.cur);</span><br><span class="line">	deallocate_node(start);</span><br><span class="line">	start.set_node(start.node + <span class="number">1</span>);	<span class="comment">// 重新设置节点</span></span><br><span class="line">	start.cur = start.first; <span class="comment">// 下一个缓冲区的第一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h4><p>这个用来清除整个 deque，需要注意的是 deque 的初始状态会保有一个缓冲区，clear() 清除元素的时候也要保留一个缓冲区</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="keyword">typename</span> BufSize&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;T, Alloc, Bufsize&gt;::clear() &#123;</span><br><span class="line">	<span class="comment">// 这些针对头尾意外的缓冲区，这些缓冲区的元素是满的</span></span><br><span class="line">	<span class="keyword">for</span> (map_pointer node = start.node + <span class="number">1</span>; node &lt; finish.node; ++node) &#123;</span><br><span class="line">		<span class="comment">// 清除所有的元素，注意这里使用的是 destroy 的第二版本</span></span><br><span class="line">		destroy(*node, *node + buffer_size());</span><br><span class="line">		<span class="comment">// 释放缓冲区</span></span><br><span class="line">		data_allocator::deallocate(*node, buffer_size());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (start.node != finish.node) &#123; <span class="comment">// 至少有头尾两个缓冲区</span></span><br><span class="line">		destroy(start.cur, start.last); <span class="comment">// 将尾缓冲区的元素释放</span></span><br><span class="line">		destroy(finish.cur, finish.last); <span class="comment">// 将头缓冲区的元素释放</span></span><br><span class="line">		<span class="comment">// 释放尾缓冲区，保留头缓冲区</span></span><br><span class="line">		data_allocator::deallocate(finish.first, finish.buffer_size())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">// 只有一个缓冲区</span></span><br><span class="line">		<span class="comment">// 将缓冲区的元素释放，但是保留该缓冲区</span></span><br><span class="line">		destroy(start.cur, start.finish);</span><br><span class="line">		<span class="comment">// 调整状态</span></span><br><span class="line">		finish = start;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里出现了很多 <code> deallocate()</code>，<code> destroy()</code> 可能会有点晕，这里提以下两者的区别</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocator::deallocate</span><span class="params">(pointer p, size_type n)</span></span></span><br></pre></td></tr></table></figure>

<p>的效果是归还之前配置的空间。</p>
<p>这个是 destroy() 的第一版本，接受一个指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* pointer)</span> </span>&#123;</span><br><span class="line">    pointer-&gt;~T(); <span class="comment">// 调用 dtor ~T()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是 destroy() 的第二版本，接受两个迭代器，该函数会设法找出元素的数组型别，进而利用 __type_traits&lt;&gt; 求取最适当的措施</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123;</span><br><span class="line">	__destroy(first, last, value_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断元素的数值型别是否有 non-trivial destructor</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">void</span> __destroy(ForwardIterator first, ForwardIterator last, T*) &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor;</span><br><span class="line">    __destroy_aux(first, last, trivial_destructor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="erase"><a href="#erase" class="headerlink" title="erase()"></a>erase()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除 pos 所指的元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span> </span>&#123;</span><br><span class="line">	iterator next = pos;</span><br><span class="line">	++next;</span><br><span class="line">	difference_type index = pos - start;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; (size() &gt;&gt; <span class="number">1</span>)) &#123; <span class="comment">// 如果清除点前的元素比较少</span></span><br><span class="line">		copy_backward(start, pos,</span><br><span class="line">		next); 			<span class="comment">// 直接覆盖</span></span><br><span class="line">		pop_front(); <span class="comment">// 移动完成后最后一个元素是冗余的，去除即可</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;  <span class="comment">// 清除点之后的元素比较少，那么就向后移动</span></span><br><span class="line">		copy(next, finish,</span><br><span class="line">			 pos);</span><br><span class="line">		pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> start + index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除 [ first, last ) 之间的元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">template</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;</span><br><span class="line"><span class="built_in">deque</span>&lt;T, Alloc, Bufsize&gt;::iterator</span><br><span class="line"><span class="built_in">deque</span>&lt;T, Alloc, Bufsize&gt;::erase(iterator first, iterator last) &#123;</span><br><span class="line">	<span class="comment">// 如果区间就是整个 deque, 直接调用 clear()</span></span><br><span class="line">	<span class="keyword">if</span> (first == start &amp;&amp; last == finish) &#123;</span><br><span class="line">		clear();</span><br><span class="line">		<span class="keyword">return</span> finish;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		difference_type n = last - finish; <span class="comment">// 清除区间的长度</span></span><br><span class="line">		difference_type elems_before = first - start; <span class="comment">// 清除区间前方的元素个数，用于恢复指针</span></span><br><span class="line">		<span class="keyword">if</span> (elem_before &lt; (size() - n) / <span class="number">2</span>) &#123; <span class="comment">// 如果前方元素较少，那么向后移动前方元素，</span></span><br><span class="line">			copy_backward(start, finish, last);	<span class="comment">// 用来覆盖清除区间</span></span><br><span class="line">			iterator new_start = start + n; <span class="comment">// 标记 deque 的起点</span></span><br><span class="line">			destroy(start, new_start);</span><br><span class="line">			<span class="comment">// 下面释放冗余的缓冲区</span></span><br><span class="line">			<span class="keyword">for</span> (map_pointer cur = start.node; cur &lt; new_start.node; ++cur)</span><br><span class="line">				data_allocator::deallocate(*cur, buffer_size());</span><br><span class="line">			start = new_start; <span class="comment">// 设定 deque 新的起点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="comment">// 清除区间后方的元素较少</span></span><br><span class="line">			copy(last, finish, first); <span class="comment">// 向前移动后方的元素</span></span><br><span class="line">			iterator new_finish = finish - n;</span><br><span class="line">			destroy(new_finish, finish); <span class="comment">// 移动完毕，析构冗余元素</span></span><br><span class="line">			<span class="comment">// 下面析构冗余区间</span></span><br><span class="line">			<span class="keyword">for</span> (map_pointer cur = new_finish.node + <span class="number">1</span>; cur &lt; finish.node; ++cur)</span><br><span class="line">				data_allocator::deallocate(*cur, buffer_size());</span><br><span class="line">			finish = new_finish; <span class="comment">// 设定 deque 的新尾点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> start + elems_before;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">WuTai</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/06/08/STL/">http://example.com/2021/06/08/STL/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/myblog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></div><div class="post_share"><div class="social-share" data-image="https://nargdg.sn.files.1drv.com/y4phk6WBcrJsxkBiGeqOm2CY8TqFueGBG1T_TZ3aDjQ5N609AJ20ykgesGg72o6uGjGpXa_MCs56NVGzJlSDdlR30u0Hc-sBOkREEcCqtGeE1FdUwdGsmP6dQdT4bEOYCgaNEuM8xJveIkylZ5N7HK5fibuo6ruAu7P6wZZDY1ZEqB5V3WVIAubzqpAhbAbGlQzvmQA7JiX5VexX2fM-wCrp9F8AdLdVRSuYfhqzp1HrvQ/hui-6.png?psid=1" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/myblog/2021/05/04/C/%E5%88%A9%E7%94%A8Direct3D%E7%BB%98%E5%88%B6%E5%87%A0%E4%BD%95%E4%BD%93/"><img class="next-cover" src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBay1lZGtWWHhMRVVsQ3lRVmVHZFpzSEdkbUpSP2U9eUswMk9J.jpg" onerror="onerror=null;src='/myblog/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">利用 Direct3D 绘制几何体</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/myblog/2020/10/13/C/C++ 中 const 的使用要点/" title="C++ 中 const 的使用要点"><img class="cover" src="/myblog/img/hui-3.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-13</div><div class="title">C++ 中 const 的使用要点</div></div></a></div><div><a href="/myblog/2021/04/21/C/Effective C++ 55 (04-12)/" title="EffectC++"><img class="cover" src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBay1lZGtWWHhMRVVsQ3MzZTBQNGZSck9ubDQwP2U9THpKZGRG.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-21</div><div class="title">EffectC++</div></div></a></div><div><a href="/myblog/2021/04/19/C/初始化 Direct3D/" title="初始化 Direct3D 12"><img class="cover" src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBay1lZGtWWHhMRVVsQ2tUNUp2QTM1N29ZUGdSP2U9U2VRSnZw.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-19</div><div class="title">初始化 Direct3D 12</div></div></a></div><div><a href="/myblog/2020/10/07/C/并发：互斥与同步的各种实现/" title="并发：互斥与同步的各种实现"><img class="cover" src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBay1lZGtWWHhMRVVsQ2tUNUp2QTM1N29ZUGdSP2U9U2VRSnZw.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-07</div><div class="title">并发：互斥与同步的各种实现</div></div></a></div><div><a href="/myblog/2020/09/26/C/利用汇编深入学习C++/" title="利用汇编深入学习C++"><img class="cover" src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBay1lZGtWWHhMRVVsQ3lRVmVHZFpzSEdkbUpSP2U9eUswMk9J.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-26</div><div class="title">利用汇编深入学习C++</div></div></a></div><div><a href="/myblog/2020/11/04/C/操作系统主要考察点/" title="操作系统复习"><img class="cover" src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBay1lZGtWWHhMRVVsQ2RqN3NQVVFfYi1fOFFkP2U9VlpKWHRF.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-04</div><div class="title">操作系统复习</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div><div class="comment-switch"><span class="first-comment">V</span><label><input id="switch-comments-btn" type="checkbox"/><span class="slider"></span></label><span class="second-comment">a</span></div></div><div class="comment-wrap"><div></div><div></div><div></div><div></div><div></div><div></div></div></div></article></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By WuTai</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/myblog/js/utils.js"></script><script src="/myblog/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  var script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>